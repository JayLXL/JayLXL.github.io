<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jay and Erine&#39;s Blog</title>
  
  
  <link href="https://jayerine.top/atom.xml" rel="self"/>
  
  <link href="https://jayerine.top/"/>
  <updated>2024-02-06T04:00:21.577Z</updated>
  <id>https://jayerine.top/</id>
  
  <author>
    <name>Jay and Erine</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试记录</title>
    <link href="https://jayerine.top/2024/02/06/137184bfb43a/"/>
    <id>https://jayerine.top/2024/02/06/137184bfb43a/</id>
    <published>2024-02-06T04:00:21.577Z</published>
    <updated>2024-02-06T04:00:21.577Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2023-11-10"><a href="#2023-11-10" class="headerlink" title="2023.11.10"></a>2023.11.10</h3><ul><li>单位：字节跳动</li><li>类型：开发<br>第一次面试，有很多可以改进的地方：</li><li>线上面试，最好使用电脑，因为可能需要做题。</li><li>项目经历没有准备充分。自我介绍和后续的提问会主要围绕项目展开。</li><li>考察了数据库的相关内容，问了数据隔离和建立索引，没有答上来</li><li>出了一个简单的编程题，括号匹配，使用oj作答。<br>总共面试了快一个小时，面试老师感觉比较有耐心，没想到会让现场答题。总体感觉不太好，应该是寄了。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;2023-11-10&quot;&gt;&lt;a href=&quot;#2023-11-10&quot; class=&quot;headerlink&quot; title=&quot;2023.11.10&quot;&gt;&lt;/a&gt;2023.11.10&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;单位：字节跳动&lt;/li&gt;
&lt;li&gt;类型：开发&lt;br&gt;第一次面试，</summary>
      
    
    
    
    <category term="简历" scheme="https://jayerine.top/categories/%E7%AE%80%E5%8E%86/"/>
    
    
  </entry>
  
  <entry>
    <title>git使用</title>
    <link href="https://jayerine.top/2024/02/06/bb4263303c4c/"/>
    <id>https://jayerine.top/2024/02/06/bb4263303c4c/</id>
    <published>2024-02-06T04:00:21.577Z</published>
    <updated>2024-02-06T04:00:21.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目分支情况"><a href="#项目分支情况" class="headerlink" title="项目分支情况"></a>项目分支情况</h2><ul><li>远程分支：目前只需要一个远程master分支就好，大家直接在上面开发提交。</li><li>本地分支，建议也是一个就够用了，绑定远程的master分支。如果想随便写东西实验，新建其他分支就好。<h2 id="安装项目到本地"><a href="#安装项目到本地" class="headerlink" title="安装项目到本地"></a>安装项目到本地</h2></li></ul><ol><li>在新建文件夹路径下创建git仓库：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li><li>添加远程仓库：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin https://gitee.com/lei-xilin/ScheduleManager.git</span><br></pre></td></tr></table></figure></li><li>下拉远程分支：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></li><li>本地master分支绑定远程master分支：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/master master</span><br></pre></td></tr></table></figure></li><li>测试：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure> 若出现“Already up to date.”说明成功。</li></ol><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h3 id="打开电脑，首先先拉取最新的代码："><a href="#打开电脑，首先先拉取最新的代码：" class="headerlink" title="打开电脑，首先先拉取最新的代码："></a>打开电脑，首先先拉取最新的代码：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h4 id="若出现冲突，则进行解决-解决完冲突之后，先提交，然后再次拉取代码，最后将解决完冲突的合并代码上传。"><a href="#若出现冲突，则进行解决-解决完冲突之后，先提交，然后再次拉取代码，最后将解决完冲突的合并代码上传。" class="headerlink" title="若出现冲突，则进行解决,解决完冲突之后，先提交，然后再次拉取代码，最后将解决完冲突的合并代码上传。"></a>若出现冲突，则进行解决,解决完冲突之后，先提交，然后再次拉取代码，最后将解决完冲突的合并代码上传。</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -a -m 解决冲突</span><br><span class="line">git pull</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h4 id="若无冲突，正常开始工作。"><a href="#若无冲突，正常开始工作。" class="headerlink" title="若无冲突，正常开始工作。"></a>若无冲突，正常开始工作。</h4><h3 id="工作完成，进行代码提交"><a href="#工作完成，进行代码提交" class="headerlink" title="工作完成，进行代码提交"></a>工作完成，进行代码提交</h3><p>若有新建文件需要上传，先添加该文件：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add &lt;新加入的文件&gt;</span><br></pre></td></tr></table></figure><br>之后进行本地提交：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -a -m 某工作完成</span><br></pre></td></tr></table></figure><br>最后提交到远程分支：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></p><p>若出现冲突，则先pull，手动修改冲突，本地提交之后重新提交到远程分支。</p><h2 id="常用git命令"><a href="#常用git命令" class="headerlink" title="常用git命令"></a>常用git命令</h2><p>追踪所有文件：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add -A .</span><br></pre></td></tr></table></figure><br>合并分支：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge &lt;branch name&gt;</span><br></pre></td></tr></table></figure><br>强制覆盖本地分支：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull --allow-unrelated-histories</span><br></pre></td></tr></table></figure><br>抛弃所有未保存的修改，回到最近一次commit的状态：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure><br>本地回滚到某个commit，xxxxxx为commit编号：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard xxxxxx</span><br></pre></td></tr></table></figure><br>查看当前文件状态，文件状态常见的有untracked(未跟踪)，modified(已修改)，deleted(已删除)等：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><br>查看所有分支名称:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><br>查看所有分支的绑定情况：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure><br>新建本地分支：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;name&gt;</span><br></pre></td></tr></table></figure><br>删除本地分支：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure><br>查看本地提交记录：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><br>查看远程分支<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><br>移除远程分支<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote remove &lt;name&gt;</span><br></pre></td></tr></table></figure></p><h2 id="本地项目首次上传远程仓库"><a href="#本地项目首次上传远程仓库" class="headerlink" title="本地项目首次上传远程仓库"></a>本地项目首次上传远程仓库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> existing_git_repo</span><br><span class="line">git remote add origin https://gitee.com/lei-xilin/chat-gpt.git</span><br><span class="line">git push --set-upstream origin master</span><br></pre></td></tr></table></figure><p>将不想上传的文件加入.gitignore文件中。</p><p>查看追踪的文件：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git ls-tree -r master --name-only</span><br></pre></td></tr></table></figure></p><h2 id="设置-gitignore文件"><a href="#设置-gitignore文件" class="headerlink" title="设置.gitignore文件"></a>设置.gitignore文件</h2><p>对于一些本地化的配置，或者运行时生成文件，最好设置成.gitignore。<br>清除所有索引：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> -r --cached .</span><br></pre></td></tr></table></figure><br>修改.gitignore文件，重新提交，设置忽略文件完成。</p><h2 id="设置ssh协议提交"><a href="#设置ssh协议提交" class="headerlink" title="设置ssh协议提交"></a>设置ssh协议提交</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;comment&quot;</span></span><br></pre></td></tr></table></figure><p>查看ssh的公钥，提交到网站上</p><p>注意，添加远程仓库的时候，必须要添加ssh的链接</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;项目分支情况&quot;&gt;&lt;a href=&quot;#项目分支情况&quot; class=&quot;headerlink&quot; title=&quot;项目分支情况&quot;&gt;&lt;/a&gt;项目分支情况&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;远程分支：目前只需要一个远程master分支就好，大家直接在上面开发提交。&lt;/li&gt;
&lt;li&gt;本</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="git" scheme="https://jayerine.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>vscode配置opencv C++ 环境与人脸检测（不是人脸识别）算法的尝试</title>
    <link href="https://jayerine.top/2024/02/06/f554b43ffd79/"/>
    <id>https://jayerine.top/2024/02/06/f554b43ffd79/</id>
    <published>2024-02-06T04:00:21.577Z</published>
    <updated>2024-02-06T04:00:21.577Z</updated>
    
    <content type="html"><![CDATA[<p>​<a href="https://blog.csdn.net/m0_61322309/article/details/124214186?spm=1001.2014.3001.5501">csdn</a><br>估计这学期都去不了学校了，家里蹲大学马上要线上期中考。。。在家呆久了无聊想学点机器视觉的东西，之前在学校双创课上做过python的机器视觉实验，想起来挺有意思的，但是还是比较喜欢C++，就找到了这个看上去还不错的C++开源项目 ，opencv。</p><p>首先是配置opencv环境。看了很多教程，下面这个是最详细的，最后是参照上面这篇博客 成功完成了配置，感谢大佬。之前出现过很多奇怪的问题，也学到了一些经验，在这里记录一下。</p><p>1.MinGW的版本问题：之前是在电脑里装了MinGW环境的，所以直接按照教程安装了Cmake，结果configure的时候一直报错“MinGW缺少mingw-make.exe”，查找MinGW目录，明明有这个文件。后来发现MinGW不是最新版的，而且有博客提起过，只有seh版的MinGW才能Cmake中成功的configure。于是删了MinGW，重新安装了一下MinGW。而且发现由于奇怪的网络问题，MinGW不能在线安装了，于是下载安装压缩包安装上了版本正确的MinGW。好像这种python库或c++库的安装都很有时效性，各软件版本正确是很关键的。</p><p>2.Cmake的configure过程，要下载一些东西，有时候由于奇怪的问题下载不了，列表会变红，这时候可以通过科学上网，或者手动搜索下载无法下载的文件补上。新建一个文件夹作为“where to build the binaries”地址选项，不然后面会很乱。</p><p>3.由于之前配置过了vscode的各种json文件，就直接在上面改了，开始我只在IncludePath下添加了新的opencv的相关头文件路径，结果是编辑器检测没报错，按住ctrl键也可以打开查看源文件，但是一编译就报错无法打开头文件，查了好多资料才知道，c_cpp_properties.josn中添加的路径只是告诉编辑器的，让编辑器不打红色波浪线，但是此时编译器还不知道这个引用，要在tasks.json中添加相关的路径才会正常编译。并且了解到了.dll(用于动态链接库导出函数，在运行期间链接）.lib(用于动态链接库导出函数，在编译期间）和.a（静态库文件）的区别。以及“-I”（小写L） “-I”（大写i）命令，相当于添加动态程序库链接，静态文件库链接之类的。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;tasks&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">        <span class="string">&quot;label&quot;</span>: <span class="string">&quot;opencv&quot;</span>,</span><br><span class="line">        <span class="string">&quot;command&quot;</span>: <span class="string">&quot;D:/mingw64/bin/g++.exe&quot;</span>,</span><br><span class="line">        <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;-g&quot;</span>,</span><br><span class="line">            <span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-o&quot;</span>,</span><br><span class="line">            <span class="string">&quot;$&#123;workspaceFolder&#125;\\Debugger\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,</span><br><span class="line">            <span class="string">&quot;D:/opencv/build/x64/mingw/bin/libopencv_world455.dll&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-I&quot;</span>,</span><br><span class="line">            <span class="string">&quot;D:/opencv/build/x64/mingw/install/include&quot;</span>,<span class="comment">//需要添加的路径</span></span><br><span class="line">            <span class="string">&quot;-I&quot;</span>,</span><br><span class="line">            <span class="string">&quot;D:/opencv/build/x64/mingw/install/include/opencv2&quot;</span>,<span class="comment">//需要添加的路径</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;options&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;D:/mingw64/bin&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;problemMatcher&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;group&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">            <span class="string">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br>4.发现搞清楚这个问题之后，face.cpp头文件还是会报错，结果是最新版的opencv把这个头文件暂时下架了，原因是不稳定，要重新开发，网上教程说要在另一个库里opencv_contrib自行下载。。。这个源文件。</p><p>搞清楚了环境的安装配置之后，头文件终于不报错了，也可以正常编译了。马上按照网上的代码学习尝试了下opencv自带的人脸检测算法。在刚刚下载的opencv中，可以找到这些文件。</p><p> 据说这些文件是github大佬们将模型训练之后得到的数据样本库，通过调用一个opencv里的函数就可以利用这些模型的数据做相关的一些实验了。里面有各种各样的模型，有的是检测人脸的，有的是检测上半身的，有的是检测眼睛部位的。总之感觉都很神奇。</p><p>然后是学习代码时间，了解一下相关的工序，将图片灰度化，均衡化什么的，建立连级检测器，导入刚刚的分类器训练文件，熟悉下opencv的基本文件操作：</p><p>1-遍历文件夹内的文件，通过glode函数实现，大概就是读取指定文件夹下的路径保存在一个vector中；</p><p>2-imread()读取图片文件，namewindow()显示图片的窗体。imwrite()写入图片；</p><p>之后我利用下面的代码尝试了下，在一个文件夹下挑选出含有人脸的jpg或png格式的图片，看看效果。<br>​<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/objdetect.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line">CascadeClassifier face_cascade[<span class="number">4</span>];<span class="comment">//建立连级采样器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">detect</span><span class="params">( Mat frame ,<span class="type">int</span> i,cv::String name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat frame_gray;</span><br><span class="line">Mat converse;</span><br><span class="line">    <span class="built_in">cvtColor</span>( frame, frame_gray, COLOR_BGR2GRAY );<span class="comment">//颜色空间转换函数，将图像转化为灰度图像</span></span><br><span class="line">    <span class="built_in">equalizeHist</span>( frame_gray, frame_gray );<span class="comment">//直方图均衡化函数</span></span><br><span class="line">    std::vector&lt;Rect&gt; faces;<span class="comment">//RECT类用于描述矩形</span></span><br><span class="line"><span class="comment">//flip(frame_gray,converse,1);//反转图片,可用于侧脸检测</span></span><br><span class="line"><span class="type">bool</span> isfind=<span class="literal">false</span>;</span><br><span class="line">face_cascade[<span class="number">1</span>].<span class="built_in">detectMultiScale</span>(frame_gray, faces);<span class="comment">//用于检测的函数</span></span><br><span class="line"><span class="keyword">if</span>(faces.<span class="built_in">size</span>())&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;张图片中发现&quot;</span>&lt;&lt;faces.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;张脸&quot;</span>&lt;&lt;endl;</span><br><span class="line">string a;</span><br><span class="line"><span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">itoa</span>(i+<span class="number">1</span>,s,<span class="number">10</span>);</span><br><span class="line">a=s;</span><br><span class="line"><span class="built_in">imwrite</span>(<span class="string">&quot;C:/Users/notbadhhhh/Desktop/4\\&quot;</span>+a+<span class="string">&quot;.jpg&quot;</span>,frame);</span><br><span class="line">a=name;</span><br><span class="line"><span class="type">int</span> resort=<span class="built_in">remove</span>(a.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="comment">//namedWindow(&quot;w&quot;);</span></span><br><span class="line"><span class="comment">//imshow( &quot;w&quot;, frame );</span></span><br><span class="line"><span class="comment">//waitKey(3000);</span></span><br><span class="line"><span class="comment">//显示图片</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;张图片中未发现人脸&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pre_check</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!face_cascade[<span class="number">1</span>].<span class="built_in">load</span>(<span class="string">&quot;C:/Users/notbadhhhh/Desktop/haarcascade_frontalface_default.xml&quot;</span>)) <span class="comment">//opencv自带的人脸识别,需要下载</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--(!)Error loading face cascade\n&quot;</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(!face_cascade[<span class="number">2</span>].<span class="built_in">load</span>(<span class="string">&quot;C:/Users/notbadhhhh/Desktop/haarcascade_profileface.xml&quot;</span>)) <span class="comment">//opencv自带的人脸识别,需要下载</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--(!)Error loading face cascade\n&quot;</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(!face_cascade[<span class="number">3</span>].<span class="built_in">load</span>(<span class="string">&quot;C:/Users/notbadhhhh/Desktop/haarcascade_eye_tree_eyeglasses.xml&quot;</span>)) <span class="comment">//opencv自带的人脸识别,需要下载</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--(!)Error loading face cascade\n&quot;</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(!face_cascade[<span class="number">4</span>].<span class="built_in">load</span>(<span class="string">&quot;C:/Users/notbadhhhh/Desktop/haarcascade_eye.xml&quot;</span>)) <span class="comment">//opencv自带的人脸识别,需要下载</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--(!)Error loading face cascade\n&quot;</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//可同时导入多个训练模型文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;chcp 65001&quot;</span>),<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);<span class="comment">//让编译器能输出中文</span></span><br><span class="line"><span class="type">bool</span> is=<span class="built_in">pre_check</span>();</span><br><span class="line">    <span class="keyword">if</span>(!is)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">string origin_deposite=<span class="string">&quot;C:/Users/notbadhhhh/Desktop/python1.4&quot;</span>;<span class="comment">//目标文件夹</span></span><br><span class="line">string pattern_jpg=origin_deposite+<span class="string">&quot;/*jpg&quot;</span>;</span><br><span class="line">string pattern_png=origin_deposite+<span class="string">&quot;/*png&quot;</span>;</span><br><span class="line">vector&lt;cv::String&gt; image_files_jpg,image_files_png;</span><br><span class="line"><span class="built_in">glob</span>(pattern_jpg,image_files_jpg);</span><br><span class="line"><span class="built_in">glob</span>(pattern_png,image_files_png);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;image_files_jpg.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">Mat pic=<span class="built_in">imread</span>(image_files_jpg[i]);</span><br><span class="line"><span class="keyword">if</span> (pic.<span class="built_in">empty</span>())cout &lt;&lt; <span class="string">&quot; wrong&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">bool</span> b=<span class="built_in">detect</span>(pic,i,image_files_jpg[i]);</span><br><span class="line"><span class="keyword">if</span>(b)sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//遍历文件夹下的jpg图片</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;image_files_png.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">Mat pic=<span class="built_in">imread</span>(image_files_png[i]);</span><br><span class="line"><span class="keyword">if</span> (pic.<span class="built_in">empty</span>())cout &lt;&lt; <span class="string">&quot; wrong&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">bool</span> b=<span class="built_in">detect</span>(pic,i,image_files_png[i]);</span><br><span class="line"><span class="keyword">if</span>(b)sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//遍历文件夹下的png图片</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;一共筛选出了&quot;</span>&lt;&lt;sum&lt;&lt;<span class="string">&quot;张含有人脸的照片&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>反复测试了多个训练器模型文件后，发现这些模型的识别准确率远低于我的预期，误检率和漏检率都非常的高。。。反复调试了detectMultiScale的七个参数，发现正确率始终不是很高。用三十张含有人脸的照片，最好的一次检出了二十一张含有人脸，也就是70%左右。不知道是我的参数没设置合适还是其他什么原因，正确率基本上不超过70%。检测人眼的，和检测上半身的正确率更离谱。。。上网也没查到什么资料（一查人脸检测的讨论，出来的都是人脸识别）。而且检测很耗时，基本上一张图片要几秒钟。</p><p>虽然这不是最好的人脸检测算法，但是也不至于这么低吧，我以为至少有百分之九十以上准确率。结果比较失望。了解到还有一些其他的比较优秀的人脸检测算法，但是限于缺少获取途径和能力（好像他们不是开源的），无法再简单的实践体验了。</p><p>想问问有大佬知道这个算法的最优正确率有多高吗？或者怎么改进提高检测正确率？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​&lt;a href=&quot;https://blog.csdn.net/m0_61322309/article/details/124214186?spm=1001.2014.3001.5501&quot;&gt;csdn&lt;/a&gt;&lt;br&gt;估计这学期都去不了学校了，家里蹲大学马上要线上期中考。。。在</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="csdn" scheme="https://jayerine.top/tags/csdn/"/>
    
    <category term="机器学习" scheme="https://jayerine.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>两棵树（可持久线段树+Hash+高精度数）</title>
    <link href="https://jayerine.top/2024/02/06/0e751f91670a/"/>
    <id>https://jayerine.top/2024/02/06/0e751f91670a/</id>
    <published>2024-02-06T04:00:21.577Z</published>
    <updated>2024-02-06T04:00:21.577Z</updated>
    
    <content type="html"><![CDATA[<p>​<a href="https://blog.csdn.net/m0_61322309/article/details/123586007?spm=1001.2014.3001.5502">csdn</a><br>Problem Description</p><p>给定两棵n个点的有根树，每棵 树的根节点都是1，点的编号为1到n。 定义d(x)为x在第一棵树上到1号点的最短路加上x在 第二棵树上到1号点的最短路，请将1到n按照d从小到 大排序。如果两个点的d相等，则编号小的排在前面。</p><p>Input</p><p>第一行一个正整数T(1 ≤ T ≤ 5)，表示测试数 据的数量。</p><p>每组数据第一行一个正整数n(2 ≤ n ≤ 100000)。 接下来n − 1行，第i行4个正整数a, x, b, y(1 ≤ a, b ≤ i, 1 ≤ x, y ≤ n)，表示i + 1号点在第一棵树上的父亲 是a，它到它父亲的距离为100000000x，i+1号点在第二 棵树上的父亲是b，它到它父亲的距离为100000000y。</p><p>Output</p><p>每组数据输出n行，第i行输出排序结果中 第i小的点的编号。</p><p>输入样例<br><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br><span class="line">1 2 1 3</span><br><span class="line">2 1 1 5</span><br><span class="line">1 2 3 1</span><br><span class="line">4 2 2 4</span><br></pre></td></tr></table></figure></p><p>输出样例<br><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><br>题意很简单，就是给定两棵有n个节点的树，以1作为树根，求某一个点在两棵树中到1号树根节点的距离之和，按照距离之和从小到大输出节点的编号。若不考虑数据范围，可以通过链式前向星建立两个有向图，从根节点两遍深度优先搜索记录每一个点到根节点的距离之和，然后利用sort函数排序输出。但是考虑到树的边权很大，都是100000000的x次方，无法用正常的变量存储距离的值。</p><p>于是使用高精度数处理。将每条边的值看作100000000进制下的数，则长为100000000的x次方的边可表示为100<strong>*</strong>00（1后面x个零）。在一棵树中，一个点到树根的距离等于其父亲节点到树根的距离，加上该节点到其父亲节点的距离。由于这个高精度数距离很大，所以不会发生进位（发生进位需要加100000000次1，而数据范围最多到十万），从父亲节点到该节点，只是在某一位加上了1，由此可联想到可持久线段树的单点修改。</p><p>维护这样一个可持久线段树，线段树中的元素为高精度数的其中一位。每一个版本的线段树，表示一个n位的点到树根距离的高精度数。因为x,y范围小于十万，所以高精度数的位数不会超过十万，因此线段树中维护的元素不会超过十万。在网上查了下可持久线段树的内存，一般说开到三十二倍数据范围，但是这题其实开到lg100000/lg2+1,差不多20倍就可以了，开到32倍100000kb都容易MLE。</p><p>解决了单棵树的建图和存储，接下来的问题是比较两棵树节点距离之和的大小关系。直接去从高到低一位一位相加再比较大小的话，每比较两个数，复杂度都是n，加上sort的复杂度，n^2lgn很明显会超时。这时候想到用字符串hash实现。由于不太会字符串hash，开始写WA了好多次，在大佬的帮助下才找到正确的hash算法。</p><p>在线段树二分结构和hash的帮助下，通过递归判断两棵树的子树hash值相加是否相等，可以在lgn的复杂度下判断高精度数的前n位是否相等，直到找到第n位不一样的位数值，判断大小即可。这个hash函数，首先要满足可加性，其次是冲突的概率要非常的小，以正确的去维护两棵树的和。最开始为了减小冲突，想到用普通的双hash，但是这样的话一来减小冲突的作用有限，二来要存两遍hash值很容易MLE。问大佬告诉使用字符串hash，先预处理生成一个用于取模的数的数组。这样能尽可能避免冲突。</p><p>下面是AC代码<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span><span class="comment">//getline的头文件，与string.h不同</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P1 233</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P 1000000007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> si maxn*20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> l[si][<span class="number">2</span>],r[si][<span class="number">2</span>],root[maxn][<span class="number">2</span>],tot[<span class="number">2</span>];</span><br><span class="line">ll ha[maxn],val[si][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> head[maxn][<span class="number">2</span>],ne[maxn&lt;&lt;<span class="number">1</span>],len[maxn&lt;&lt;<span class="number">1</span>],to[maxn&lt;&lt;<span class="number">1</span>],cnt;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hash1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ha[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">        ha[i]=ha[i<span class="number">-1</span>]*<span class="number">10007</span>;</span><br><span class="line">        ha[i]%=P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> lenth,<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">    ne[cnt]=head[a][now];</span><br><span class="line">    len[cnt]=lenth;</span><br><span class="line">    to[cnt]=b;</span><br><span class="line">    head[a][now]=cnt;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">initia</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y=tot[now]++;</span><br><span class="line">    <span class="keyword">if</span>(left==right)<span class="keyword">return</span> y;</span><br><span class="line">    <span class="type">int</span> m=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    l[y][now]=<span class="built_in">initia</span>(left,m,now);</span><br><span class="line">    r[y][now]=<span class="built_in">initia</span>(m+<span class="number">1</span>,right,now);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hash</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num=R-(R+L)/<span class="number">2</span>;</span><br><span class="line">    val[y][now]=(val[l[y][now]][now]*ha[num]+val[r[y][now]][now])%P;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> od,<span class="type">int</span> num,<span class="type">int</span> lf,<span class="type">int</span> ri,<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y=tot[now]++;</span><br><span class="line">    <span class="keyword">if</span>(lf==ri)&#123;</span><br><span class="line">        val[y][now]=val[od][now]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m=(lf+ri)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=m)&#123;</span><br><span class="line">        l[y][now]=<span class="built_in">build</span>(l[od][now],num,lf,m,now);</span><br><span class="line">        r[y][now]=r[od][now];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        l[y][now]=l[od][now];</span><br><span class="line">        r[y][now]=<span class="built_in">build</span>(r[od][now],num,m+<span class="number">1</span>,ri,now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Hash</span>(y,lf,ri,now);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> lf=<span class="number">1</span>,ri=n,x1=root[a][<span class="number">0</span>],x2=root[a][<span class="number">1</span>],y1=root[b][<span class="number">0</span>],y2=root[b][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(lf!=ri)&#123;</span><br><span class="line">        <span class="type">int</span> m=(lf+ri)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="type">bool</span> an=(val[r[x1][<span class="number">0</span>]][<span class="number">0</span>]+val[r[x2][<span class="number">1</span>]][<span class="number">1</span>])%P==(val[r[y1][<span class="number">0</span>]][<span class="number">0</span>]+val[r[y2][<span class="number">1</span>]][<span class="number">1</span>])%P;<span class="comment">//一定要将hash值相加后取余数再判断是否相等！！！</span></span><br><span class="line">        <span class="keyword">if</span>(an)&#123;</span><br><span class="line">            ri=m;</span><br><span class="line">            x1=l[x1][<span class="number">0</span>];</span><br><span class="line">            x2=l[x2][<span class="number">1</span>];</span><br><span class="line">            y1=l[y1][<span class="number">0</span>];</span><br><span class="line">            y2=l[y2][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            lf=m+<span class="number">1</span>;</span><br><span class="line">            x1=r[x1][<span class="number">0</span>];</span><br><span class="line">            x2=r[x2][<span class="number">1</span>];</span><br><span class="line">            y1=r[y1][<span class="number">0</span>];</span><br><span class="line">            y2=r[y2][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((val[x1][<span class="number">0</span>]+val[x2][<span class="number">1</span>])%P==(val[y1][<span class="number">0</span>]+val[y2][<span class="number">1</span>])%P)<span class="keyword">return</span> a&lt;b;</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">return</span> val[x1][<span class="number">0</span>]+val[x2][<span class="number">1</span>]&lt;val[y1][<span class="number">0</span>]+val[y2][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> fa,<span class="type">int</span> lenth,<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">    root[node][now]=<span class="built_in">build</span>(root[fa][now],lenth,<span class="number">1</span>,n,now);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[node][now];~i;i=ne[i])<span class="built_in">dfs</span>(to[i],node,len[i],now);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T,a,x,b,y;</span><br><span class="line">    <span class="built_in">hash1</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;T;t++)&#123;</span><br><span class="line">        cnt=<span class="number">0</span>,tot[<span class="number">0</span>]=<span class="number">0</span>,tot[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(val,<span class="number">0</span>,<span class="built_in">sizeof</span>(val));</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;a,&amp;x,&amp;b,&amp;y);</span><br><span class="line">            <span class="built_in">add</span>(a,i,x,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">add</span>(b,i,y,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        root[<span class="number">0</span>][<span class="number">0</span>]=<span class="built_in">initia</span>(<span class="number">1</span>,n,<span class="number">0</span>);</span><br><span class="line">        root[<span class="number">0</span>][<span class="number">1</span>]=<span class="built_in">initia</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> ans[maxn];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)ans[i]=i;</span><br><span class="line">        <span class="built_in">sort</span>(ans+<span class="number">1</span>,ans+n+<span class="number">1</span>,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一步，输入，链式前向星分别对两棵树建立有向图</span></span><br><span class="line"><span class="comment">第二步，从一号节点开始，分别对两棵树进行深度搜索，并用可持久线段树记录相应节点到一号节点距离的高精度数</span></span><br><span class="line"><span class="comment">注意到对于树中的每个节点，其到一号点的距离等于他父亲节点的距离大小，在高精度进制下某一位加一，故可以用节点的编号作为可持久线段树的版本树根，对于每一个节点到一号点的距离，</span></span><br><span class="line"><span class="comment">可通过其父亲节点的对应版本的线段树进行单点修改</span></span><br><span class="line"><span class="comment">第三步，利用cmp函数排序，递归判断线段树左右子树的Hash值，若右子树的的hash相等，说明高位相等，递归搜索左子树，直到l==r，判断两树节点到一号点的距离和是否相等，</span></span><br><span class="line"><span class="comment">若相等，则按序号大小排序，否则按该位的大小排序</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​&lt;a href=&quot;https://blog.csdn.net/m0_61322309/article/details/123586007?spm=1001.2014.3001.5502&quot;&gt;csdn&lt;/a&gt;&lt;br&gt;Problem Description&lt;/p&gt;
&lt;p&gt;给定两</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="csdn" scheme="https://jayerine.top/tags/csdn/"/>
    
    <category term="ACM" scheme="https://jayerine.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>创新课程</title>
    <link href="https://jayerine.top/2024/02/06/19d418e9f6fa/"/>
    <id>https://jayerine.top/2024/02/06/19d418e9f6fa/</id>
    <published>2024-02-06T04:00:21.577Z</published>
    <updated>2024-02-06T04:00:21.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TRIZ"><a href="#TRIZ" class="headerlink" title="TRIZ"></a>TRIZ</h2><ul><li>创始人：阿奇舒勒</li><li>40种原理</li><li>发明家式的解决任务理论<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3></li><li>解决技术问题</li><li>预测未来难题<h3 id="如何解决一个问题？"><a href="#如何解决一个问题？" class="headerlink" title="如何解决一个问题？"></a>如何解决一个问题？</h3></li><li>传统解决方案：</li></ul><ol><li>灵光乍现</li><li>试错</li></ol><ul><li>TRIZ：<br>  例如：组合原理<ol><li>空间、时间上将各种功能整合</li><li>将相同或相反的功能整合 </li></ol></li><li>技术矛盾<br>“又要马儿跑，又要马儿不吃草。”————了解改善参数、恶化参数，通过统计学方法查表分析。</li><li>技术进化趋势：</li></ul><ol><li>产品发展有固定规律吗？<br> 由功能简单，到功能复杂，再由结构复杂，到结构尽量简单。</li><li>产品生命周期不同阶段研发侧重点：<br>功能实现-&gt;功能实现最大化-&gt;性能最大化-&gt;效率最大化-&gt;可靠性最大化-&gt;成本最小化</li><li>常见发展规律<ul><li>由静态变为动态</li><li>由单体变为系统</li><li>空间分割趋势</li><li>物体分割趋势</li><li>可控度增加（手动向自动发展）</li><li>引入物质的趋势</li><li>表面分割的趋势</li><li>维度的上升</li><li>表面曲面化趋势</li><li>增加裁剪度</li></ul></li></ol><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>栈帧（stack frame）和堆：</p><ul><li>一个线程一个栈</li><li>堆是程序运行时动态分配的空间<br>栈里的空间随着程序弹栈自动释放，JVM负责堆的空间管理。</li></ul><p>同一个对象，释放了两次，则会产生NullPointerException（野指针），这是所有语言需要面对的问题。go语言和Java类似，使用GC自动维护内存空间。在不同线程中，都存在并发问题，同时访问一个内存空间。</p><p>语言的发展历史：</p><ul><li>C/C++：手工管理内存（malloc free / new delete），容易产生内存泄漏，可以通过重启电脑解决，容易产生释放多次，产生非常难调试的bug，导致运行效率高，但是开发效率低。</li><li>python java go: 自带GC机制，方便内存管理。只需要分配内存，垃圾回收器负责回收。但是Java没有解决空指针的问题。执行效率相对比较低。</li><li>rust：严格的内存安全，兼顾运行效率。</li></ul><p>Garbage如何确定？  </p><ul><li>引用指向法（reference count）：python使用，在每个引用下计数，当计数为0时标记为垃圾。存在问题，当循环引用时，出现一堆垃圾。</li><li>根可达算法（root searching）：从根开始遍历，如果没有遍历到，则为垃圾。根包括一些栈，静态池等。</li></ul><p>GC算法</p><ul><li>Mark-Sweep 标记清除<br>容易导致内存碎片化</li><li>Copying 拷贝<br>边找边复制，但是浪费内存</li><li>Mark-Compact 标记压缩<br>在回收的过程中整理，但是效率低</li></ul><p>三种算法的综合运用，诞生了各种各样的垃圾回收器。</p><p>GC的演化过程（随着内存大小的不断增大而演进）</p><ul><li><p>分带算法：分为新生带和老年代<br>新生带使用拷贝算法，会回收90%的对象。<br>eden(8)—-survivor(1)—-survivor(1)—-tenured(30)</p></li><li><p>内存几兆-几十兆时，使用Serial，单线程时间停止复制回收。</p></li><li>内存几十兆-上百兆1G时，parallel并行多线程</li><li>内存几十G时，线程过多，线程上下文切换需要巨大的资源，concurrent GC，此时业务线程和GC线程并发。</li></ul><p>通常情况，Java 1.8版本使用ps+po。ParNew 工作在年轻带的多线程。</p><p>CMS concurrent mark sweep：<br>初始标记（stw标记root）-&gt;并发标记-&gt;重新标记（stw三色标记算法）-&gt;并发清理</p><h2 id="自主研修学习心得"><a href="#自主研修学习心得" class="headerlink" title="自主研修学习心得"></a>自主研修学习心得</h2><h3 id="自主研修课一：创新创业类教育"><a href="#自主研修课一：创新创业类教育" class="headerlink" title="自主研修课一：创新创业类教育"></a>自主研修课一：创新创业类教育</h3><ol><li>学习内容：<br>Triz理论的发展历史、Triz理论的用途，产品的创新过程，人类社会发展中，科学技术进步的规律，如以下常见的产品技术发展规律：<ul><li>由静态变为动态</li><li>由单体变为系统</li><li>空间分割趋势</li><li>物体分割趋势</li><li>可控度增加（手动向自动发展）</li><li>引入物质的趋势</li><li>表面分割的趋势</li><li>维度的上升</li><li>表面曲面化趋势</li><li>增加裁剪度</li></ul></li><li>学习收获：<br>以前在思考创新点的时候，缺少系统的训练和方法，导致经常缺乏灵感。通过学习Triz理论，我学习到了如何利用这些方法和规律，进行思考和创新。<h3 id="自主研修课二：系统地学习一门软件或硬件开发"><a href="#自主研修课二：系统地学习一门软件或硬件开发" class="headerlink" title="自主研修课二：系统地学习一门软件或硬件开发"></a>自主研修课二：系统地学习一门软件或硬件开发</h3></li><li>学习内容：<br>android应用程序的开发，包括android studio软件的使用，android虚拟机和真机的编程调试，android系统的内存交互。Java语言语法，包括面向对象编程的各种技术，多线程技术，lambda表达式。学习了android底层DVM的工作机制和kotlin语言的编译运行原理，了解了Java语言中的JVM，JDK，JRE，深入学习了JVM中的内存管理机制GC中的CMS垃圾回收算法。</li><li>学习收获：<br>对于android应用程序的开发，更加熟悉了，同时借助android开发的实践，学习了解了Java语言的语法知识，并且深入学习了Java虚拟机的原理，对于以后的移动应用开发打下了基础。<h3 id="自主研修课三：人工智能类"><a href="#自主研修课三：人工智能类" class="headerlink" title="自主研修课三：人工智能类"></a>自主研修课三：人工智能类</h3></li><li>学习内容：<br>吴恩达机器学习，基础机器学习算法，包括线性回归，最小梯度法，K-Means，支持向量机等算法。<br>数据结构的相关算法，如Splay算法，二分答案、贪心搜索、模拟、压状dp、平衡树算法、查并集、欧拉线性筛、图论、拓扑排序、数论基础（费马小定理、逆元运算、欧拉线性筛）、快速幂等。</li><li>学习收获：<br>通过学习和实践各种算法，打牢算法和数学基础，为将来学习和使用更高级的算法做铺垫。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TRIZ&quot;&gt;&lt;a href=&quot;#TRIZ&quot; class=&quot;headerlink&quot; title=&quot;TRIZ&quot;&gt;&lt;/a&gt;TRIZ&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;创始人：阿奇舒勒&lt;/li&gt;
&lt;li&gt;40种原理&lt;/li&gt;
&lt;li&gt;发明家式的解决任务理论&lt;h3 id=&quot;用途&quot;&gt;</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://jayerine.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>奇怪名词解释</title>
    <link href="https://jayerine.top/2024/02/06/feae35703595/"/>
    <id>https://jayerine.top/2024/02/06/feae35703595/</id>
    <published>2024-02-06T04:00:21.577Z</published>
    <updated>2024-02-06T04:00:21.577Z</updated>
    
    <content type="html"><![CDATA[<p>PowerPC（Power Processor Architecture）是一种基于精简指令集计算机（RISC）架构的中央处理器（CPU）系列，最早由IBM、苹果公司和摩托罗拉共同开发。PowerPC CPU被广泛应用于高性能计算机、嵌入式系统、网络设备以及游戏机等领域。</p><p>DSP（Digital Signal Processor）是数字信号处理器的缩写。它是专门为数字信号处理而设计的微处理器，通常具有更快的时钟速度和更高的运算能力，适用于音频、视频、语音、图像等实时信号的处理和分析。DSP广泛应用于通信、音频、视频、雷达、医疗等领域。</p><p>SRIO（Serial RapidIO）是一种串行高速总线标准，旨在提供高速数据传输和低延迟的通信解决方案。SRIO被设计用于高性能计算、数据中心、网络设备、电信设备等领域，可以连接多个处理器、DSP、FPGA等芯片以及外围设备。</p><p>SRIO总线具有以下特点：</p><ol><li>高速传输：SRIO的速度可达到5Gbps或更高，可满足高带宽应用的需求。</li><li>低延迟：SRIO采用专门的协议和硬件架构，降低了数据传输的延迟，适用于实时应用。</li><li>可靠性：SRIO具有较强的错误检测和纠正能力，保证了数据传输的可靠性。</li><li>扩展性：SRIO支持多主机和多处理器连接，可扩展性极强。</li><li>灵活性：SRIO支持多种拓扑结构和数据传输模式，适应不同应用场景的需求。</li></ol><p>SLAM（Simultaneous Localization and Mapping）算法是指同时实现机器人的自主定位和地图构建的一类算法。在SLAM算法中，机器人通过搭载传感器（如激光雷达、相机等）进行环境探测，从而实现对机器人周围环境的感知和地图构建；同时，机器人通过自身的运动信息和传感器数据进行定位，实现自主导航。</p><p>SLAM算法通常涉及到对机器人的传感器数据进行处理和分析，包括特征提取、匹配、滤波、优化等步骤。根据不同的应用场景和环境，SLAM算法可以采用不同的方法和技术，例如基于滤波的方法、基于优化的方法、基于深度学习的方法等。</p><p>SLAM算法被广泛应用于无人车、无人机、服务机器人以及工业自动化等领域，为机器人实现自主感知和导航提供了重要的技术支持。</p><p>Redis是一种内存数据结构存储系统，它可以用作数据库、缓存和消息队列。Redis支持多种数据结构，包括字符串、哈希表、列表、集合等。与传统的关系型数据库不同，Redis将所有数据保存在内存中，因此访问速度非常快。此外，Redis还提供了一些高级功能，如发布/订阅、事务处理、Lua脚本等。Redis的主要优点是快速、灵活、可扩展，并且具有广泛的应用场景，如Web应用程序、游戏、移动应用程序等。</p><p>Flask是一个轻量级的Web应用框架，它基于Python语言编写而成。Flask旨在提供一种简单易用、灵活性高、扩展能力强的开发方式，适用于快速搭建小型Web应用程序。</p><p>Flask具有以下特点：</p><ol><li>简单易用：Flask采用简洁的结构设计，易于理解和上手。</li><li>轻量级：Flask核心代码库非常小，运行起来非常快。</li><li>扩展性强：Flask提供了丰富的插件和扩展库，可以方便地实现各种功能。</li><li>模板引擎：Flask内置了Jinja2模板引擎，可以灵活地构建Web界面。</li><li>松耦合：Flask框架没有强制的目录结构和组织方式，可以根据需求自由定制。</li></ol><p>Flask可以用于构建各种类型的Web应用程序，包括博客、社交网络、电子商务等。同时，Flask也可以和其他Python库和框架配合使用，如NumPy、Pandas、Django等，满足更加复杂的需求。</p><p>AWS是Amazon Web Services的缩写，是亚马逊公司提供的一整套云计算服务。AWS提供了各种基础设施和应用程序服务，涵盖了计算、存储、数据库、网络、分析、人工智能、开发工具等多个领域。</p><p>AWS的主要产品和服务包括：</p><ol><li>EC2：弹性云服务器，可以在几分钟内启动虚拟机实例。</li><li>S3：简单存储服务，可提供安全、高扩展性的对象存储服务。</li><li>RDS：关系型数据库服务，支持多种数据库引擎，如MySQL、PostgreSQL、Oracle等。</li><li>Lambda：事件驱动计算平台，可运行代码片段并按使用时间计费。</li><li>Elastic Beanstalk：自动化部署和管理平台，可快速部署Web应用程序。</li><li>CloudFront：全球内容分发网络，可将静态和动态内容快速分发到全球各地。</li><li>DynamoDB：NoSQL数据库服务，可处理大量非结构化数据。</li><li>Glacier：低成本的云归档存储服务，支持长期数据存储和备份。</li></ol><p>AWS的优点包括可靠性高、安全性好、灵活性强、可扩展性高，并且具有广泛的应用场景。AWS已经成为当今最为流行的云计算服务提供商之一。</p><p>RESTful（Representational State Transfer）是一种基于Web的架构风格，用于设计分布式系统。它是一组约束和属性的集合，可以使应用程序更加简单、可扩展和易于维护。</p><p>RESTful架构风格的核心概念包括：</p><ol><li>资源：系统中任何可以被访问的信息都被视为资源，每个资源都有唯一的标识符。</li><li>表述：资源的状态可以通过表述来传输，例如JSON、XML等格式。</li><li>状态转移：客户端通过HTTP协议对资源进行操作，包括GET、POST、PUT、DELETE等方法。</li><li>无状态：RESTful服务不维护客户端状态，每个请求都包含了足够的信息，服务器可以独立处理。</li></ol><p>RESTful设计规范通常遵循以下几个原则：</p><ol><li>URI表示资源：URI是资源的唯一标识符，每个资源都应该有一个固定的URI。</li><li>HTTP动词操作资源：HTTP动词表示对资源进行的操作，如GET表示读取资源，POST表示创建资源，PUT表示更新资源，DELETE表示删除资源等。</li><li>返回资源的表述：响应应该返回资源的表述，例如JSON或XML格式的数据。</li><li>超媒体驱动：超媒体链接可以提供应用程序自我描述的能力。</li></ol><p>RESTful架构在Web开发中被广泛使用，尤其适用于移动应用程序、API服务等分布式系统。它可以简化系统架构，提高系统的灵活性和可扩展性。</p><p>Docker是一种开源的容器化平台，用于构建、部署和运行应用程序。它基于Linux操作系统中的容器技术，可以将应用程序及其依赖项封装在一个可移植的容器中，并提供了标准化的接口和工具集，使得应用程序的部署和管理变得更加简单、灵活和可靠。</p><p>Docker的核心组件包括：</p><ol><li>Docker引擎：Docker的主要组件，负责管理容器的生命周期。</li><li>Docker镜像：容器运行的时候需要的文件系统和参数的集合。</li><li>Docker容器：Docker中的运行实例，包含了应用程序和其所有的依赖项。</li><li>Docker仓库：用于存储和分享Docker镜像的集合。</li></ol><p>Docker的主要优点包括：</p><ol><li>快速、高效：Docker利用容器技术，可以快速地创建、启动和停止容器，提高开发和部署效率。</li><li>简单、易用：Docker提供了简单易用的命令行工具，使得容器的管理和部署变得非常方便。</li><li>可移植、可扩展：Docker的容器可以在不同的环境中运行，具有很好的可移植性和可扩展性。</li><li>安全、隔离：Docker利用容器技术实现应用程序之间的隔离，保证了系统的安全性。</li><li>生态丰富：Docker拥有一个庞大的生态系统，提供了大量的工具和插件，满足了不同场景下的需求。</li></ol><p>Docker在云计算、DevOps等领域得到了广泛的应用，成为了一种重要的容器化平台。</p><p>Spark、Kafka和Presto都是大数据处理领域的重要工具和技术。</p><ol><li><p>Spark：Spark是一个快速的、可扩展的、通用的大数据处理框架，支持多种数据处理场景，如批处理、流处理、机器学习等。Spark采用内存计算技术，可以提高数据处理速度，同时也支持多种编程语言和数据源。</p></li><li><p>Kafka：Kafka是一种分布式消息队列系统，主要用于高吞吐量的数据流处理。它支持消息的发布和订阅机制，支持多种数据源和数据消费端，同时还提供了容错性和可伸缩性。</p></li><li><p>Presto：Presto是一种分布式SQL查询引擎，可以快速地查询大规模的数据集。它支持多种数据源，如Hadoop、Cassandra、MySQL等，并且具有高性能和易用性。</p></li></ol><p>这三个工具在大数据处理中经常被同时使用。例如，可以使用Kafka作为数据输入源，将数据流传输到Spark中进行实时处理，然后使用Presto对结果进行查询。这样的组合可以提供灵活、高效、可靠的数据处理解决方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PowerPC（Power Processor Architecture）是一种基于精简指令集计算机（RISC）架构的中央处理器（CPU）系列，最早由IBM、苹果公司和摩托罗拉共同开发。PowerPC CPU被广泛应用于高性能计算机、嵌入式系统、网络设备以及游戏机等领域。&lt;</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://jayerine.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>工具使用</title>
    <link href="https://jayerine.top/2024/02/06/16139088fdfb/"/>
    <id>https://jayerine.top/2024/02/06/16139088fdfb/</id>
    <published>2024-02-06T04:00:21.577Z</published>
    <updated>2024-02-06T04:00:21.577Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些好用的工具</p><p>voicemeeter banana：可以输出声音到多个耳机</p><p>ffmpeg——音频处理开源工具，可以进行音频格式转换：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i 白日梦想家.rmvb -c:v libx264 -strict -2 白日梦想家.mp4</span><br></pre></td></tr></table></figure></p><p>runfuns：iso系统镜像制作软件，制作好的U盘镜像可以安装系统</p><p>Termus：可以通过手机使用ssh</p><p>TTS-coqui-ai开源项目，可以很方便的使用命令行或Python实现文字语音合成。若模型下载太慢，可以到huggingface网站或者其他镜像站下载模型，再手动拷贝到本地的cache目录中。使用的时候需要注意，中文一定要用句号结尾，否则会产生杂音。</p><p>stability-ai的开源diffusion模型，可以实现本地部署AI绘画。</p><p>chatglm6B，可以实现本地部署的LLM大模型，效果还不错。</p><p>rocm可能可以让amd的显卡使用pytorch进行机器学习。经过一天的研究发现，rocm的不同版本（5.0-5.71）之间非常不一样，一定要注意适配的相应pytorch版本。而且较新版本的rocm支持不了比较老的显卡，如RX580，据说5.30版本可以使用，但是到了5.70版本后，虽然可以配置rocm环境，但是经过简单测试可以发现，无法进行任何cuda计算，只要使用cuda计算，程序就会毫无征兆的挂掉内核。机器学习可能还是N卡比较好。</p><p>smab协议可以让局域网电脑之间相互共享文件，类似于ftp。需要注意的是，smab协议有3个版本，其中android系统常使用1.0版本，若需要电脑和手机文件共享，需要电脑端降低设置到1.0版本。</p><p>jupyter可以实现浏览器登录服务器，使用服务器的计算资源跑程序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一些好用的工具&lt;/p&gt;
&lt;p&gt;voicemeeter banana：可以输出声音到多个耳机&lt;/p&gt;
&lt;p&gt;ffmpeg——音频处理开源工具，可以进行音频格式转换：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://jayerine.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>鲲鹏软件迁移</title>
    <link href="https://jayerine.top/2024/02/06/125b95e4ccef/"/>
    <id>https://jayerine.top/2024/02/06/125b95e4ccef/</id>
    <published>2024-02-06T04:00:21.577Z</published>
    <updated>2024-02-06T04:00:21.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="周末和Erine去听了huawei的讲座"><a href="#周末和Erine去听了huawei的讲座" class="headerlink" title="周末和Erine去听了huawei的讲座"></a>周末和Erine去听了huawei的讲座</h2><p>开学的第一个星期，好好的周末选择去坐大牢了）。感觉整个实验做下来，很大部分内容就是跟着老是配环境，下载各种软件。有一次总是Missing file，结果是下载zip的时候没有下完整就解压了。然后动不动就有些环境掉了，爆出一大堆错，比较吓人。</p><p>感觉现在的网站搭建的各种工具有一个趋势，就是自动化水平越来越高了，各种组件和模板都有很多现成的，上手起来就方便了很多。还有就是大数据服务很高级，Hadoop、Hive之类的分析工具做的非常好。</p><p>前端的难感觉难在很多简单的东西凑在一起，就变得很复杂了，需要非常细心，有很多细节需要注意，一不小心就404了。以后可能不做前端工作，但是还是得会一点。</p><p>下面记录一些Jay通过鲲鹏软件迁移工具了解到的信息。</p><h2 id="常用网站部署工具"><a href="#常用网站部署工具" class="headerlink" title="常用网站部署工具"></a>常用网站部署工具</h2><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>反向代理，有利于保护服务器。直接在公网上部署服务器，容易受到攻击。Nginx可以用与实现反向代理，以及负载均衡，自动平衡服务器之间的业务量。负责运行前端应用。</p><h3 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h3><p>大数据分析工具，为海量数据提供存储和计算。</p><h4 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h4><p>Hadoop Distributed File System的简称，是Hadoop抽象文件系统的一种实现。Hadoop抽象文件系统可以与本地系统、Amazon S3等集成，甚至可以通过Web协议（webhsfs）来操作。HDFS的文件分布在集群机器上，同时提供副本进行容错及可靠性保证。例如客户端写入读取文件的直接操作都是分布在集群各个机器上的，没有单点性能压力。</p><h4 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h4><p>Yarn是一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的操作系统平台，而MapReduce等运算程序则相当于运行于操作系统之上的应用程序。</p><h3 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h3><p>大数据查询工具，提供SQL语句查询功能。</p><h3 id="apache"><a href="#apache" class="headerlink" title="apache"></a>apache</h3><p>开放源码的网页服务器，可以在大多数计算机操作系统中运行，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。</p><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>SQL- 是structured query language简称。MySQL是数据库管理系统，能够帮助你管理关系型数据库，并且是开源的，意味着这是免费的，如果必要，你可以修改源代码。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mysql@ecs-3ddf bin]$ service mysql start</span><br><span class="line">//启动数据库</span><br><span class="line">[mysql@ecs-3ddf bin]$ mysql -uroot -p -S /data/mysql/run/mysql.sock</span><br><span class="line">//登录数据库</span><br></pre></td></tr></table></figure></p><h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><p>Spring Boot 是由 Pivotal 团队提供的基于 Spring 的全新框架，旨在简化 Spring 应用的初始搭建和开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。</p><p>Spring 官网给的定义是：Spring Boot 是所有基于 Spring 开发项目的起点。Spring Boot 集成了绝大部分目前流行的开发框架，就像 Maven 集成了所有的 JAR 包一样，Spring Boot 集成了几乎所有的框架，使得开发者能快速搭建 Spring 项目。</p><p>Spring Boot 的核心设计思想是“约定优于配置”。基于这一设计原则，Spring Boot 极大地简化了项目和框架的配置。比如在使用 Spring 开发 Web 项目时，我们需要配置 web.xml、Spring 和 MyBatis 等，还需要将它们集成在一起。而使用 Spring Boot 一切将变得极其简单，它采用了大量的默认配置来简化这些文件的配置过程，只需引入对应的 Starters（启动器）。</p><p>Spring Boot 可以构建一切。设计它就是为了使用最少的配置，以最快的速度来启动和运行 Spring 项目。</p><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a><a href="https://blog.csdn.net/chaizepeng/article/details/119384531">Mybatis</a></h3><p>mybatis是一款用于持久层的、轻量级的半自动化<a href="https://blog.csdn.net/Mr_VK/article/details/122930987#:~:text=%E4%BB%80%E4%B9%88%E6%98%AForm?">ORM框架</a>，封装了所有jdbc操作以及设置查询参数和获取结果集的操作，支持自定义sql、存储过程和高级映射。</p><h3 id="Layui"><a href="#Layui" class="headerlink" title="Layui"></a>Layui</h3><p>Layui是一套开源的 Web UI 组件库。layui采用自身极简的模块化规范，并遵循原生 HTML/CSS/JS 的开发模式，极易上手，开箱即用。非常适合网页界面的快速构建。</p><h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><p>jQuery是一个快速，小型且功能丰富的JavaScript库。借助易于使用的API（可在多种浏览器中使用），使HTML文档的遍历和操作，事件处理，动画和Ajax等事情变得更加简单。</p><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><p>Maven是基于项目对象模型(POM project object model)，可以通过一小段描述信息（配置）来管理项目的构建，报告和文档的软件项目管理工具.</p><h2 id="Linux常用操作"><a href="#Linux常用操作" class="headerlink" title="Linux常用操作"></a>Linux常用操作</h2><h3 id="配置yum源便于下载"><a href="#配置yum源便于下载" class="headerlink" title="配置yum源便于下载"></a>配置yum源便于下载</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ecs-3ddf yum.repos.d]<span class="comment"># wget -O /etc/yum.repos.d/openEulerOS.repo https://repo.huaweicloud.com/repository/conf/openeuler_aarch64.repo</span></span><br><span class="line">[root@ecs-3ddf yum.repos.d]<span class="comment"># yum clean all</span></span><br><span class="line">[root@ecs-3ddf yum.repos.d]<span class="comment"># yum makecache</span></span><br></pre></td></tr></table></figure><h3 id="echo-命令"><a href="#echo-命令" class="headerlink" title="echo 命令"></a>echo 命令</h3><p>用于显示和打印各种字符串或变量</p><h3 id="Linux-chown（英文全拼：change-owner）命令"><a href="#Linux-chown（英文全拼：change-owner）命令" class="headerlink" title="Linux chown（英文全拼：change owner）命令"></a>Linux chown（英文全拼：change owner）命令</h3><p>用于设置文件所有者和文件关联组的命令，chown 需要超级用户 root 的权限才能执行此命令。chown更改每个给定文件的用户和/或组所有权。</p><p>例：修改配置文件/etc/my.cnf 的用户组和用户权限为 mysql:mysql。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ecs-3ddf <span class="built_in">local</span>]<span class="comment"># chown mysql:mysql /etc/my.cnf</span></span><br></pre></td></tr></table></figure></p><h3 id="vim使用"><a href="#vim使用" class="headerlink" title="vim使用"></a>vim使用</h3><p>命令模式下，输入:wq保存退出</p><p>命令模式下，输入u撤销操作</p><p>命令模式下，输入/和Enter键进行查找，n键查找下一个选项</p><h3 id="source命令"><a href="#source命令" class="headerlink" title="source命令"></a>source命令</h3><p>保留、更改当前shell中的环境变量，用作配置环境后刷新。</p><p>例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ecs-3ddf <span class="built_in">local</span>]<span class="comment"># source /etc/profile</span></span><br></pre></td></tr></table></figure></p><h2 id="鲲鹏代码迁移工具"><a href="#鲲鹏代码迁移工具" class="headerlink" title="鲲鹏代码迁移工具"></a>鲲鹏代码迁移工具</h2><p>处理器所支持的指令集不同，意味着开发者可能需要对代码进行跨平台的迁移。我们常见到便是x86平台的代码往arm平台进行迁移。</p><p>通常，代码迁移是件复杂又繁琐的工作，需要花费开发者大量精力对软件包、源代码、依赖库文件进行人工分析、检查和识别，手动修正不同指令集之间的相关差异，这些差异主要涉及语法、指令、函数和库文件支持情况。</p><p>鲲鹏代码迁移工具是一款可以简化客户应用迁移到基于鲲鹏916/920的服务器的过程的工具。工具仅支持x86 Linux到Kunpeng Linux的扫描与分析，不支持Windows软件代码的扫描、分析与迁移。</p><p>当用户有x86平台上源代码的软件要迁移到基于鲲鹏916/920的服务器上时，既可以使用该工具分析可迁移性和迁移投入，也可以使用该工具自动分析出需修改的代码内容，并指导用户如何修改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;周末和Erine去听了huawei的讲座&quot;&gt;&lt;a href=&quot;#周末和Erine去听了huawei的讲座&quot; class=&quot;headerlink&quot; title=&quot;周末和Erine去听了huawei的讲座&quot;&gt;&lt;/a&gt;周末和Erine去听了huawei的讲座&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="华为" scheme="https://jayerine.top/tags/%E5%8D%8E%E4%B8%BA/"/>
    
    <category term="网站" scheme="https://jayerine.top/tags/%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>机器学习</title>
    <link href="https://jayerine.top/2024/02/06/602d3832692a/"/>
    <id>https://jayerine.top/2024/02/06/602d3832692a/</id>
    <published>2024-02-06T04:00:21.577Z</published>
    <updated>2024-02-06T04:00:21.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means"></a><a href="https://zhuanlan.zhihu.com/p/184686598">K-Means</a></h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">方以类聚，物以群分。</span><br><span class="line">                    ——《易经》</span><br></pre></td></tr></table></figure><p>聚类算法KMeans是无监督学习的杰出代表之一，K-Means可以做为其他聚类算法的基础。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>通过迭代寻找K个簇（Cluster）的一种划分方案，使得聚类结果对应的损失函数最小。其中，损失函数可以定义为各个样本距离所属簇中心点的误差平方和：</p><script type="math/tex; mode=display">J(c, \mu)=\sum_{i=1}^{M}{||x_{i}-\mu_{c_{i}}||^{2}}</script><p>其中 $x_{i}$ 代表第 $i$ 个样本， $c_{i}$ 是 $x_{i}$ 所属的簇， $\mu_{c_{i}}$ 代表簇对应的中心点， $M$ 是样本总数。</p><h3 id="主要过程"><a href="#主要过程" class="headerlink" title="主要过程"></a>主要过程</h3><ol><li>选定初始簇中心</li><li>更新簇中心位置</li><li>更新分类归属</li><li>重复2、3步到簇中心不在变化</li></ol><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>KMeans的核心目标是将给定的数据集划分成K个簇（K是超参），并给出每个样本数据对应的中心点。具体步骤非常简单，可以分为4步：</p><p>（1）数据预处理。主要是标准化、异常点过滤。</p><p>（2）随机选取K个中心，记为 $\mu_{1}^{(0)},\mu_{2}^{(0)},…,\mu_{k}^{(0)}$</p><p>（3）定义损失函数： $J(c, \mu)=min\sum_{i=1}^{M}{||x_{i}-\mu_{c_{i}}||^{2}}$</p><p>（4）令$t=0,1,2,…$ 为迭代步数，重复如下过程直到 J 收敛：</p><ul><li>对于每一个样本 $x_{i}$ ，将其分配到距离最近的中心</li></ul><script type="math/tex; mode=display">c_{i}^{t} <—argmin_{k}{||x_{i}-\mu_{k}^{t}||^{2}}</script><ul><li>对于每一个类中心k，重新计算该类的中心</li></ul><script type="math/tex; mode=display">\mu_{k}^{(t+1)} <—argmin_{\mu}\sum_{i:c_{i}^{t}=k}^{b}{||x_{i}-\mu||^{2}}</script><p>KMeans最核心的部分就是先固定中心点，调整每个样本所属的类别来减少 J ；再固定每个样本的类别，调整中心点继续减小J 。两个过程交替循环， J 单调递减直到最（极）小值，中心点和样本划分的类别同时收敛。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>KMenas的优点：</p><ul><li>高效可伸缩，计算复杂度 为O(NKt)接近于线性（N是数据量，K是聚类总数，t是迭代轮数）。</li><li>收敛速度快，原理相对通俗易懂，可解释性强。</li></ul><p>KMeans也有一些明显的缺点：</p><ul><li>受初始值和异常点影响，聚类结果可能不是全局最优而是局部最优。</li><li>K是超参数，一般需要按经验选择。</li><li>样本点只能划分到单一的类中。</li><li>不适合圆形数据集的分类（非凸数据集）。<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3>图像压缩：图像矢量量化。<blockquote><p>对颜色进行聚类，若原图256*256，每个像素用24个比特的RGB表示。若经过聚类颜色之后剩下64种颜色，只用6比特表示颜色，压缩率为$\frac{6}{24}\times 100\%$。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3></blockquote></li></ul><ol><li><p>数据预处理：归一化和异常点过滤</p><p> KMeans本质上是一种基于欧式距离度量的数据划分方法，均值和方差大的维度将对数据的聚类结果产生决定性影响。所以在聚类前对数据（具体的说是每一个维度的特征）做归一化和单位统一至关重要。此外，异常值会对均值计算产生较大影响，导致中心偏移，这些噪声点最好能提前过滤。</p></li><li><p>合理选择K值</p><p> K值的选择一般基于实验和多次实验结果。例如采用手肘法，尝试不同K值并将对应的损失函数画成折线。手肘法认为图上的拐点就是K的最佳值。</p><p> 为了将找寻最佳K值的过程自动化，研究人员提出了Gap Statistic方法。它的有点是我们不再需要肉眼判断，只需要找到最大的Gap Statistic对应的K即可。</p><p> 沿用第一节中损失函数记为 $D_{k}$ ，当分为K类时，Gap Statistic定义为： $Gap(k)=E(logD_{k})-logD_{k}$ 。 $E(logD_{k})$ 是 $logD_{k}$ 的期望，一般由蒙特卡洛模拟产生。我们在样本所在的区域内按照均匀分布随机地产生和原始样本数一样多的随机样本，并对这个随机样本做KMeans，得到一个 $D_{k}$ ，重复多次就可以计算出 $E(logD_{k})$ 的近似值。</p><p> $Gap(K)$ 的物理含义是随机样本的损失与实际样本的损失之差。$Gap$越大说明聚类的效果越好。一种极端情况是，随着K的变化 $Gap(K)$ 几乎维持一条直线保持不变。说明这些样本间没有明显的类别关系，数据分布几乎和均匀分布一致，近似随机。此时做聚类没有意义。</p></li><li><p>改进初始值的选择</p><p> 之前我们采取随机选择K个中心的做法，可能导致不同的中心点距离很近，就需要更多的迭代次数才能收敛。如果在选择初始中心点时能让不同的中心尽可能远离，效果往往更好。这类算法中，以K-Means++算法最具影响力。</p></li><li><p>采用核函数</p><p> 主要思想是通过一个非线性映射，将输入空间中的数据点映射到高位的特征空间中，并在新的空间进行聚类。非线性映射增加了数据点线性可分的概率（与SVM中使用核函数思想类似）对于非凸的数据分布可以达到更为准确的聚类结果。</p></li></ol><h2 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a><a href="https://zhuanlan.zhihu.com/p/31886934">SVM</a></h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>支持向量机（support vector machines, SVM）是一种二分类模型，它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机；SVM还包括核技巧，这使它成为实质上的非线性分类器。SVM的的学习策略就是间隔最大化，可形式化为一个求解凸二次规划的问题，也等价于正则化的合页损失函数的最小化问题。SVM的的学习算法就是求解凸二次规划的最优化算法。属于有监督学习。</p><p>研究对线性二分类问题的凸优化问题的表示，以及支持向量机的求解。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>SVM学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。如下图所示， $\boldsymbol{w}\cdot x+b=0$ 即为分离超平面，对于线性可分的数据集来说，这样的超平面有无穷多个（即感知机），但是几何间隔最大的分离超平面却是唯一的。<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/支持向量机.jpg" alt="二分类划分"></p><script type="math/tex; mode=display">w=[w1,w2]\quad x=[x,y]^T</script><p>点到超平面的距离是</p><script type="math/tex; mode=display">d=\frac{|xX_0+b|}{||w||}</script><p>若$X_0$为支持向量，</p><script type="math/tex; mode=display">d=\frac{1}{||w||}</script><p>用a缩放w和b，$(w,b)\rightarrow(aw,ab)$</p><p>当$|wx_0+b|=1$，$x_0$是支持向量。</p><p>当$|wx_0+b|&gt;1$，$x_0$非支持向量。</p><h3 id="支持向量机的求解"><a href="#支持向量机的求解" class="headerlink" title="支持向量机的求解"></a>支持向量机的求解</h3><p>支持向量机求解是一个凸问题，存在唯一一个全局极值。</p><p>凸问题总能找到高效快速的算法来解决。</p><ul><li>拉格朗日乘子法求解</li><li>用现成数学包求解<h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a><a href="https://zhuanlan.zhihu.com/p/30059442">决策树</a></h2>决策树是一种十分常用的分类方法，需要监管学习。<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3>熵：表示信息的不确定性，即混乱程度。<script type="math/tex; mode=display">H(D)=-\sum_{i=1}^N p_ilog_2p_i</script>$p_i$表示取到某个信息元素D的概率。</li></ul><p>信息增益：表示得知特征A的信息而使得类X得信息不确定性减少得程度。<br>若用g(D,A)表示特征A对训练数据集D得信息增益，则有：</p><script type="math/tex; mode=display">g(D,A)=H(D)-H(D|A)</script><p>D|A表示加入A特征之后的训练集D。</p><p>条件熵：假设在特征A上有m个分支节点，其中$D_i$表示特征A得第i个分支得节点的数据，则</p><script type="math/tex; mode=display">H(D|A)=\sum_{i=1}^m\frac{|D_i|}{|D|}H(D_i)</script><p>即，特征A的分支节点的熵的加权和。</p><h3 id="训练期望"><a href="#训练期望" class="headerlink" title="训练期望"></a>训练期望</h3><ul><li>希望随着树深度的增加，节点的熵迅速的降低。</li><li>得到一个高度最矮的决策树。</li><li>到叶子节点的熵值为0，此时叶子节点为纯节点，即每个叶子节点中的实例都属于同一类。<h3 id="决策树的构造"><a href="#决策树的构造" class="headerlink" title="决策树的构造"></a>决策树的构造</h3>计算所有属性的信息增益，选择当前信息增益最大的特征进行划分。<h3 id="改进算法"><a href="#改进算法" class="headerlink" title="改进算法"></a>改进算法</h3>CART算法。<h2 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h2>卷积神经网络（Convolutional Neural Networks）是一种深度学习模型或类似于人工神经网络的多层感知器，常用来分析视觉图像。</li></ul><p>全连神经网络数量太庞大，不适合处理图像，因此需要通过CNN局部感知。<br>CNN特点：</p><ul><li>局部感知</li><li>参数共享</li><li>多卷积核</li><li><p>池化处理</p><p>最大池化、平均池化</p></li><li><p>多层结构</p><p>层数越多，学到的特征越全局化</p></li></ul><p>卷积计算，使用哈达玛积。</p><p>步长：滑动的长度</p><p>窄卷积和宽卷积：对图像边缘的处理，是否扩充图片边缘。</p><p>2023.3.18</p><h2 id="图像语义分割"><a href="#图像语义分割" class="headerlink" title="图像语义分割"></a>图像语义分割</h2><p>概念：对图像中的每个像素进行分类。</p><p>任务：识别图像中存在的内容及位置。</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>用$J(\theta_1)$表示$h_{\theta}(x)$的代价函数。</p><script type="math/tex; mode=display">J(\theta_1)=\frac{1}{2m}\sum(h_\theta(x^{(i)})-y^{(i)})^2</script><h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><script type="math/tex; mode=display">\theta_j=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta_0,\theta_1) \space\space(for\space j=0\space and\space j=1)</script><p>$\alpha$称为学习率，学习率太大，会导致发散，学习率太小，会导致收敛过慢。<br>如何找到合适的学习率？<br>画出$min\space J(\theta)-No.of\space iteration$图像，判断算法是否已经收敛，挥着通过自动收敛测试判断。如果函数递增，则说明没有收敛，需要使用较小的学习率。最开始的时候可以每隔十倍取一次值尝试。<br>convex function 凸函数<br>Feature Scaling：通过放缩特征数据的范围一致，使得梯度下降法运行效果更加丝滑。<br>Mean normalization（均值归一化）：通过平移和放缩，使得特征数据的样本中心接近。<br>可以通过简单的特征变换，拟合不同的函数。</p><h2 id="正规方程法"><a href="#正规方程法" class="headerlink" title="正规方程法"></a>正规方程法</h2><p>正规方程法求$\Theta$推导：<br>设样本特征数为n，样本个数为m，则设$X$为样本构成的$n\times m$的矩阵，$Y_{m\times 1}$为真实预测值，$\Theta_{n\times 1}$为待求参数值，则价值函数的矩阵形式为：</p><script type="math/tex; mode=display">J(\Theta)=(X\Theta -Y)^T(X\Theta -Y)</script><p>由微分知识可知，当任意的$\theta_i$满足</p><script type="math/tex; mode=display">\frac{\partial}{\partial\theta_i}J(\Theta)=0</script><p>时，存在极值，于是对于每个$\theta_i$，求$J(\Theta)$的偏导等于0。化简，得到：</p><script type="math/tex; mode=display">J(\Theta)=\Theta^T X^TX\Theta-2Y^TX\Theta</script><p>考虑在$A_{1\times n}\Theta_{n\times 1}$中，对每一个$\theta_i$求导，得到极值条件：</p><script type="math/tex; mode=display">A^T=0</script><p>考虑在$\Theta_{n\times 1}^T A_{n\times n}\Theta_{n\times 1}$中，对每一个$\theta_i$求导，得到极值条件：</p><script type="math/tex; mode=display">\frac{\partial}{\partial \theta_i}(\Theta_{n\times 1}^T A_{n\times n}\Theta_{n\times 1})=\frac{\partial}{\partial \theta_i}(\Theta^Ta_{xi}+a_{ix}\Theta-\theta_i^2aii)=2a_{ix}\theta_i</script><p>因此通过求导和重新排列，· 得到$J(\Theta)$的极值条件：</p><script type="math/tex; mode=display">2X^TX\Theta -2X^TY=0</script><p>即</p><script type="math/tex; mode=display">\Theta=(X^TX)^{-1}X^TY</script><p>线性代数中，可以通过正规方程法，直接求使得代价函数最小的$\Theta$，但是由于正规方程法是$O(n^3)$复杂度，在数据量很大时，只能使用梯度下降法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;K-Means&quot;&gt;&lt;a href=&quot;#K-Means&quot; class=&quot;headerlink&quot; title=&quot;K-Means&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/184686598&quot;&gt;K-Means&lt;/a&gt;&lt;/h2&gt;</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="机器学习" scheme="https://jayerine.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Erine的文案</title>
    <link href="https://jayerine.top/2024/02/06/2d0f77ed687f/"/>
    <id>https://jayerine.top/2024/02/06/2d0f77ed687f/</id>
    <published>2024-02-06T04:00:21.577Z</published>
    <updated>2024-02-06T04:00:21.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2023-3-11"><a href="#2023-3-11" class="headerlink" title="2023.3.11"></a>2023.3.11</h2><p>你是否有过这样的遭遇？<br>网购的商品收到后却是冒牌货<br>超市冰柜里买回来的酸奶却早已过期<br>路边疯狂推销的优惠办卡却在半个月后卷钱跑路  </p><p>第41个“3·15国际消费者权益日”即将到来<br>让我们来共同了解一下这个节日吧！ </p><h3 id="3·15国际消费者权益日简介"><a href="#3·15国际消费者权益日简介" class="headerlink" title="3·15国际消费者权益日简介"></a>3·15国际消费者权益日简介</h3><p>国际消费者权益日，最早由国际消费者联盟组织于1983年确定，目的在于扩大消费者权益保护的宣传，使之在世界范围内得到重视，促进各国和地区消费者组织之间的合作与交往，在国际范围内更好地保护消费者权益。<br>中国消费者协会确定2023年全国消协组织消费维权年主题为“提振消费信心”。<br>“提振消费信心”具有以下三个方面的涵义：<br>一是立足主责主业，推动消费者权益保护协同共治，打造更加安全放心消费环境；<br>二是坚持需求导向，顺应消费需求多元化趋势，推动消费供给提质升级，推动高质量发展；<br>三是坚持问题导向，找准主攻方向，解决“急难愁盼”，推动消费提质升级。  </p><h3 id="我国的《3·15晚会》"><a href="#我国的《3·15晚会》" class="headerlink" title="我国的《3·15晚会》"></a>我国的《3·15晚会》</h3><p>3·15国际消费者权益日的宗旨就是对消费者进行教育，提高消费者维护自身权益的意识和能力，并且处理消费者投诉，帮助消费者挽回损失。<br>1987年9月，中国消费者协会被国际消费者联盟组织接受为正式成员，中国消费者协会及地方各级协会都要联合各有关部门共同举办大规模的宣传活动。1991年，中央电视台、中国消费者报社、中华工商时报社与中国消费者协会联合举办了国际消费者权益日“消费者之友专题晚会”，从此拉开了中央电视台《3·15晚会》的序幕。从此以后，中央电视台《3·15晚会》已经成为一个符号，是中国消费者最信赖的守护消费品质的舆论阵地。<br>《3·15晚会》唤醒了消费者的权益意识，成为规范市场秩序、传播国家法规政策的强大平台。专题调查、权威发布等都成为广大观众最期待的节目亮点。目前，《3·15晚会》已成为一个符号，成为亿万消费者信赖的舆论阵地，成为国家有关部委规范市场秩序的重要力量，3·15也从一个简单的数字变成了维护消费者权益的代名词。  </p><h3 id="权益受到侵害，该怎么办"><a href="#权益受到侵害，该怎么办" class="headerlink" title="权益受到侵害，该怎么办?"></a>权益受到侵害，该怎么办?</h3><p>作为消费者，当我们的权益收到侵害时，可以拨打12315等举报电话，用好法律这把利器，在法治框架内维护自己的合法权益，让不良商家付出应有的代价。同时，也要增强我们作为消费者的安全意识和防范能力，树立理性消费观念。<br>但要守住消费安全这道防线，更重要的是需要商家承担起诚信经营的责任和义务，恪守商业道德，始终把消费者的人身生命财产和个人信息安全放在首位，自觉强化消费者权益保护第一责任人的意识，主动接受社会监督。  </p><p>让我们共同努力，创造更安全、更有保障的消费环境，维护消费者合法权益！  </p><p><a href="https://mp.weixin.qq.com/s/-5nglkRoT7Y8dLd9qkT5nw">提振消费信心 共筑消费和谐 | 3·15国际消费者权益日</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2023-3-11&quot;&gt;&lt;a href=&quot;#2023-3-11&quot; class=&quot;headerlink&quot; title=&quot;2023.3.11&quot;&gt;&lt;/a&gt;2023.3.11&lt;/h2&gt;&lt;p&gt;你是否有过这样的遭遇？&lt;br&gt;网购的商品收到后却是冒牌货&lt;br&gt;超市冰柜里买回来的酸</summary>
      
    
    
    
    <category term="随笔" scheme="https://jayerine.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>lichess记录</title>
    <link href="https://jayerine.top/2024/02/06/edea1504322d/"/>
    <id>https://jayerine.top/2024/02/06/edea1504322d/</id>
    <published>2024-02-06T04:00:21.561Z</published>
    <updated>2024-02-06T04:00:21.561Z</updated>
    
    
    
    
    <category term="兴趣爱好" scheme="https://jayerine.top/categories/%E5%85%B4%E8%B6%A3%E7%88%B1%E5%A5%BD/"/>
    
    
    <category term="chess" scheme="https://jayerine.top/tags/chess/"/>
    
  </entry>
  
  <entry>
    <title>C++</title>
    <link href="https://jayerine.top/2024/02/06/0ea105e1bfda/"/>
    <id>https://jayerine.top/2024/02/06/0ea105e1bfda/</id>
    <published>2024-02-06T04:00:21.561Z</published>
    <updated>2024-02-06T04:00:21.561Z</updated>
    
    <content type="html"><![CDATA[<p>很少注意到的main函数的另一个重载形式，int main(int argc,char *argv[])。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//main函数的重载，另一个是int main(void)</span></span><br><span class="line">    <span class="comment">//argc表示传进去多少个参数</span></span><br><span class="line">    <span class="comment">//argv是一个包含传入参数的默认二维char数组，调用函数，默认会将调用的函数名作为第一个参数</span></span><br><span class="line">    <span class="comment">//很像命令</span></span><br><span class="line">    <span class="built_in">int</span> (*f)(<span class="type">int</span>,<span class="type">char</span> *[])=main;</span><br><span class="line">    <span class="comment">//函数指针</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> ***a=&amp;argv,*first=argv[<span class="number">0</span>],ch=argv[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//printf(&quot;arg=\&quot;%s\&quot;;ch=&#x27;%c&#x27;\n&quot;,first,ch);</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;argc= &quot;</span>&lt;&lt;argc&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;argc;i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;argc[%d]= %s\n&quot;</span>,i,argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(***a ==ch);</span><br><span class="line">        <span class="comment">//assert的作用是先计算表达式expression，如果其值为假（即为0），那么它先向stderr打印一条出错信息，之后通过调用abort来终止程序运行。判断是否第一个字符是否等于第一个字符？一定会相等吧。</span></span><br><span class="line">        <span class="built_in">f</span>(argc - <span class="number">1</span>,argv+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//通过函数指针递归调用main.exe，并控制参数的传入，传入的参数减少一个，argv指针类型为char***，argv变量+1，应该是重载过加号，意思是指向下一个地址空间的char**地址，下一次进入递归，会打印下一个传入的参数。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>面向对象课上学的c++类的基本元素：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>(arg);<span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Object</span>(arg):<span class="built_in">Object</span>(arg<span class="number">&#x27;</span>);<span class="comment">//构造函数列表</span></span><br><span class="line">    ~<span class="built_in">Object</span>(<span class="type">void</span>);<span class="comment">//析构函数</span></span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">const</span> Object &amp;object);<span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">func</span><span class="params">(arg)</span></span>;<span class="comment">//友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ObjFriend</span>;<span class="comment">//友元类</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;<span class="comment">//虚函数，用于实现多态</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>=<span class="number">0</span>;<span class="comment">//纯虚函数，用于实现接口和抽象类</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;<span class="comment">//重写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(arg)</span></span>;<span class="comment">//重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>之前一直没有理解多态的作用，多态可以使编写父类的程序员无需关心子类的情况，可以将一个子类的实例赋值给父类，此时这个实例拥有子类的细节，当调用其中的虚方法的时候，能正确调用子类的实现方法，方便上游程序员编写类的相关方法。</p><p>一些细节:</p><ul><li>无参构造方法，实例化的时候不能带括号。</li><li>time(0)函数返回的是秒。</li><li>尽量多用const修饰。</li></ul><p>一些好用的库：</p><ul><li>正则表达式regix，可以方便的进行自定义字符提取，判断是否匹配格式。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很少注意到的main函数的另一个重载形式，int main(int argc,char *argv[])。&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://jayerine.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>IDE使用记录</title>
    <link href="https://jayerine.top/2024/02/06/a8fa2ad5debf/"/>
    <id>https://jayerine.top/2024/02/06/a8fa2ad5debf/</id>
    <published>2024-02-06T04:00:21.561Z</published>
    <updated>2024-02-06T04:00:21.561Z</updated>
    
    <content type="html"><![CDATA[<p>今天初次使用了QT，安装的时候，出了一些问题记录一下。</p><p>QT6版本必须在线下载，网速其实还可以。</p><p>安装的时候，选择它给的默认安装组件就行。</p><p>记得把“D:\QT\6.5.0\mingw_64\bin”加入环境变量，否则会因为找不到DLL库报错。</p><p>在项目中配置运行环境，注意可能自动选择了vs的工具，导致编译出错。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天初次使用了QT，安装的时候，出了一些问题记录一下。&lt;/p&gt;
&lt;p&gt;QT6版本必须在线下载，网速其实还可以。&lt;/p&gt;
&lt;p&gt;安装的时候，选择它给的默认安装组件就行。&lt;/p&gt;
&lt;p&gt;记得把“D:&#92;QT&#92;6.5.0&#92;mingw_64&#92;bin”加入环境变量，否则会因为找不到DL</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://jayerine.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TSN网络</title>
    <link href="https://jayerine.top/2024/02/06/8513ff2ec67a/"/>
    <id>https://jayerine.top/2024/02/06/8513ff2ec67a/</id>
    <published>2024-02-06T04:00:21.561Z</published>
    <updated>2024-02-06T04:00:21.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TSN"><a href="#TSN" class="headerlink" title="TSN"></a><a href="https://zhuanlan.zhihu.com/p/342289546">TSN</a></h1><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="GCL："><a href="#GCL：" class="headerlink" title="GCL："></a>GCL：</h3><p>门控列表（Gate Control List，GCL）</p><h3 id="CNC："><a href="#CNC：" class="headerlink" title="CNC："></a>CNC：</h3><p>集中网络控制器（centralized network configuration，CNC）</p><h3 id="CUC："><a href="#CUC：" class="headerlink" title="CUC："></a>CUC：</h3><p>集中用户控制器（centralized user configuration，CUC）</p><h3 id="802-1AS："><a href="#802-1AS：" class="headerlink" title="802.1AS："></a><a href="https://www.polelink.com/index.php?m=content&amp;c=index&amp;a=show&amp;catid=93&amp;id=53">802.1AS</a>：</h3><p>通用精确时间协议（Generalized Precision Time Protocol），将为汽车、工业自动化控制等领域实现精确时间的测量。</p><h3 id="Linux-Traffic-Control"><a href="#Linux-Traffic-Control" class="headerlink" title="Linux Traffic Control:"></a><a href="https://blog.csdn.net/qinyushuang/article/details/46611709">Linux Traffic Control</a>:</h3><p>Linux TC(Traffic Control) 众所周知，在互联网诞生之初都是各个高校和科研机构相互通讯，并没有网络流量控制方面的考虑和设计，IP协议的原则是尽可能好地为所有数据流服务，不同的数据流之间是平等的。然而多年的实践表明，这种原则并不是最理想的，有些数据流应该得到特别的照顾，比如，远程登录的交互数据流应该比数据下载有更高的优先级。</p><h3 id="NETCONF"><a href="#NETCONF" class="headerlink" title="NETCONF:"></a><a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/NETCONF.html">NETCONF</a>:</h3><p>网络配置协议NETCONF（Network Configuration Protocol）为网管和网络设备之间通信提供了一套协议，网管通过NETCONF协议对远端设备的配置进行下发、修改和删除等操作。网络设备提供了规范的应用程序编程接口API（Application Programming Interface），网管可以通过NETCONF使用这些API管理网络设备。<br>NETCONF是基于可扩展标记语言XML（Extensible Markup Language）的网络配置和管理协议，使用简单的基于RPC（Remote Procedure Call）机制实现客户端和服务器之间通信。客户端可以是脚本或者网管上运行的一个应用程序。服务器是一个典型的网络设备。</p><p>云时代对网络的关键诉求之一是网络自动化，包括业务快速按需自动发放、自动化运维等。传统的命令行和SNMP已经不适应云化网络的诉求。在网络自动化方面，NETCONF越来越受欢迎，并被广泛采用。</p><h3 id="OPC-UA"><a href="#OPC-UA" class="headerlink" title="OPC UA:"></a><a href="https://zhuanlan.zhihu.com/p/430243728">OPC UA</a>:</h3><p>在网络化、标准化或网络安全方面，对工业网络的要求正以非凡的速度增长。在这些问题重重的领域，基于以太网的 OPC UA（Open Platform Communications – Unified Architecture，开放平台通信 - 统一架构）通信标准正在快速发展。凭借其集成的安全机制，独立于供应商和平台的特性， OPC UA 为数字化提供了优异基础条件。</p><p><strong>交换机</strong></p><p>Gbps:</p><p>也称交换带宽，是衡量交换机总的数据交换能力的单位，以太网是IEEE802.3以太网标准的扩展，传输速度为每秒1024兆位(即1Gbps)。</p><h2 id="调度模型1-0"><a href="#调度模型1-0" class="headerlink" title="调度模型1.0"></a>调度模型1.0</h2><p>TSN调度问题简化：<br><img src="https://s1.ax1x.com/2023/03/03/ppA8keU.png" alt="TSN调度问题"><br><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Q:通过调整每个f的一个开始发送时间，把周期性数据给错开，假如发送周期都是离散的数值，每个数据发送占一个周期的时间，就取一个所有周期的最大公因数，在这个最大公因数长度的时间段中依次发送初始数据，计算offset就不会冲突了?</span><br><span class="line"></span><br><span class="line">A:最大公约数这个是一个方法，可以先这样做。显示上也足够了。之后的展示更加复杂后，若没有最大公约数，这个方法就行不通了。</span><br><span class="line"></span><br><span class="line">Q:但是如果没有最大公约数的话，会不会有无法避免冲突的情况产生呀</span><br><span class="line"></span><br><span class="line">A:肯定有无法避免的情况产生。那就是调度不成功的情况，例如说有1000个流，你只能调度600个，那就展示600个的结果就可以了。</span><br><span class="line">数据包在网络中传输经过了传输，传播，处理以及排队时延。1m的链路长度用于计算传播时延。</span><br><span class="line"></span><br><span class="line">Q:在TSN提前计算好了冲突解决，就不存在排队时延了吗？</span><br><span class="line">A:TSN交换机可以控制流什么时候被传输，因此调度就是能够控制排队时延。简单来讲，我给你的题目是计算出offset以完成无等待传输（即排队时延为0），这样最简明易懂。更复杂的就是你可以有目的的让某些流延迟，以传输更为紧急的流量。</span><br><span class="line"></span><br><span class="line">Q:那我们目前是不需要考虑优先等级吗，先满足能正常调度，然后做出展示就好了？</span><br><span class="line">A:目前先不考虑，这个在之后的细节丰富中增加。例如说当网络负载变大时，低优先级的受到影响，但是依然能保持高优先级的传输。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TSN&quot;&gt;&lt;a href=&quot;#TSN&quot; class=&quot;headerlink&quot; title=&quot;TSN&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/342289546&quot;&gt;TSN&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;名词解释&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="TSN" scheme="https://jayerine.top/tags/TSN/"/>
    
    <category term="网络" scheme="https://jayerine.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>android文本路径选择器</title>
    <link href="https://jayerine.top/2024/02/06/8311e7629f95/"/>
    <id>https://jayerine.top/2024/02/06/8311e7629f95/</id>
    <published>2024-02-06T04:00:21.561Z</published>
    <updated>2024-02-06T04:00:21.561Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/m0_61322309/article/details/126552369?spm=1001.2014.3001.5501">csdn</a></p><ul><li>​预期效果：通过点击文件夹或文件，选择文件或文件夹，并返回选择的路径<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li></ul><p>花了几天时间，做这个小程序，初步学习并体验了一下android开发。没想到看似这么基础的功能，也需要五六百行代码来实现。学习过程就是把网上前人的代码片段扒下来，然后一点点看懂，纠错，完善，通过看懂别人写的代码来学习。把学习到的东西，后来遇到的一些困难，以及解决的方法，作为笔记整理记录一下。</p><p>1.第一次深入了解面向对象语言，了解了面向对象语言的很多基础知识，如基类，派生类，接口，继承，implements的使用条件和规范，this的各种用法，和一些基础的方法，如super()。第一次学习xml文件的标签语言，如何用xml文件组织运行程序的各种资源，以及不同activity之间的通信方法。</p><p>2.学习了android软件开发的一些流程，从package下的文件构成，res下文件的作用，gradle的使用，manifest中注册activity，签名打包成apk文件，初步了解了整个android开发的基本流程。</p><p>3.了解了一些在android开发debug的一些基本方法。</p><p>（1）由于没学Kotlin，只会用Java，因此在网上看教程的时候，常常出现看不懂别人写的kotlin代码的情况。这时候可以用android studio中tools的Java和Kotlin代码互相转化的工具，将看不懂的Kotlin代码转化为Java代码帮助理解。</p><p>（2）最开始是用usb连接手机和电脑进行调试的，后来发现了一个更方便，更快捷的调试方法，就是用adb插件进行无线调试，网上很多教程，就是注意一点，华为的鸿蒙系统，设置里没有直接进行扫码与android studio链接的功能，需要手动开启电脑的命令框，进行连接，网上也很多教程。</p><p>（3）刚开始不知道有LogCat这样一个android studio自带的日志记录软件，程序崩溃退出老是找不到原因，也不会去看报错，就直接用Toast向屏幕发信息来调试。知道LogCat之后，程序崩溃的Log可以看的到，调试就方便了太多了。</p><p>(4)对于一些常见的报错和崩溃，有了些认识。比如空指针报错，在Java开发中算是最常见的了。往往就是初始化对象，没有实例化，在之后的使用中就报错，让程序崩溃了。或者是findObjectById的方法，必须先将Object在layout中加载出来，不然绑定的时候程序会直接崩溃退出。所以要养成好习惯，设置好异常流的检查，用try,catch,finally的语句控制检查运行异常。</p><p>（5）比较离谱的bug，实在绕不过可以换种方式写。在这次实践中，就有一处写的和官方一摸一样，编译器还报错的，换了种类似的写法，就完全没有问题了。还有些离谱的问题，就只能靠经验积累了。比如有一次突然就不能显示文字了，反复查看才发现字体颜色没设置，与背景混为一体了。</p><p>（6）由于android更新换代非常快，经常会出现一些方法突然用不了了，过时了之类的问题。这时候就需要仔细鉴别和设置各种版本了。利用gradle下的版本管理，非常的方便，可以很容易的设置sdk版本，编译器版本，依赖库资源等各种版本。遇到最新的问题时，可能有用的中文教程非常有限，还是需要到官网上学习最新方法的使用。这一次实践中，由于要切换activity,并在不同的activity之间进行通信，原有的教程中，使用的是setActivityForStart()和OnActivitySet方法。在最新的sdk30版本中，已经标记为废弃该方法进行活动间通信了，要使用最新的ActivityContracts，来规范信息传递，让方法更高效安全。网上很多教程都不合适，于是只能去官网上学习了contracts的写法。还有一个版本带来的问题。早在android 4.0之后，系统就开始对app的存储修改权限做出了限制，无法随意修改读取。在最近的android10.0更新之后，又做了一次修改，使得android系统中app的读取权限更小了。在manifest文件中申请的权限，实际上十分小了，仅限于app安装的目录下的cache文件。若要进行越界内存访问，需要更多的内存申请方法。在了解这些版本问题之前，经常被莫名奇妙的bug困扰，这就是为什么，有时候照抄别人代码，程序也会报错崩溃。</p><p>(7)关于uft8编码和另一种中文编码不能被app读取路径的问题，其实是不存在的。后面看Log才发现，程序闪退是因为List为null，和编码没关系。比较新的android版本对于中文的支持都挺好了。</p><p>4.csdn帮助了我很多，有很多很不错的大佬写的教程。但是面对有些棘手的bug，中文教程看了几十篇也找不到可行方案时，就很头疼了。这时候最好应该直接去官网上学习，看不懂英文也没关系，反正有翻译。官网上的教程可以说是最好最详尽的了，是个高质量的学习途径。</p><p>5.有时候发现一个bug改不出来，可以向大佬们请教，相互交流。在一些QQ群中，或者交流网站，都有很多厉害的大佬，说不定困扰很久的问题，大佬一眼就能帮自己点破，而且能了解一些高效学习的方法。这对于初学者来说帮助挺大的。</p><p>6.不足和改进：这个程序只能读取app中cache下的文件资料，因为版本问题，高版本的android限制了app对公共存储的访问。如果要申请对其他内存的访问，应该使用最新的访问api协议。对于面向对象编程方法的巧妙之处理解还很浅显。写的代码很容易就变成面向过程了，就失去了面向对象编程的意义。大佬说最新的androiid提供了一个全局管理activity的方法，就不用intent来切换activity了，这样反而更慢。全局管理应该是个好东西，值得学一手。</p><p>除了作为笔记，还有一点就是看到好的教程太少了，基本上都是代码片段，或者不完整，或者版本陈旧，无法参考，因此发了个最完整的带各种注释的文件供初学者实践参考。</p><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/m0_61322309/article/details/126552369?spm=1001.2014.3001.5501&quot;&gt;csdn&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​预期效果：通过点击文件夹或文件，选择文件</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="android" scheme="https://jayerine.top/tags/android/"/>
    
    <category term="csdn" scheme="https://jayerine.top/tags/csdn/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="https://jayerine.top/2024/02/06/00c22e4202c6/"/>
    <id>https://jayerine.top/2024/02/06/00c22e4202c6/</id>
    <published>2024-02-06T04:00:21.561Z</published>
    <updated>2024-02-06T04:00:21.561Z</updated>
    
    <content type="html"><![CDATA[<p>记录最难受的一次ubuntu ssh使用经历。<br>今天想尝试一下ssh免密码登录服务器，本来以为几分钟就完事了，结果发现按照网上的教程没有成功。</p><p>首先在客户端生成ssh密钥<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -f C:\Users\JayL/.ssh/ubuntu_key</span><br></pre></td></tr></table></figure></p><p>注意windows下不能直接使用ssh-copy-id命令，所以选择手动拷贝pub到/home/jayl/.ssh/authorized_keys下。</p><p>发现还是不能免密码连接。</p><p>打开客户端ssh调试信息打印，发现信息很粗略，没有什么价值。</p><p>反复查看网上说的文件权限的问题，发现一切正常。</p><p>按照教程，开始折腾rsyslog和/etc/ssh/sshd_config配置文件，但是由于没找到官方文档，设置的依托答辩，后来还不小心给把日志文件auth给弄没了。</p><p>最后使用下面的命令，打印sshd的调试信息。</p><p>sudo /usr/sbin/sshd -p 2222 -d</p><p>ssh -vvv -p 2222 jayl@玺.top</p><p>结果只是说找不到公钥。</p><p>最后，偶然间发现，在/home/jayl/.ssh/authorized_keys 第一行加一行空行，就可以正常运行了。</p><p>以后找奇怪的bug，调试信息非常重要，不然很难定位到一个点。<br>从一开始没有想过去看官方文档，浪费了很多时间。<br>还有就是，这个奇怪的错误太阴间了，不知道是为什么。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录最难受的一次ubuntu ssh使用经历。&lt;br&gt;今天想尝试一下ssh免密码登录服务器，本来以为几分钟就完事了，结果发现按照网上的教程没有成功。&lt;/p&gt;
&lt;p&gt;首先在客户端生成ssh密钥&lt;br&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;t</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://jayerine.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ROS2学习</title>
    <link href="https://jayerine.top/2024/02/06/b6336b6b162f/"/>
    <id>https://jayerine.top/2024/02/06/b6336b6b162f/</id>
    <published>2024-02-06T04:00:21.561Z</published>
    <updated>2024-02-06T04:00:21.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ROS1和ROS2的选择"><a href="#ROS1和ROS2的选择" class="headerlink" title="ROS1和ROS2的选择"></a>ROS1和ROS2的选择</h2><p>小车型号是HUNTER SE，给的官方教程是使用ROS1操作，但是安装教程过于陈旧，需要使用ubuntu16版本，和ROS KENICT版本，网上说ROS2是兼容ROS1的，而且有更好的性能，所以选择ROS2。</p><h2 id="配置ROS2环境记录"><a href="#配置ROS2环境记录" class="headerlink" title="配置ROS2环境记录"></a>配置ROS2环境记录</h2><p>环境：ubuntu22.04+vscode</p><p><a href="https://fishros.com/d2lros2/#/humble/chapt1/%E7%AB%A0%E8%8A%82%E5%AF%BC%E8%AF%BB">教程1</a></p><h3 id="一、安装必要的ROS2工具"><a href="#一、安装必要的ROS2工具" class="headerlink" title="一、安装必要的ROS2工具"></a>一、安装必要的ROS2工具</h3><p>网上教程很丰富，采用了直接进入官网下载安装包本地安装，选择代号为rolling的最新版本。</p><h3 id="二、配置vscode环境"><a href="#二、配置vscode环境" class="headerlink" title="二、配置vscode环境"></a>二、<a href="https://blog.csdn.net/m0_52332336/article/details/127452907">配置vscode环境</a></h3><p>考虑使用cmake+ament_cmake+colcon构建。<br>可以使用教程中的ros2 pkg命令创建新的项目，参数可以问chatgpt。</p><p>需要的包和工具：</p><ul><li>cmake是多文件编译的基本工具，可以根据CMakeLists.txt自动生成MakeFile文件</li><li>ament_cmake用于辅助ROS2的项目构建，注意这个包不会随着ROS工具集一起下载，需要使用apt-get命令单独安装。</li><li>colcon用于管理ros2的package的工作空间。这个工具是一个vscode插件。colcon基于CMake工作，在调试过程中，可单独使用CMake运行项目，在最终完成项目时，按下ctrl+shift+B，使用colcon build进行package的安装。</li></ul><h3 id="需要注意的坑"><a href="#需要注意的坑" class="headerlink" title="需要注意的坑"></a>需要注意的坑</h3><h4 id="坑1：装好ROS相关工具之后，无法在命令行使用"><a href="#坑1：装好ROS相关工具之后，无法在命令行使用" class="headerlink" title="坑1：装好ROS相关工具之后，无法在命令行使用"></a>坑1：装好ROS相关工具之后，无法在命令行使用</h4><ul><li>解决1：每次打开shell前，需要运行命令  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /opt/ros/rolling.setup.bash</span><br></pre></td></tr></table></figure>  可以通过修改shell配置的方法，使得每次打开shell时自动运行该命令。  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure>  在文件的末尾加入该命令。<h4 id="坑2：ztrl-shift-P，输入Edit-Config，配置好c-cpp-preproperties的第三方引用路径之后，代码提示中还是报错，找不到头文件。"><a href="#坑2：ztrl-shift-P，输入Edit-Config，配置好c-cpp-preproperties的第三方引用路径之后，代码提示中还是报错，找不到头文件。" class="headerlink" title="坑2：ztrl+shift+P，输入Edit Config，配置好c_cpp_preproperties的第三方引用路径之后，代码提示中还是报错，找不到头文件。"></a>坑2：ztrl+shift+P，输入Edit Config，配置好c_cpp_preproperties的第三方引用路径之后，代码提示中还是报错，找不到头文件。</h4></li><li>解决2：在CmakeLists.txt文件中，使用include_directories语句，将需要使用的头文件地址引用。注意，这个语句不会进行递归搜索，所以需要写清楚引用头文件的相对路径。<h4 id="坑3：习惯性的想使用External-consoler，但是launch-json文件配置不成功"><a href="#坑3：习惯性的想使用External-consoler，但是launch-json文件配置不成功" class="headerlink" title="坑3：习惯性的想使用External consoler，但是launch.json文件配置不成功"></a>坑3：习惯性的想使用External consoler，但是launch.json文件配置不成功</h4></li><li>解决3：没什么办法，想要使用外部终端，只能在外面打开一个新的shell了<h4 id="坑4：CMake编译运行成功之后，没有install的输出"><a href="#坑4：CMake编译运行成功之后，没有install的输出" class="headerlink" title="坑4：CMake编译运行成功之后，没有install的输出"></a>坑4：CMake编译运行成功之后，没有install的输出</h4></li><li>解决4：install的默认路径中的lib，是 $CMAKE_INSTALL_PREFIX的相对路径，需要单独使用make install命令才会有输出。注意需要在cmake ..之后使用，即在CMakeLists.txt的子目录下进行使用。<h4 id="坑5：CMake编译运行成功，但是使用ros2-run命令找不到package"><a href="#坑5：CMake编译运行成功，但是使用ros2-run命令找不到package" class="headerlink" title="坑5：CMake编译运行成功，但是使用ros2 run命令找不到package"></a>坑5：CMake编译运行成功，但是使用ros2 run命令找不到package</h4></li><li>解决5：没有理解colcon的作用，需要先使用colcon build构建工作空间，然后必须运行source install/setup.bat，之后才能找到自定义的package。package的名称，可以在package.pom中设置，executable_name可以在CMakeLists.txt中设置，即导出文件的名称。</li></ul><h3 id="ROS2工作原理的初步理解"><a href="#ROS2工作原理的初步理解" class="headerlink" title="ROS2工作原理的初步理解"></a>ROS2工作原理的初步理解</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ROS1和ROS2的选择&quot;&gt;&lt;a href=&quot;#ROS1和ROS2的选择&quot; class=&quot;headerlink&quot; title=&quot;ROS1和ROS2的选择&quot;&gt;&lt;/a&gt;ROS1和ROS2的选择&lt;/h2&gt;&lt;p&gt;小车型号是HUNTER SE，给的官方教程是使用ROS1操作</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="硬件" scheme="https://jayerine.top/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 第一章 引言</title>
    <link href="https://jayerine.top/2024/02/06/812f344402b9/"/>
    <id>https://jayerine.top/2024/02/06/812f344402b9/</id>
    <published>2024-02-06T04:00:21.561Z</published>
    <updated>2024-02-06T04:00:21.561Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%80%E7%AB%A0.png" alt=""></p><h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><p><strong><font color=#fea401>Computer network（计算机网络）：</font></strong></p><ul><li><p>一组互联的计算机，通过同一种技术自主交换信息</p></li><li><p>可看见实际的计算机情况，即<font color=#FF6347>可见，不透明</font></p></li><li><p>计算机网络不是Internet因特网（因特网是一种特殊的覆盖全球的计算机网络）</p></li><li><p>计算机网络不是WWW万维网（万维网是建立在因特网之上的分布式系统）</p></li><li><p><strong><font color=#ff8b61>计算机网络的组成：</font></strong></p><ul><li><p>计算机/主机/端系统（数据通信的源端和数据端）</p></li><li><p>通信链路（分为有线和无线）</p></li><li><p>交换机/路由器，作为Node节点</p></li></ul></li></ul><p><strong><font color=#fea401>Distributed system（分布式系统）：</font></strong></p><ul><li><p>一组独立的计算机，对外是一个统一的系统，是<font color=#FF6347>不可见，透明</font>的</p></li><li><p>在计算机网络的基础上加入中间件（一种应用于分布式系统的基础软件），来实现这个模型</p></li><li><p>典型的分布式系统：万维网</p></li></ul><h2 id="网络硬件"><a href="#网络硬件" class="headerlink" title="网络硬件"></a>网络硬件</h2><p><strong><font color=#fea401>计算机网络的分类方式：</font></strong></p><ul><li><p><strong><font color=#ff8b61>以传输技术分类：</font></strong></p><ul><li><p><strong><font color=#ff8aaf>广播网络：</font></strong> 向所有的目的地发送数据包，如果接收机器正确，那么接收机器就会处理数据包，否则不接收直接忽略。</p><ul><li><p>多播/组播：向一组机器发送数据包</p></li><li><p>典型：局域网</p></li></ul></li><li><p><strong><font color=#ff8aaf>点到点网络：</font></strong> 通过访问多个中间设备，将数据包从源端传送到目的端，有时候也称为unicasting单播</p><ul><li><p>一个发送方，一个接收方</p></li><li><p>路由选择很重要</p></li></ul><p><img src="https://s1.ax1x.com/2023/03/02/ppFmvOs.jpg" alt="广播网络对比点到点网络"></p></li></ul></li><li><p><strong><font color=#ff8b61>以传输技术分类：</font></strong></p><ul><li><p><strong><font color=#ff8aaf>Personal area network（个域网）：</font></strong> 允许设备围绕着一个人进行通信，例如蓝牙网络</p></li><li><p><strong><font color=#ff8aaf>Local area network（局域网）：</font></strong> 将主机和边缘路由器链接起来，共享<font color=#FF6347>同一个</font>通信链路，分为有线局域网和无线局域网</p><ul><li><p>在大多数情况下，每台计算机与安装在天花板上的一个设备通信，这个设备，称为接入点、无线路由器或者基站,它主要负责中继无线计算机之间的数据包，还负责中继无线计算机和Internet之间的数据包</p><p><img src="https://s1.ax1x.com/2023/03/02/ppF8ly8.jpg" alt="局域网"></p></li><li><p><font color=#b59bfd>拓扑结构：</font>总线型或环型</p></li><li><font color=#b59bfd>信道分配：</font><ul><li><p><font color=#DA70D6>静态</font>：将时间划分成时间槽，并使用轮循算法，每台机器只能在分配给它的时间槽到来时广播。当一台机器在分配给它的时间槽到来时没有任何数据需要发送，这种静态分配算法就浪费了信道容量</p></li><li><p><font color=#DA70D6>动态</font>：按需分配，可以是集中式的，也可以是分散式的。在集中式的信道分配方法中，有一个中心实体，由这个中心实体决定接下来谁使用信道；在分散式信道分配方法中，没有一个中央实体，每台机器必须自行决定是否可以传输</p></li></ul></li></ul></li><li><p><strong><font color=#ff8aaf>Metropolitan area network（城域网）：</font></strong> 范围可覆盖一个城市，例如有线电视网</p><ul><li><font color=#b59bfd>拓扑结构：</font>树型</li></ul></li><li><p><strong><font color=#ff8aaf>Wide area network（广域网）：</font></strong> 覆盖范围较广泛的通信网，通常是一个国家、地区或者一个大陆</p><ul><li><p>专门运行用户程序的计算机称为<font color=#FF6347>主机</font>；连接这些主机的网络其余部分称为<font color=#FF6347>通信子网</font>，子网的工作是把信息从一个主机携带到另一个主机</p><ul><li><font color=#DA70D6>通信子网:</font><ul><li><p><font color=#63B8FF>传输线路：</font>负责在机器之间移动比特，它们可以是铜线、光纤，甚至无线链路</p></li><li><p><font color=#63B8FF>交换元素：</font>简称为交换机，负责连接两条或两条以上的传输线路</p></li></ul><p><img src="https://s1.ax1x.com/2023/03/02/ppFy8mj.jpg" alt="通信子网"></p></li></ul></li><li><p><font color=#b59bfd>拓扑结构：</font>网孔型</p></li></ul></li><li><p><strong><font color=#ff8aaf>The Internet（互联网）</font></strong></p><ul><li><font color=#b59bfd>Internet和internet的区别：</font><ul><li><p><font color=#DA70D6>internet互联网：</font>网络与网络之间所串连成的庞大网络</p></li><li><p><font color=#DA70D6>Internet因特网：</font>一种特殊的覆盖全球的互联网</p><ul><li><font color=#63B8FF>网关：</font>在硬件和软件方面提供必要的翻译，将两个或多个不同的网络连接起来并提供必要转换的机器</li></ul></li></ul></li></ul></li></ul></li></ul><p><strong><font color=#fea401>子网，网络，互联网：</font></strong></p><ul><li><p><font color=#ff8b61>子网：</font><font color=#FF6347>路由器</font>和<font color=#FF6347>通信链路</font>的集合</p></li><li><p><font color=#ff8b61>网络：</font><font color=#FF6347>子网</font>和它的<font color=#FF6347>主机</font>的结合</p></li><li><p><font color=#ff8b61>互联网：</font>不同的网络互联</p></li></ul><h2 id="网络软件"><a href="#网络软件" class="headerlink" title="网络软件"></a>网络软件</h2><p><strong><font color=#fea401>协议层次结构：</font></strong></p><ul><li><p><strong><font color=#ff8b61>网络体系结构：</font></strong> 层和协议的集合，实现的细节和接口的规范都不是体系结构的一部分</p><ul><li><p>为了降低网络设计的复杂性，绝大多数网络都组织成一个层次栈或分级栈</p></li><li><p>每一层都是一个虚拟机，的目的是向更高的层提供特定服务，每层具体实现的细节对外不可见</p></li></ul></li><li><p><strong><font color=#ff8b61>层，对等体，协议，接口</font></strong></p><p>  <img src="https://s1.ax1x.com/2023/03/02/ppFgnt1.jpg" alt="协议层次结构"></p><ul><li><p><strong><font color=#ff8aaf>协议：</font></strong> 通信双方就如何进行通信的一种约定</p></li><li><p><strong><font color=#ff8aaf>对等体：</font></strong> 不同机器上构成对应层次相同的实体，可能是软件过程、硬件设备</p></li><li><p><strong><font color=#ff8aaf>物理介质：</font></strong>  第1层的下面是物理介质，通过它进行实际的通信</p></li><li><p><strong><font color=#ff8aaf>界面/接口：</font></strong> 定义了下层向上层提供哪些原语操作和服务</p><p><img src="https://s1.ax1x.com/2023/03/02/ppFRGFA.jpg" alt="层次举例"></p></li></ul></li><li><p><strong><font color=#ff8b61>5层网络</font></strong></p><p>  <img src="https://s1.ax1x.com/2023/03/02/ppFRhmF.jpg" alt="5层网络"></p><ul><li><p><strong><font color=#ff8aaf>第5层：</font></strong> 报文M由应用层产生，并交给第4层进行传输</p></li><li><p><strong><font color=#ff8aaf>第4层：</font></strong> 在报文前面加上一个头部以识别消息，并将结果传递给第3层</p><ul><li><font color=#DA70D6>头部：</font>控制信息，例如地址；在某些层中，Header还可以包含消息序号，消息大小、时间和其他控制字段</li></ul></li><li><p><strong><font color=#ff8aaf>第3层：</font></strong> 在第3层协议中传输的消息大小是有限制的，因此必须把入境消息分割成较小的单元，即<font color=#FF6347>数据包</font>或<font color=#FF6347>包</font>，并且在每个数据包前面加上第3层的头，决定使用哪条出站线路并将数据包传递到第2层</p></li><li><p><strong><font color=#ff8aaf>第2层：</font></strong> 不仅要加上一个头部还要加上一个<font color=#FF6347>尾部</font>用于差错检查，再将结果传输单元送给第1层以便进行物理传输</p></li><li><p><strong><font color=#ff8aaf>第1层：</font></strong> 把信息加载到物理介质上进行传输</p><p><img src="https://s1.ax1x.com/2023/03/02/ppFf5GR.jpg" alt="实际例子"></p></li></ul></li></ul><p><strong><font color=#fea401>层次设计问题：</font></strong></p><ul><li><p><strong><font color=#ff8b61>可靠性：</font></strong> 差错检测和差错修正；路由选择</p></li><li><p><strong><font color=#ff8b61>网络演进：</font></strong> 协议分层；addressing（寻址）和naming（命名）：识别发送者和接收者；internetworking（网络互联）：对消息进行拆分、传输，然后重组；可拓展性：网络规模变大时仍能工作良好</p></li><li><p><strong><font color=#ff8b61>资源分配：</font></strong> 统计复用：根据主机的短期需求变化动态共享网络带宽；流量控制，拥塞控制</p></li><li><p><strong><font color=#ff8b61>服务质量QoS：</font></strong><br>QoS包含的参数是带宽、时延、抖动、丢包率</p><ul><li><strong><font color=#ff8aaf>带宽：</font></strong> 在单位时间（一般指的是1秒钟）内能传输的数据量</li><li><strong><font color=#ff8aaf>时延：</font></strong> 一个报文或分组从一个网络的一端传送到另一个端所需要的时间。它包括了发送时延，传播时延，处理时延，排队时延。（时延=发送时延+传播时延+处理时延+排队时延）</li><li><strong><font color=#ff8aaf>抖动：</font></strong> 如果网络发生拥塞，导致通过同一连接传输的分组延迟各不相同。抖动用来描述延迟变化的程度，也就是最大延迟与最小延迟的时间差</li><li><strong><font color=#ff8aaf>丢包率：</font></strong> 丢包率是指在网络传输过程中丢失报文的数量占传输报文总数的百分比</li></ul></li><li><p><strong><font color=#ff8b61>安全性</font></strong></p></li></ul><p><strong><font color=#fea401>面向连接和无连接服务：</font></strong></p><div class="table-container"><table><thead><tr><th></th><th><font color=#ff8b61>面向连接服务</font></th><th><font color=#ff8b61>无连接服务</font></th></tr></thead><tbody><tr><td>参考</td><td>电话系统</td><td>邮政系统</td></tr><tr><td>特点</td><td>建立连接时分配资源，预先分配资源</td><td>分配仅当数据到达，动态分配资源，接收机不需要在线</td></tr><tr><td>Qos</td><td>可靠的传输</td><td>数据会丢失，乱序或重复</td></tr><tr><td>目的地址</td><td>只有建立连接时需要完整地址，后续不用</td><td>需要完整的目的地址</td></tr><tr><td>应用</td><td>大量数据在短时间内转送到目的地</td><td>少量数据</td></tr><tr><td>包含服务类型</td><td>Reliable message stream(可靠的报文流)<br>Reliable byte stream（可靠的字节流）<br>Unreliable connection（不可靠的连接）</td><td>Unreliable datagram（不可靠的数据报）<br>Acknowledged datagram（有确认的数据报）<br>Request-reply（请求-响应）</td></tr></tbody></table></div><p><strong><font color=#ff8aaf>可靠的报文流和可靠的字节流的区别：</font></strong><br>可靠的字节流没有边界，而可靠的报文流则有边界<br>例如：一个发送进程向一个连接中写入了1024字节数据，然后又写入了1024字节数据。对于可靠的报文流服务，接收进程将收到两个1024字节的数据；而对于可靠的字节流服务，接收进程将可能收到一个完整的 2048 字节的数据，即不能保证上层信息的边界</p><ul><li><p><strong><font color=#ff8b61>接口和服务：</font></strong></p><ul><li><p><strong><font color=#ff8aaf>服务提供者和服务用户：</font></strong> 第n层的实体向第n+1层提供了服务，第n层称为服务提供者，第n+1层称为服务用户</p></li><li><p><strong><font color=#ff8aaf>服务访问点SAP：</font></strong> 第n层的SAP是第n+1层可以访问所提供服务的地方</p></li><li><p><strong><font color=#ff8aaf>协议数据单元PDU：</font></strong> 对等体之间通信所传输的信息，<font color=#FF6347>平常所称的包就是PDU</font>，PDU=SDU+PCI（协议控制信息）</p></li></ul></li></ul><p><strong><font color=#fea401>服务原语：</font></strong> 同一个系统内相邻两层之间交互的信息</p><ul><li><p><strong><font color=#ff8b61>例子：</font></strong> </p><ul><li><p><strong><font color=#ff8aaf>CONNECT.request：</font></strong> 请求建立一个连接</p></li><li><p><strong><font color=#ff8aaf>CONNECT.indication：</font></strong> 通知被叫方有连接到达</p></li><li><p><strong><font color=#ff8aaf>CONNECT.response：</font></strong> 被叫方接收或拒绝呼叫</p></li><li><p><strong><font color=#ff8aaf>CONNECT.confirm：</font></strong> 告诉呼叫者是否被接受</p></li><li><p><strong><font color=#ff8aaf>DATA.request：</font></strong> 请求发送数据</p></li><li><p><strong><font color=#ff8aaf>DATA.indication：</font></strong> 通知有数据到达</p></li><li><p><strong><font color=#ff8aaf>DISCONNECT.request：</font></strong> 请求释放一个连接</p></li><li><p><strong><font color=#ff8aaf>ISCONNECT.indication：</font></strong> 通知有释放连接的请求到达</p><p><img src="https://s1.ax1x.com/2023/03/02/ppkpk0e.png" alt="服务原语示例"></p></li></ul></li><li><p><strong><font color=#ff8b61>简单的面向连接的服务：</font></strong></p><ul><li><strong><font color=#ff8aaf>系统调用：</font></strong> 操作系统提供给用户的API</li></ul></li></ul><div class="table-container"><table><thead><tr><th><font color=#ff8aaf>原语</font></th><th><font color=#ff8aaf>实例</font></th></tr></thead><tbody><tr><td>LISTEN</td><td>阻塞操作，等待入境连接请求</td></tr><tr><td>CONNECT</td><td>与等待中的对等实体建立连接</td></tr><tr><td>ACCEPT</td><td>接受来自对等实体的入境连接请求</td></tr><tr><td>RECEIVE</td><td>阻塞操作，等待入境报文</td></tr><tr><td>SEND</td><td>给对等实体发送一个报文</td></tr><tr><td>DISCONNECT</td><td>终止一个连接</td></tr></tbody></table></div><p><strong><font color=#fea401>服务和协议的关系：</font></strong> </p><ul><li><p><strong><font color=#ff8b61>服务（垂直）：</font></strong> 定义了<font color=#FF6347>某一层向它上一层</font>提供的一组原语（操作），但完全没有说明这些操作是如何实现的；与两层之间的接口有关，下层向上层提供服务</p></li><li><p><strong><font color=#ff8b61>协议（水平）：</font></strong> 规定了<font color=#FF6347>同一层上对等实体</font>之间所交换的数据包或者报文的格式和含义；<font color=#FF6347>服务通过协议实现它的定义</font></p></li><li><p>服务和协议是完全分开的，不更改服务的前提下，协议可以随意修改</p></li></ul><h2 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h2><p><strong><font color=#fea401>OSI参考模型：</font></strong></p><p><img src="https://s1.ax1x.com/2023/03/03/ppkmgC8.jpg" alt="OSI模型"></p><ul><li><p><strong><font color=#ff8b61>物理层：</font></strong> 在信道上传送原始的比特流</p></li><li><p><strong><font color=#ff8b61>数据链路层：</font></strong> 将一个原始的传输设施转变成一条没有漏检传输错误的线路</p><ul><li><p>发送方将输入的数据拆分成数据帧，然后顺序发送这些数据帧；如果服务是可靠的，则接收方必须给发送方发回一个确认帧</p></li><li><p><font color=#ff8aaf>流量控制：</font>避免一个快速发送方用数据“淹没”一个慢速接收方 </p></li></ul></li><li><p><strong><font color=#ff8b61>网络层：</font></strong> 控制子网的运行</p><ul><li><p><font color=#ff8aaf>路由选择：</font>根据路由表决定转发到哪个链路</p></li><li><font color=#ff8aaf>拥塞控制</font></li><li><p><font color=#ff8aaf>异构网络互联：</font>技术不同的网络互联</p></li><li><p>在广播网络当中，路由问题比较简单</p></li></ul></li><li><p><strong><font color=#ff8b61>传输层：</font></strong> 接收来自上一层的数据，在必要的时候把这些数据分割成较小的单元，然后把这些数据单元传递给网络层，并且确保这些数据单元正确地到达另一端</p><ul><li><p>传输层还决定了向会话层提供哪种类型的服务</p><ul><li><p>一个完全无错的点到点信道（最为常见）</p></li><li><p>传输独立的报文但不保证传送的顺序</p></li><li><p>将报文广播给多个目标节点</p></li></ul></li></ul></li><li><p><strong><font color=#ff8b61>会话层：</font></strong> 允许不同机器上的用户建立会话</p><ul><li><p><font color=#ff8aaf>对话控制：</font>记录该由谁来传递数据</p></li><li><p><font color=#ff8aaf>令牌管理：</font>禁止双方同时执行同一个关键操作</p></li><li><p><font color=#ff8aaf>同步功能：</font>在一个长传输过程中设置一些断点，以便在系统崩溃之后还能恢复到崩溃前的状态继续运行</p></li></ul></li><li><p><strong><font color=#ff8b61>表示层：</font></strong> 规定传输信息的语法和语义</p><ul><li>交换的数据结构必须以一种抽象的方式来定义</li></ul></li><li><p><strong><font color=#ff8b61>应用层：</font></strong> 包含了用户通常需要的各种各样的协议</p><ul><li>超文本传输协议HTTP</li></ul></li></ul><p><strong><font color=#ff8b61>OSI模型的核心是如下3个概念：</font></strong> </p><ul><li><p><strong><font color=#ff8aaf>服务：</font></strong> 某层实体对于上一层实体的支持</p></li><li><p><strong><font color=#ff8aaf>接口：</font></strong> 某层实体对于上一层实体提供的原语操作</p></li><li><p><strong><font color=#ff8aaf>协议：</font></strong> 两个对等体之间进行通信所必须遵守的原则</p></li></ul><p><strong><font color=#fea401>TCP/IP参考模型：</font></strong></p><p><img src="https://s1.ax1x.com/2023/03/03/ppkK3Hs.jpg" alt="两个参考模型对比"></p><ul><li><p><strong><font color=#ff8b61>链路层：</font></strong> 描述了链路必须完成什么功能才能满足无连接的互联网络层的需求；不是真正意义上的一个层，而是主机与传输线路之间的一个接口</p></li><li><p><strong><font color=#ff8b61>互联网层：</font></strong> 将整个网络体系结构贯穿在一起，是基于无连接互连层的分组交换网络</p><ul><li><p><font color=#ff8aaf>因特网协议IP：</font>正式的数据包格式和协议</p></li><li><p>互联网层的工作是把IP包送到它们应该去的地方</p><ul><li><p>分组路由，转发IP包</p></li><li><p>拥塞控制</p></li></ul></li></ul></li><li><p><strong><font color=#ff8b61>传输层：</font></strong> 允许源主机和目标主机上的对等实体进行对话，是在TCP/IP模型中位于互联网层之上的那一层</p><ul><li><p>定义了两个端到端的传输协议：</p><ul><li><p><font color=#DA70D6>传输控制协议TCP：</font><font color=#FF6347>可靠的、面向连接</font>的协议，允许从一台机器发出的字节流正确无误地交付到互联网上的另一台机器</p><ul><li><p>把输入的字节流分割成离散的报文，并把每个报文传递给互联网层</p></li><li><p>接收TCP进程把收到的报文重新装配到输出流中</p></li><li><p>流量控制</p></li></ul></li><li><p><font color=#DA70D6>用户数据报协议UDP：</font><font color=#FF6347>不可靠的、无连接</font>协议</p><ul><li><p>适用于那些不想要TCP的有序性或流量控制功能，而宁可自己提供这些功能的应用程序</p></li><li><p>应用于及时交付比精确交付更加重要的应用，比如传输语音或者视频</p></li></ul></li></ul></li></ul></li><li><p><strong><font color=#ff8b61>应用层：</font></strong> 包含了所有的高层协议，以及所需的任何会话和表示功能</p></li></ul><p><img src="https://s1.ax1x.com/2023/03/04/ppA6B26.jpg" alt="TCP/IP模型"></p><p><img src="https://s1.ax1x.com/2023/03/04/ppAcPZ4.png" alt="TCP/IP模型以及一些协议"></p><p>……未完待续♬</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%80%E7%</summary>
      
    
    
    
    <category term="专业课" scheme="https://jayerine.top/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="计网" scheme="https://jayerine.top/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 第三章 数据链路层</title>
    <link href="https://jayerine.top/2024/02/06/a6b483964d38/"/>
    <id>https://jayerine.top/2024/02/06/a6b483964d38/</id>
    <published>2024-02-06T04:00:21.561Z</published>
    <updated>2024-02-06T04:00:21.561Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0.webp" alt=""><br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0.jpg" alt=""></p><h1 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h1><p>物理层给数据链路层提供的服务是传送数字信号，这个信号有可能是恒定的比特流或字节流  </p><p>数据链路层在两个<font color=#FF6347>邻接</font>的计算机之间提供<font color=#FF6347>可靠的</font>，高效率的通信（点到点）  </p><ul><li>邻接：两个计算机之间用一个通信信道（有线或无线）连接在一起，也叫点到点。</li></ul><p>通信信道在概念上就像一条线路（比如同轴电缆、电话线或者无线信道）。信道像一条线路的本质特性使得信道上<font color=#FF6347>传递的比特顺序与发送顺序完全相同</font>。</p><h2 id="数据链路层的设计问题"><a href="#数据链路层的设计问题" class="headerlink" title="数据链路层的设计问题"></a>数据链路层的设计问题</h2><p>数据链路层使用物理层提供的服务在通信信道上发送和接收比特。它要完成一些功能，包括：<br>（1） 向网络层提供一个定义良好的服务接口。<br>（2） 把比特流或字节流封装成帧。<br>（3） 处理传输错误，尾部用于差错控制。<br>（4） 调节数据流，确保慢速的接收方不会被快速的发送方淹没。  </p><p><strong><font color=#fea401>数据链路层的功能:</font></strong></p><ul><li><p><strong><font color=#ff8b61>为网络层提供业务接口</font></strong></p><ul><li><p><strong><font color=#ff8aaf>数据链路层通常会提供以下3种可能的服务：</font></strong>  </p><ul><li><p><font color=#b59bfd>无确认的无连接服务：</font>源机器向目标机器发送独立的帧，目标机器并不对这些帧进行确认  </p><ul><li><p>想发就发，不管数据有没有差错或者丢失  </p></li><li><p>例如以太网</p></li><li><p>差错率非常低，如果出错需要最高层去解决，但是越高层解决，代价就越大 </p></li><li><p>语音传输</p></li></ul></li><li><p><font color=#b59bfd>有确认的无连接服务：</font>数据链路层仍然没有使用逻辑连接，但其发送的每一帧都需要单独确认</p><ul><li><p>WiFi  </p></li><li><p>发送方需要知道这一帧是正确到达了还是丢失了。若在特定的时间间隔内没有到达，则再发一遍</p></li></ul></li><li><p><font color=#b59bfd>有确认的有连接服务：</font>在数据链路层提供确认只是一种优化手段，永远不应该成为一种需求</p><ul><li><p>可靠性较差的长链路  </p></li><li><p>如果在计时器超时之前，该数据包的确认还没有到来，那么发送方只要再次发送整个报文即可。这一策略的麻烦在于它可能导致传输的低效率。</p></li></ul></li></ul></li></ul></li><li><p><strong><font color=#ff8b61>处理传输错误</font></strong></p></li><li><p><strong><font color=#ff8b61>调节数据流</font></strong></p></li></ul><p><strong><font color=#fea401>成帧：</font></strong> </p><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/1.jpg" alt="成帧"></p><p>一个比特流（或是字节流）通过点到点链路从节点A发送到节点B。节点B必须准确地识别构成帧的比特集，也就是说，它必须确定帧的开始和结束位置，哪几个比特是一伙的</p><p><strong><font color=#ff8b61>拆分比特流的4种方法：</font></strong></p><ul><li><p><strong><font color=#ff8aaf>字节计数法：</font></strong></p><p>  <img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/2.png" alt="字节计数法"></p><ul><li><p>面临的物理层提供的服务是字节流 </p></li><li><p>这个算法的问题在于计数值有可能因为一个传输错误而被弄混</p></li></ul></li><li><p><strong><font color=#ff8aaf>字符填充法：</font></strong> </p><p>  <img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/3.png" alt="字符填充法"></p><ul><li><p>每个帧用一些特殊的字节作为开始和结束。这些特殊字节通常都相同，称为标志字节，作为帧的起始和结束分界符</p></li><li><p>浪费了带宽</p></li></ul></li><li><p><strong><font color=#ff8aaf>比特填充法：</font></strong></p><ul><li><p>每个帧的开始和结束由一个特殊的比特模式，01111110标记，同时在数据当中每出现5个1，后面就插入1个0 </p></li><li><p>接收方读取到连续5个1后的0，会直接丢弃</p></li></ul></li><li><p><strong><font color=#ff8aaf>物理层编码违禁法：</font></strong></p><ul><li><p>比特编码成信号通常包括一些冗余比特，这种冗余意味着这种冗余不会出现在常规数据中。可以利用这些保留的信号来指示帧的开始和结束。</p></li><li><p><font color=#b59bfd>例如Manchester编码：</font>一个周期内电压由低到高表示为0，由高到低表示为1。<strong>则当电压恒为高或恒为低时，不表示数据，可用做定界符</strong>。</p></li><li><p><font color=#b59bfd>例如4B/5B编码：</font>11111表示空闲，11000表示一帧的开始</p></li><li><p><font color=#b59bfd>缺点：</font>但只适用于存在冗余编码的环境。 </p></li></ul></li></ul><p><strong><font color=#fea401>差错控制：</font></strong></p><p>数据链路层要确保所有的帧最终都被传递给目标机器的网络层，并且保持正确的顺序</p><p>对于无确认的无连接服务，不管发出去的帧是否正确抵达目标机器</p><p>但是对于可靠的、面向连接的服务，这样做肯定还远远不够</p><ul><li><p>确保可靠传递的常用方法是向发送方提供一些有关线路另一端状况的反馈信息</p></li><li><p>有时候由于硬件的问题，一个帧被完全丢失了</p><ul><li><p>有可能数据帧丢失接收方是否收到，也有可能接收方已经收到数据也做出了应答，但是ACK丢失了 </p></li><li><p>这种可能性可以通过在数据链路层中引入<font color=#FF6347>计时器</font>来解决：当发送方发出一帧时，通常要启动一个计时器，如果帧或者确认被丢失，则计时器将被触发，帧将会重新发送</p></li><li><p>同时为了避免接收方将两次或者多次接收到同一帧，要给每一帧<font color=#FF6347>分配序号</font>，这样接收方可以<strong>根据帧的序号来有效区分原始帧和重传帧</strong> </p></li></ul></li></ul><p><strong><font color=#fea401>流量控制：</font></strong></p><ul><li><p><strong><font color=#ff8b61>基于反馈的流量控制：</font></strong> 接收方给发送方返回信息，允许它发送更多的数据，或者至少告诉发送方自己的情况怎么样。发送数据必须得到接收方的同意</p></li><li><p><strong><font color=#ff8b61>基于速率的流量控制：</font></strong> 限制发送方传输数据的速率，无须利用接收方的反馈信息</p></li></ul><h2 id="差错检测和纠正"><a href="#差错检测和纠正" class="headerlink" title="差错检测和纠正"></a>差错检测和纠正</h2><p><strong><font color=#fea401>纠错码(ECC)：</font></strong></p><p>错误模型:</p><ul><li><p>单比特错误：只有一个比特发生改变</p></li><li><p>突发错误：2个或多个比特发生改变</p><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/1678799367193.jpg" alt="突发错误"><br>等价于在原始的数据基础上叠加了这么长的一个噪音</p></li></ul><ul><li><p><strong><font color=#ff8b61>海明码：</font></strong></p><ul><li><p><strong><font color=#ff8aaf>码字：</font></strong> 一个包含了<strong>数据位和校验位</strong>的n位单元</p></li><li><p><strong><font color=#ff8aaf>海明距离：</font></strong> 两个码字中不相同的位的个数</p><ul><li><p>为了可靠地检测d个错误，需要一个距离为<font color=#FF6347>d+1</font>的编码方案（编码：把有效数据变成若干个码字，任意两个合法的码字之间的距离至少为n+1） </p></li><li><p>为了纠正d个错误，需要一个距离为<font color=#FF6347>2d+1</font>的编码方案</p></li></ul></li><li><p><strong><font color=#ff8aaf>纠正单个错误所需的校验位数：</font></strong> </p><ul><li><p>m个消息位，r个校验位，n=m+r个码字</p></li><li><p>有$2^m$个合法的消息</p></li><li><p>则需要满足：<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/a34447959860e8ec4cfeca23731f77e.jpg" alt="m和r的关系"></p></li></ul></li><li><p><strong><font color=#ff8aaf>海明码：</font></strong> </p><p>在海明码中，码字的位被连续编号，从最左端的位开始，紧跟在右边的那位是2，依次从左到右编号。2的幕次方的位（1,2,4,8,16等）是校验位，其余位用来填充m个数据位</p><p>每一个校验位强制进行模2加，或对某些位的集合，包括其本身进行偶（或奇）校验</p><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/cc4c8b595d36e82239c020e2e5e8a2a.jpg" alt="海明码"></p><p><font color=#b59bfd>海明码纠正突发错误：</font><br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/78f910a1650e66d63961c0bc899a89d.jpg" alt="海明码纠正突发错误"></p></li></ul></li><li><p><strong><font color=#ff8b61>二进制卷积码</font></strong></p></li><li><p><strong><font color=#ff8b61>里德所罗门码</font></strong></p></li><li><p><strong><font color=#ff8b61>低密度奇偶校验码</font></strong></p></li></ul><p><strong><font color=#fea401>检错码：</font></strong></p><p>光纤或高品质铜线的错误率要低得多，因此对于偶尔出现的错误采用差错检测和重传的处理方式通常更加有效</p><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/6046da809151c13eefb101a713644ca.jpg" alt="开销对比"></p><p>海明码检测出错之后<font color=#FF6347>不用重传，可以自行纠错（翻转出错的比特）</font></p><ul><li><p><strong><font color=#ff8b61>奇偶校验：</font></strong> </p><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/c158f43a7bafed78b18af98207b7a60.jpg" alt="奇偶校验"></p><ul><li><p>可以检测突发错误小于等于r的</p></li><li><p>可能可以检测出偶数个比特的翻转，<font color=#FF6347>一定可以检测出奇数个比特的翻转</font></p></li><li><p>若突发错误的长度<strong>大于r且有偶数个比特的翻转</strong>，则被接受的概率为<font color=#FF6347>${(\frac{1}{2})^{r}}$</font></p></li></ul></li><li><p><strong><font color=#ff8b61>多项式编码(CRC,Cyclic Redundancy Check)：</font></strong></p><ul><li><p>将位串看成是系数为0或1的多项式M(x)，作为被除数。一个k位帧看作是一个k-1次多项式的系数列表，该多项式共有k项，从$x^{k-1}$到$x^0$</p></li><li><p>生成多项式G(x)作为除数，发送方和接收方约定好G(x)</p></li><li><p><font color=#ff8aaf>多项式的模2算术：</font>加法和减法等同于异或</p></li><li><p>M(x)/G(x)，进行模2运算，得到余数即为帧校验序列 </p></li></ul><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/98d199807906993dbd21ca457ee5582.png" alt="CRC"></p><ul><li><p>如果传输过程中出现了错误，则接收方收到的数据可以看作正确数据和差错的叠加，即T(x)+E(x)。由于接受方收到的正确数据T(x)一定有：T(x)/G(x)的余数一定为0，那么结果为E(x)/G(x)</p><ul><li><p>若E(x)/G(x)余数恰好为0，则差错会被忽略</p></li><li><p>除此之外，其他情况都可以检测出来</p><ul><li><p><font color=#DA70D6>突发错误的长度小于等于r：</font>此时E(x)/G(x)一定有余数</p></li><li><p><font color=#DA70D6>两个独立的单比特错误：</font>则$E(x)=x^{i}+x^{j}$,这里i&gt;j。换一种写法，E(x)可以写成$E(x)=x^{j}(x^{i-j}+1)$。因此对于任何小于等于i-j最大值(即小于等于最大帧长)的k值，$G(x)$都不能除尽$x^k+1$</p></li><li><p><font color=#DA70D6>奇数个比特的翻转：</font>在模2系统中，没有一个奇数项多项式包含x+1因子，因此可令$G(x)$含有因子$(x+1)$</p></li><li><font color=#DA70D6>突发错误的长度超过r：</font>错误的帧被接收的概率为<font color=#FF6347>${(\frac{1}{2})^{r}}$</font></li></ul></li></ul></li></ul></li></ul><font color=#ff8aaf>CRC放在帧尾的原因：</font>  如果把CRC放在帧头，那么在发送前要把整个帧扫描一遍来计算CRC，然后再从帧头开始发送，这样每一位都要处理两次，比较浪费时间  把CRC放在帧尾，边发送边计算校验位，数据比特发送完紧跟着把硬件寄存器里生成的校验比特发出去，可以一次完成，效率较高  ![生成多项式](https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/6.jpg)  ![生成多项式的软硬件实现](https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/7.jpg)## 初级数据链路层协议wait_for_event(&event)：标示数据链路层正在等待事情发生，只有当确实发生了什么事情（比如到达了一个帧），该过程才返回to_network_layer/from_network_layer：和网络层之间的接口to_physical_layer/from_physical_layer：和物理层之间的接口timer operations：定时器操作enable_network_layer/disable_network_layer：流量控制，控制网络层是否可以发送数据![函数](https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/8.jpg)协议定义：![协议定义](https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/9.jpg)**<font color=#fea401>一个乌托邦式的单工协议</font>****不需要考虑任何出错**的情况，数据只能**单向**传输发送方和接收方的网络层总是处于准备就绪状态，数据处理的时间忽略不计![一个乌托邦式的单工协议](https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/10.jpg)**<font color=#fea401>无错信道上的单工停-等式协议</font>**仍然假设通信信道**不会出错**，并且数据流量还是**单工**的接收方只有有限的缓冲区容量和处理速度，因此协议必须有显式的应答，防止发送方以超过处理速度的数据淹没接收方![无错信道上的单工停-等式协议](https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/11.jpg)**<font color=#fea401>有错信道上的单工停-等式协议</font>**![有错信道上的单工停-等式协议](https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/12.jpg)区分第一次看到的帧和重传的帧,需要在每帧的头部放一个序列号，则 **<font color=#ff8b61>序列号的最小位数为：</font>*** **<font color=#ff8aaf>链路层：</font>** 1比特，编号空间大小为2* **<font color=#ff8aaf>传输层：</font>** 1比特编号空间太小，需要较大的编号空间，如：TFTP（16比特）**<font color=#ff8b61>发送方：</font>**<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">seq_nr=<span class="number">0</span> <span class="comment">//用于记录buffer的序号</span></span><br><span class="line">从网络层获取一个分组放入buffer</span><br><span class="line">label1:</span><br><span class="line">发送buffer中的数据（带上序号seq_nr），新启动定时器</span><br><span class="line">wait_for_event()</span><br><span class="line"><span class="keyword">switch</span> (event) &#123;</span><br><span class="line">  <span class="keyword">case</span> 收到了坏帧(校验和错):</span><br><span class="line">     <span class="comment">//重发缓冲（在收到ACK之前，一直存在缓冲区中）在buffer里的数据，重新启动定时器</span></span><br><span class="line">  <span class="keyword">case</span> 定时器超时:</span><br><span class="line">     <span class="comment">//重发缓冲在buffer里的数据，新启动定时器</span></span><br><span class="line">  <span class="keyword">case</span> 收到校验和正确的帧:</span><br><span class="line">    <span class="keyword">if</span>（ack序号正确） &#123;</span><br><span class="line">      关闭旧定时器</span><br><span class="line">      inc(seq_nr)</span><br><span class="line">      从网络层获取下一个分组放入buffer</span><br><span class="line">      <span class="comment">//发送buffer中的数据，新启动定时器</span></span><br><span class="line">    &#125;<span class="keyword">else</span> </span><br><span class="line">      <span class="comment">//重发缓冲在buffer里的数据，重新启动定时器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> label1</span><br><span class="line">从网络层获取一个分组放入buffer</span><br><span class="line">next_frame_to_send = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  发送buffer中的数据，启动定时器</span><br><span class="line">  帧序号填写为next_frame_to_send</span><br><span class="line">  <span class="title function_">wait_for_event</span><span class="params">()</span></span><br><span class="line">  <span class="title function_">if</span> <span class="params">(收到校验和正确的帧)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ack序号正确)&#123;</span><br><span class="line">      关闭旧定时器</span><br><span class="line">      从网络层获取下一个分组放入buffer</span><br><span class="line">      <span class="title function_">inc</span><span class="params">(next_frame_to_send)</span></span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>![发送方](https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/13.jpg)**<font color=#ff8b61>接收方：</font>**<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">frame_expected=<span class="number">0</span> <span class="comment">//希望收到几号帧</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  wait_for_event()</span><br><span class="line">  <span class="keyword">switch</span>(event) &#123;</span><br><span class="line">  <span class="keyword">case</span> 坏帧:</span><br><span class="line">     do_nothing</span><br><span class="line">  <span class="keyword">case</span> 收到校验和正确的数据帧:</span><br><span class="line">    <span class="keyword">if</span>(序号==frame_expected)&#123;</span><br><span class="line">      向网络层上交分组</span><br><span class="line">      回ACK(序号为frame_expected)</span><br><span class="line">      inc(frame_expected)</span><br><span class="line">    &#125;</span><br><span class="line">      回ACK(序号为frame_expected<span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>![发送方](https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/14.png)**<font color=#ff8b61>计时器：</font>** 如果计时器设置的时间隔太短，发送端会发送不必要的帧，虽然这些额外的帧不会影响协议的正确性，但会影响性能## 滑动窗口协议对于全双工的通信：* 使用两个单独的信道，分别用在两个不同的方向进行单工数据传输* 使用相同的电路进行两个方向的数据传输**捎带确认：*** 当到达一个数据帧时，并不是立即发送一个单独的控制帧（回答ACK），而是抑制自己并开始等待，直到网络层传递给它下一个要发送的数据包。然后，确认信息被附加在往外发送的数据帧上（使用帧头的ACK字段）  * 简单来说，就是我方发数据过去，对方也会发数据过来，对方给我回数据的帧里，顺便捎带ACK，可以优化性能节省资源* 若网络层没有数据帧传输，则需要设置定时器，当定时器超时后，则专门传输一个空帧表示数据已经到达**发送窗口：*** 用于控制悬而未决的帧的编号    发送方的数据一共分三种情况：  * 完全结束：数据已经发给接收方，并且得到接收方的ACK  * 悬而未决：发过去的数据没有收到任何确认，这种情况下要保留发送窗口，记住编号同时缓存数据，便于无应答时重传  * 还没有发送* 在任何时候，发送方把已经发送过的帧的序号，包括重传的内容，构成了发送窗口。如果有某一帧落在滑动窗口内，表示这一帧已经发送过了，但还没收到ACK* 发送窗口的大小越小越好**接收窗口：*** 接收方也维持着一个接收窗口，对应于一组允许它接受的帧数据链路层中，发送窗口和接收窗口的大小是固定的**<font color=#fea401>1位滑动窗口协议</font>** 等效于停等协议滑动窗口的大小等于1，允许悬而未决的帧只能有1个至少需要3个比特的序号，取值0~7![1位滑动窗口协议](https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/15.jpg)![1位滑动窗口协议](https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/16.png)![1位滑动窗口协议](https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/17.png)![1位滑动窗口协议](https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/18.png)问题（链路利用率）：![问题](https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/19.png)一个50kbps的卫星信道，传播时延是270ms，发送的数据帧是1000比特*  t=0:发送方开始发送 * t=20 msec:帧已经完全发送 * t=270 msec:帧完全到达接收方 * t=520 msec: 在最好的情况下，ACK到达发送方(在接收方没有等待，只发送一个短的确认帧，几乎不占用时间)。![问题](https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/20.jpg)假设信道的容量是B bit/s（即带宽，一秒钟能传多少比特）每一帧的长度是l bit往返的时延是R s则链路利用率为：$(l/B)/(l/B+2R)=l/(l+2BR)=1/(1+2BR/l)$其中l/B是传输速率；BR是往返时间**<font color=#fea401>回退N协议</font>** 流水线和差错恢复：![流水线和差错恢复](https://s1.ax1x.com/2023/03/23/ppwCHPI.png)(a)接收器的窗口大小为1，不需要缓存，一旦有错误后面的全部丢弃，直到超时后再重传(b)接收器的窗口大小较大，当发送的顺序不对时，先暂时存着，会占用更多的存储空间基于滑动窗口（接收器的窗口大小为1）：* 使用窗口控制悬而未决的帧的数量 * 如果接收方检测到错误，丢弃该帧和所有未来帧，直到正确接收到之前出错的帧；如果接收方收到不想要的数据帧，保持沉默* 发送方必须返回并重新发送该帧和所有后续帧坏帧：* 如果数据帧被损坏：    * 接收器在帧i中检测到错误，则直接丢弃帧i和所有后续帧，超时后发送方将重传帧i和所有后续帧* 如果ACK帧被损坏：  * 约定收到ACK(i)则表明帧i及其以前所有的帧都已经收到了  * 如果发送超时，同样需要重传帧i和所有后续帧发送窗口的最大值：3比特序号，则发送窗口的最大值是7原则：当发送方发送完发送窗口内所有帧，在未收到ACK之前，接收方正确接收到所有发送来的帧，接收窗口向前推移，此时，必须保证发送窗口与接收窗口在序号上**不能重叠**![原则](https://s1.ax1x.com/2023/03/23/ppwkpIH.jpg)![回退N协议](https://s1.ax1x.com/2023/03/23/ppwmdYD.png)判断序号b是否落在窗口(a,c)内：![判断序号b是否落在窗口(a,c)内](https://s1.ax1x.com/2023/03/23/ppwm3l9.png)![](https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/21.jpg)![](https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/22.png)![](https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/23.png)![](https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/24.jpg)改进和效率:* 设置ACK定时器:  * 发送数据并非一个源源不断的分组流，无法及时搭载ACK时，因此可以发送一个短的ACK帧（不含数据信息）  * 用于回送ACK的定时器start_ack_timer与stop_ack_timer，当许久没有数据发送时，定时器超时，此时就可以发送一个短的ACK帧  * 数据重传所用定时器start_timer是**每个数据有一个**，再次启动时要重新计时；用于回送ACK的定时器start_ack_timer**只有一个**，启动多个时都以最先启动的计时器开始计时，当有任何反向流量（包括数据，NAK，里面都有ACK序号）时，ACK定时器则被停止  * ACK定时器时限的设计* 协议参数与线路利用率  * 超时定时器时限的设计（考虑线路往返时间延迟，ACK定时器时限，对方物理层发送排队时延）  * 滑动窗口即MAX_SEQ大小（窗口太小可能导致无法流水线操作出现停等，效率低下）**<font color=#fea401>回退N协议选择重传协议</font>** * 发送方只重传被拒绝的帧，接收方会将后续的帧接收下来并缓存，因此可以实现最小化重传次数* 但缺点是必须维持一个大的缓冲区，协议会变得更复杂**选择重传的窗口大小：**由于发送窗口大小和接收窗口大小一样，且当接收方接收到发送方全部数据，但会送的ACK全部丢失，需要发送方重传时，窗口中的序号不能有重叠，因此：**选择重传窗口最大大小：$2^{n-1}$=(MAX_SEQ+1)/2****回退N窗口最大大小：$2^{n}-1$=MAX_SEQ**其中n为序号的个数$W_s$：发送窗口最大值，$W_r$：接收窗口大小，则<font color=#FF6347>$W_s+W_r<=2^n$,$W_r=W_s$</font><p><strong>NAK：</strong></p><p>当接收方有理由怀疑发生了错误，它将NAK帧发送回发送方，请求重新传输  </p><p>有两种情况：</p><ul><li><p>收到一个坏帧 </p></li><li><p>收到一个不同于预期的帧</p></li></ul><p>要避免对同一帧进行多个重传输请求，接收方应该跟踪是否已经为给指定帧发送了一个NAK帧</p><p><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/29.png" alt="选择重传"></p><p><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/30.jpg" alt=""></p><p><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/31.png" alt=""></p><p><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/32.png" alt=""></p><p><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/33.png" alt=""></p><ul><li>停等协议——无差错<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/34.jpg" alt="停等协议——无差错"></li><li>停等协议——有差错<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/35.jpg" alt="停等协议——有差错"></li><li>滑动窗口——无差错<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/36.png" alt="滑动窗口——无差错"> </li><li>捎带传输：$U=\frac{N}{2+2\alpha}$ </li></ul><h2 id="数据链路协议实例"><a href="#数据链路协议实例" class="headerlink" title="数据链路协议实例"></a>数据链路协议实例</h2><p><strong><font color=#fea401>HDLC（High-level Data Link Control）：</font></strong></p><p><img src="https://s1.ax1x.com/2023/03/28/pp63wUU.png" alt="HDLC"></p><p>不平衡：一个主站，一个或多个从站</p><p>平衡：两个混合站，全双工</p><p><strong>HDLC帧格式：</strong></p><p>使用比特填充法<br><img src="https://s1.ax1x.com/2023/03/28/pp68Ms1.png" alt="HDLC帧格式"></p><p><strong>Control字段：</strong></p><p><img src="https://s1.ax1x.com/2023/03/28/pp68xw6.png" alt="HDLC帧Control字段"></p><p>(a)I-frame(INFO)：数据帧<br>(b)S-frame：监督帧<br>(c)U-frame：没有编号的帧  </p><ul><li><p><strong><font color=#ff8b61>I-frame：</font></strong></p><p><img src="https://s1.ax1x.com/2023/03/28/pp60Q9P.png" alt="I-frame"></p></li><li><p><strong><font color=#ff8b61>S-frame：</font></strong></p><p><img src="https://s1.ax1x.com/2023/03/28/pp6DDw4.png" alt="I-frame"></p><p>Code:RR, RNR, REJ, SREJ  (3-bit N(R))<br>ACK帧：RR,RNR<br>NAK帧：REJ,SREJ  </p><ul><li><p><strong><font color=#ff8aaf>RR:</font></strong> 接收方准备好<br>表示期望的N(R)帧的ACK帧<br>只在没有反向流量可用于捎带时使用该帧<br>仍可以发送数据</p></li><li><p><strong><font color=#ff8aaf>RNR:</font></strong> 接收方没有准备好<br>它像RR一样，识别所有不包括N(R)的帧<br>但它告诉发送方停止发送(流量控制)</p></li><li><p><strong><font color=#ff8aaf>REJ:</font></strong> 拒绝<br>表示检测到传输错误<br>N(R)字段表示序列中第一个未正确接收的帧（即，要重传的帧）<br>发送端需要重传从N(R)开始的所有（悬而未决）帧</p></li><li><p><strong><font color=#ff8aaf>SREJ:</font></strong> 选择性拒绝<br>只调用N(R)指定的帧的重传<br>如果接收端希望缓冲无序帧以备将来使用，它可以使用SREJ强制重传任何特定帧</p></li></ul></li><li><p><strong><font color=#ff8b61>U-frame：</font></strong></p><p><img src="https://s1.ax1x.com/2023/03/28/pp6rJBD.png" alt="U-frame"></p></li></ul><p><strong>P/F：</strong></p><p>非平衡方式：<br>Poll：邀请终端发送数据<br>Final：终端发送的所有帧，除最后一帧外，均将P/F位设置为0，最后一个是1  </p><p>平衡方式：<br>Command（P位）：P=1以恳求(Poll)对方做出响应<br>Response（F位）：F=1表示对请求命令的响应<br>强制另一台机器立即发送一个监督帧，而不是等待反向通信，以便在反向通信上捎带窗口信息</p><p><img src="https://s1.ax1x.com/2023/03/28/pp62l3d.png" alt="平衡方式"></p><p>HDLC操作实例：</p><p><img src="https://s1.ax1x.com/2023/03/28/pp6WwXn.png" alt="HDLC操作实例"></p><p><img src="https://s1.ax1x.com/2023/03/28/pp6W6tU.png" alt="HDLC操作实例"></p><p><strong><font color=#fea401>PPP（点到点协议）</font></strong></p><p><img src="https://s1.ax1x.com/2023/03/28/pp6HP6U.png" alt="PPP"></p><p>PPP协议子层：</p><p><img src="https://s1.ax1x.com/2023/03/28/pp6HZkR.png" alt="PPP协议子层"></p><p>特性:   </p><ul><li><p>Layer 1 </p><ul><li>同步线路(支持面向比特的编码)  </li><li>异步电路(支持面向字节编码) </li><li>PPPoE (支持以太网) </li></ul></li><li><p>LCP(Link Control Protocol):链路控制协议</p><ul><li>错误检测(CRC) </li><li>允许认证  </li></ul></li><li><p>允许在连接时协商IP地址  </p></li><li><p>多种协议:NCP(IP, IPX，…)</p></li></ul><p><img src="https://s1.ax1x.com/2023/03/28/pp6HQXD.png" alt="多协议"></p><p><strong><font color=#ff8b61>PPP帧格式：</font></strong></p><p><img src="https://s1.ax1x.com/2023/03/28/pp6biCt.png" alt="PPP帧格式"></p><p>PPP状态转移图：</p><p><img src="https://s1.ax1x.com/2023/03/28/pp6byrD.png" alt="PPP状态转移图"></p><p><strong><font color=#ff8b61>LCP链路控制协议(Link Control Protocol)：</font></strong></p><ul><li><p>数据帧的最大有效负载大小</p></li><li><p>身份验证和选择要使用的协议</p><ul><li><p>PAP(Password Authentication Protocol)：密码认证协议（密码会被偷听）</p></li><li><p>CHAP(Challenge Handshake Authentication Protocol)：挑战握手认证协议<br><img src="https://s1.ax1x.com/2023/03/28/pp6XPeS.png" alt="CHAP"></p></li></ul></li><li><p>压缩：对头和数据进行压缩</p></li><li><p>异步方式，<font color=#FF6347>字节填充法</font>，链接建立时指定转义字符集ACCM (Async-Control-Character-Map, 32 bits，用bitmap指定需转义的ASCII 码的控制字符集合)</p><ul><li>FLAG为0x7E，ESC为0x7D<br>0x7E==&gt;0x7D, 0x5E<br>0x7D==&gt;0x7D, 0x5D<br>控制字符C ==&gt; 0x7D，C xor 0x20<br>判断方法 (C &lt; 0x20) &amp;&amp; ((1 &lt;&lt; C) &amp; ACCM)<br>反转义：<font color=#FF6347>看到0x7D，直接让后面的数与0x20异或</font></li></ul></li></ul><p><strong>PPP和HDLC的区别：</strong>  </p><ul><li>PPP是面向字节而不是面向比特的。特别是PPP使用<font color=#FF6347>字节填充技术</font>，所有帧的长度均是字节的整数倍<br>HDLC协议则使用<font color=#FF6347>比特填充技术</font>， 允许帧的长度不是字节的倍数</li><li>HDLC协议提供了<font color=#FF6347>可靠的</font>数据传输，PPP是<font color=#FF6347>面向连接的不可靠的</font></li></ul><p>……未完待续♬</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%</summary>
      
    
    
    
    <category term="专业课" scheme="https://jayerine.top/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="计网" scheme="https://jayerine.top/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 第二章 物理层</title>
    <link href="https://jayerine.top/2024/02/06/c1da0ecf4a63/"/>
    <id>https://jayerine.top/2024/02/06/c1da0ecf4a63/</id>
    <published>2024-02-06T04:00:21.561Z</published>
    <updated>2024-02-06T04:00:21.561Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%BA%8C%E7%AB%A0.webp" alt="思维导图"></p><h1 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h1><p><strong><font color=#fea401>基本概念：</font></strong> </p><ul><li><p><strong><font color=#ff8b61>信道(Channel)：</font></strong> 传送信息的媒体</p></li><li><p><strong><font color=#ff8b61>数据率(Bit Rate)：</font></strong> 数据传输速率 (bps)</p></li><li><p><strong><font color=#ff8b61>波特(Baud)：</font></strong> 码元传输速率（每秒传输多少个符号）</p><ul><li><p>$1 Baud = (\log_{2}{V})$ bps，其中V是信号的电平级数，一般都为2的幂次。</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">四电平传输是指在数字通信中使用四个电平级别来传输数字信号。与二电平（高电平和低电平）不同，四电平使用四个电平（例如-3V，-1V，+1V和+3V）来表示数字信号，这样就可以在每个脉冲周期内传输更多的比特。</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong><font color=#ff8b61>传播速度(Propagation Speed)：</font></strong> 通信线路上，信号单位时间内传送的距离（米/秒）</p><ul><li><p>媒体不同，传播速度也不同</p></li><li><p>同种媒体，频率不同的电磁波速度有差异</p></li><li><p>小于光速 </p></li></ul></li><li><p><strong><font color=#ff8b61>带宽(Bandwidth)：</font></strong> 信号占用的频率范围 (Hz) ，超出范围则无法传输</p></li><li><p><strong><font color=#ff8b61>信道容量(Channel Capacity)：</font></strong> 信道的最大数据率</p></li><li><p><strong><font color=#ff8b61>吞吐量(Throughput)：</font></strong> 网络容量的度量，表示单位时间内网络可以传送的数据位数（bps）</p></li><li><p><strong><font color=#ff8b61>误码率BER(Bit Error Rate)：</font></strong> 信道传输可靠性指标</p><ul><li>P= 传送错的位数 / 传送总位数</li></ul></li><li><p><strong><font color=#ff8b61>时延(Delay)：</font></strong> 从向网络中发送数据块的第一比特开始，到最后一位数据被接收所经历的时间</p><ul><li><p><strong><font color=#ff8aaf>时延的组成：</font></strong> 传播时延、发送时延、处理时延、排队时延    </p><ul><li><p><font color=#DA70D6>传播时延：</font>信号通过传输介质的时间。</p></li><li><p><font color=#DA70D6>发送时延：</font>设备发送一个数据块所需要的时间（数据块长度/信道带宽）    </p></li><li><p><font color=#DA70D6>处理时延：</font>交换机/路由器检查数据、选路的时间</p></li><li><p><font color=#DA70D6>排队时延：</font>在交换机/路由器中排队等待的时间</p></li></ul></li></ul></li></ul><p><strong><font color=#fea401>单工，半双工，全双工：</font></strong></p><ul><li><p><strong><font color=#ff8b61>单工：</font></strong> 传播只发生在一个方向，没有反向的信道</p><ul><li>例如： 调频无线电广播</li></ul></li><li><p><strong><font color=#ff8b61>半双工：</font></strong> 传输可以在两个方向进行，但在同一时间只有一个方向是可用的，不能同时传输信息</p><ul><li>例如：对讲机</li></ul></li><li><p><strong><font color=#ff8b61>全双工：</font></strong> 传输可以同时在两个方向进行</p><ul><li>例如：电话交谈</li></ul></li></ul><p><strong><font color=#fea401>串行通信和并行通信：</font></strong></p><ul><li><p><strong><font color=#ff8b61>串行通信：</font></strong> 数据一位位顺序传送</p><ul><li><p><strong><font color=#ff8aaf>同步串行通信：</font></strong> 通信双方共用一个时钟来实现发送端和接收端的同步</p><ul><li><p>以时钟信号线对传输的数据线上的信号进行比特同步</p></li><li><p>以数据块（帧或分组）为单位传输</p></li></ul></li><li><p><strong><font color=#ff8aaf>异步串行通信：</font></strong> 发送端与接收端之间只需要数据线连接，无需额外的时钟线互联，传输的信息中包含特殊标志位<font color=#FF6347>Start（在字符最后，为0）</font>和<font color=#FF6347>Stop（在字符前段，为1）</font>，接收设备根据特殊标志位可以判断数据传输的开始和结束</p><ul><li><p>独立时钟，无须同步</p></li><li><p>以字符为单位进行传输</p></li><li><p>发送两个字符之间的间隔是任意的</p></li><li><p>接收方依靠字符中的起始位和停止位来同步</p></li></ul><p><img src="https://s1.ax1x.com/2023/03/05/ppEw7i6.png" alt="同步和异步通信"></p></li></ul></li><li><p><strong><font color=#ff8b61>并行通信：</font></strong> 数据各位同时传送</p></li></ul><h2 id="数据通信理论基础"><a href="#数据通信理论基础" class="headerlink" title="数据通信理论基础"></a>数据通信理论基础</h2><p><strong><font color=#fea401>傅里叶分析：</font></strong></p><p><img src="https://s1.ax1x.com/2023/03/05/ppE0AyQ.png" alt="傅里叶分析"></p><ul><li><p>任何有周期T的函数，都可以拆分成若干个正弦波和余弦波的叠加</p></li><li><p>所有的传输设施在传输过程中都要损失一些能量</p></li><li><p>所有的传输设施对于不同傅里叶分量的衰减程度并不相同</p><ul><li>对于不同的正弦波，衰减因子不一样</li></ul></li></ul><p><strong><font color=#fea401>带宽有限的信号：</font></strong></p><ul><li><p><strong><font color=#ff8b61>带宽（传输介质的带宽）：</font></strong> 没有被强(衰减因子为<font color=#FF6347>0.5</font>)衰减的传输频率范围</p><ul><li><p>带宽是传输介质的一种物理特性，通常取决于介质的构成、粗细和电线或者光纤的长度</p><p>  <img src="https://s1.ax1x.com/2023/03/04/ppARZzq.jpg" alt="带宽"></p></li><li><p><strong><font color=#ff8aaf>带宽受限：</font></strong> </p><p>  <img src="https://s1.ax1x.com/2023/03/05/ppE0uF0.jpg" alt="带宽受限"><br>  <img src="https://s1.ax1x.com/2023/03/05/ppE01lF.jpg" alt="带宽受限"><br>  <img src="https://s1.ax1x.com/2023/03/05/ppE08OJ.jpg" alt="带宽受限"></p><ul><li><p>语音级信道带宽为3000Hz</p></li><li><p>T=8/Bps</p></li><li><p>基准谐波：f=Bps/8</p></li><li><p>Harmonics Sent=3000/f=24000/Bps</p></li></ul></li></ul></li></ul><p><strong><font color=#fea401>信道的最大数据速率：</font></strong></p><ul><li><p><strong><font color=#ff8b61>Nyquist’s Theorem：</font></strong> 如果一个信号经过一个带宽为H的低通滤波器（没有高频成分了），信号可以通过每秒2H次采样来完全重构（超过2H的信息已经没有任何价值）</p><p>  <img src="https://s1.ax1x.com/2023/03/04/ppA7mlQ.jpg" alt="采样"></p><ul><li><p><strong><font color=#ff8aaf>最大数据速率：</font></strong> $C=2H\log_{2}{V}$ (b/s)</p><ul><li><p>采样的频率不能超过2H</p></li><li><p>V是符号可能的电平级数（V和噪音有关），因此所携带的信息量是$\log_{2}{V}$(bit)，每秒有2H次次采样，因此有速率为$2H\log_{2}{V}$(b/s)</p></li></ul></li></ul></li><li><p><strong><font color=#ff8b61>Shannon’s Theorem：</font></strong></p><ul><li><p><strong><font color=#ff8aaf>最大数据速率：</font></strong> $C=H\log_{2}{(1+S/N)}$</p><ul><li>S是信号，N是噪音</li></ul></li><li><p>分贝换算： $(S/N)_{dB}=10×\log_{10}{(S/N)}$</p></li></ul></li></ul><h2 id="引导性传输介质"><a href="#引导性传输介质" class="headerlink" title="引导性传输介质"></a>引导性传输介质</h2><p><strong><font color=#fea401>磁介质：</font></strong></p><ul><li><p>带宽：一盘磁带可以容纳800GB，一个盒子可以容纳1000个磁带:800TB；带宽=800Tx8bits/86400s秒=70Gbps </p></li><li><p>成本：磁带成本4000美元每盒每次使用；运输1000美元，运输1GB低于0.5美分</p></li></ul><p><strong><font color=#fea401>双绞线：</font></strong></p><p><img src="https://pic4.zhimg.com/v2-2640cfd4bb07d1f1ec97cceec3db2edb_r.jpg" alt="双绞线"></p><ul><li><p>无屏蔽双绞线UTP，屏蔽双绞线STP</p><ul><li><p>Category 3 UTP: 16MHz</p></li><li><p>Category 5 UTP: 100MHz</p></li><li><p>Category 6 UTP: 250MHz</p></li><li><p>Category 7 UTP: 600MHz</p></li></ul></li><li><font color=#FF6347>电流大小相等，方向相反</font></li><li><p><strong><font color=#ff8b61>差分传输：</font></strong> 减弱环境噪音对自身信号的影响</p></li><li><p><strong><font color=#ff8b61>减少串扰：</font></strong> 两根导线产生的相反方向的磁场，减少自身信号对环境的干扰</p></li></ul><p><strong><font color=#fea401>同轴电缆：</font></strong></p><p>同轴电缆的结构和屏蔽性使得它既有很高的带宽，又拥有很好的抗噪性，是有线电视和计算机城域网的常用传输介质 </p><p><img src="https://pic4.zhimg.com/v2-c029107f99f5b47aeee5d6cfc55691df_r.jpg" alt="同轴电缆"></p><ul><li><p>以高速在<font color=#FF6347>长距离</font>中传输</p></li><li><p><font color=#FF6347>高带宽</font>：超过GHz</p></li><li><p>卓越的抗干扰性能</p></li></ul><p><strong><font color=#fea401>电力线：</font></strong></p><ul><li><p>在家庭内部作为局域网，在家庭外部用于宽带互联网接入</p></li><li><p>设计用于分配电源信号</p></li></ul><p><strong><font color=#fea401>光纤：</font></strong></p><p><img src="https://www.vfe.ac.cn/Storage/uploads/201509/20150927154309_9165.jpg" alt="光纤"></p><h2 id="无线传输"><a href="#无线传输" class="headerlink" title="无线传输"></a>无线传输</h2><p><strong><font color=#fea401>电磁频谱：</font></strong></p><ul><li><p>频率越低，穿透力越强，越接近于无线电</p></li><li><p>频率越高，穿透力越弱，越接近于可见光</p></li></ul><p><img src="https://s1.ax1x.com/2023/03/04/ppAXbcT.png" alt="电磁频谱"></p><p><strong><font color=#fea401>无线电传输(VLF,LF,MF,HF)：</font></strong></p><ul><li><p><strong><font color=#ff8b61>无线电传输中带宽的两种使用方式：</font></strong></p><ul><li><p><strong><font color=#ff8aaf>使用窄带（电视，收音机）： </font></strong> 大多数传输使用较窄的频带来获得最好的接收</p></li><li><p><strong><font color=#ff8aaf>扩展频谱（蓝牙，无线局域网）：</font></strong></p><ul><li><p><font color=#DA70D6>FHSS跳频扩频：</font> 发送方和接收方使用一个伪随机数序列，随机同步地跳到其他频率</p></li><li><p><font color=#DA70D6>DSSS直接序列扩频： </font>将一个比特进行扩展</p></li><li><p><font color=#DA70D6>UWB超宽带通信： </font>发送一系列快速脉冲，这些脉冲随着通信信息而不断变化自己的位置，这种位置的快速变换导致信号被稀疏分布在一个很宽的频带上</p></li></ul></li></ul></li><li><p>在VLF、LF和MF波段，无线电波沿地球曲率（1000公里）移动</p></li><li><p>在HF波段，它们在100~500公里高度的电离层上反弹</p></li></ul><p><strong><font color=#fea401>微波通信：</font></strong></p><ul><li><p>微波传输几乎是一条直线，发射和接收天线必须精确对准</p></li><li><p>中继器每隔80km要接力一次（地球的曲率阻隔）</p></li><li><p>多径衰落通常是一个严重的问题（取决于天气和频率）</p></li></ul><p><strong><font color=#fea401>卫星通信：</font></strong> 实际上还是微波通信，卫星在天空中充当一个大的微波中继器</p><ul><li><p><strong><font color=#ff8b61>收发器</font></strong> </p><ul><li><p>只听某一个频率的数据</p></li><li><p>电磁波经过无线电传输，它与距离的平方成反比</p></li><li><p>放大输入信号</p></li><li><p>以另一个频率重新广播</p></li></ul></li></ul><h2 id="数字调制与多路复用"><a href="#数字调制与多路复用" class="headerlink" title="数字调制与多路复用"></a>数字调制与多路复用</h2><p><strong><font color=#fea401>基带传输：</font></strong> 信号的传输占有传输介质上从零到最大值之间的全部频率，而最大频率则取决于信令速率。这是有线介质普遍使用的一种调制方法</p><p><img src="https://s1.ax1x.com/2023/03/09/ppnYYX4.jpg" alt="基带传输"><br>曼彻斯特编码开销为100%</p><ul><li><p><strong><font color=#ff8b61>带宽利用率：</font></strong> </p><ul><li><p><strong><font color=#ff8aaf>比特率</font></strong> =波特率（每秒钟有多少个符号）*符号速率（每个符号携带多少个比特）</p></li><li><p>信号电平的数量不需要是2的n次方</p></li></ul></li><li><p><strong><font color=#ff8b61>时钟恢复：</font></strong> </p><ul><li><p><strong><font color=#ff8aaf>4B/5B编码方式：</font></strong> 绝对不会连续出现超过三个0，但损失了25%的代码</p><ul><li><font color=#DA70D6>11111：</font>空闲</li><li><font color=#DA70D6>11000：</font>代表一帧的开始</li></ul><p><img src="https://s1.ax1x.com/2023/03/08/ppeXApR.png" alt="4B/5B"></p></li></ul></li></ul><p><strong><font color=#fea401>通带传输：</font></strong> 调节载波的幅度，相位或者频率来表示一些比特。信号占据了以载波信号频率为中心的一段频带。这是无线和光纤信道最常使用的调制方法</p><p><img src="https://s1.ax1x.com/2023/03/08/ppejE5Q.png" alt="通带传输"></p><ul><li><p>(a) A binary signal（二进制信号）  </p></li><li><p>(b) Amplitude modulation（调幅）  </p></li><li><p>(c) Frequency modulation（调频）  </p></li><li><p>(d) Phase modulation（调相）  </p></li></ul><p><img src="https://s1.ax1x.com/2023/03/08/ppexXUU.jpg" alt="QPSK&amp;QAM"></p><ul><li><p><strong><font color=#ff8b61>频分复用：</font></strong> 将频谱分成几个频段，每个用户完全拥有其中的一个频段来发送自己的信号，多路信号共享高带宽介质</p><ul><li><p>给不同的逻辑信道(站)分配不同的频率，每个频率工作在频谱中的一部分，并且相邻信道之间的频谱间隔足够大，以便防止干扰</p></li><li><p><strong><font color=#ff8aaf>保护带：</font></strong> 比语音通信所需多出来的那部分频带</p></li></ul></li></ul><p><img src="https://s1.ax1x.com/2023/03/09/ppmq1R1.png" alt="频分复用"></p><ul><li><p><strong><font color=#ff8b61>时分复用：</font></strong> 用户以循环的方式轮流工作，每个用户周期性地获得整个带宽非常短的一个时间</p><p>  <img src="https://s1.ax1x.com/2023/03/09/ppmqYqO.jpg" alt="时分复用"></p><ul><li><p><strong><font color=#ff8aaf>同步的时间复用：</font></strong> 固定了时间位置，信道资源会浪费</p></li><li><p><strong><font color=#ff8aaf>异步的时间复用：</font></strong> 没有时间片的对应关系</p></li></ul></li><li><p><strong><font color=#ff8b61>码分复用：</font></strong> 扩频通信的一种方式，它把一个窄带信号扩展到一个很宽的频带上</p><ul><li><p><strong><font color=#ff8aaf>CDMA（Code Division Multiple Access）码分多址访问：</font></strong></p><ul><li><p>每一个比特的时间被拆分为m个更短的间隔，称为码片（m=128/64）  </p></li><li><p>每一个站点分配唯一一个m个比特的编码，称为码片序列，且两两正交</p><ul><li>任何两个站点之间一半相同，一半相反</li></ul></li><li><font color=#DA70D6>发送数据：</font><ul><li><p><font color=#63B8FF>发送比特1：</font>发送码片序列</p></li><li><p><font color=#63B8FF>发送比特0：</font>码片序列取反后发出去</p></li></ul></li></ul></li></ul></li></ul><p><img src="https://s1.ax1x.com/2023/03/09/ppmqUde.png" alt="码分复用"></p><p><strong>区别：</strong></p><p>基带传输：信号源产生的原始电信号称为基带信号，将数字数据0、1直接用两种不同的电压表示，然后送到线路上去传输。</p><p>通带传输：将基带信号进行调制后形成模拟信号，然后采用频分复用技术实现宽带传输。</p><h2 id="公共电话交换网络"><a href="#公共电话交换网络" class="headerlink" title="公共电话交换网络"></a>公共电话交换网络</h2><p>ADSL(Asymmetric Digital Subscriber Line)：ADSL技术是一种不对称数字用户线实现宽带接入互连网的技术，ADSL作为一种传输层的技术，充分利用现有的铜线资源，在一对双绞线上提供上行640kbps下行8Mbps的带宽，从而克服了传统用户在”最后一公里”的”瓶颈”，实现了真正意义上的宽带接入。ADSL是<font color=#FF6347>纯物理层协议</font></p><ul><li>ADSL用户线采用的传输介质是双绞线，通常是<font color=#FF6347>铜</font>质的</li><li>ADSL用户线使用了<font color=#FF6347>频分复用（FDM）技术和时分复用（TDM）</font>技术来实现信号的复用<ul><li>ADSL将铜线分成多个不同的频段，每个频段用于传输不同的数据类型（如语音、图像和互联网数据）。这个过程使用FDM技术实现</li><li>在每个频段内，ADSL使用TDM技术进行时分复用，以确保每个用户都能在同一频段内交替地发送和接收数据。这种方式使得ADSL能够同时处理多个连接，并提高网络资源利用率</li></ul></li></ul><p>Modem：执行数字比特流和模拟信号流（代表这些数字比特）之间转换的设备称为调制解调器（modem）,调制解调器是调制器（modulator）和解调器（demodulator）的缩写。ADSL属于<font color=#FF6347>通带传输</font>，需要<font color=#FF6347>调制</font>。</p><p><img src="https://s1.ax1x.com/2023/03/09/ppmqBRI.jpg" alt="公共电话交换网络"></p><p><strong><font color=#fea401>本地回路：</font></strong> 每个电话客户的电话机到电信局之间的双绞线</p><ul><li><p>电信局会去除高频成分</p></li><li><p><strong><font color=#ff8b61>传输线有三个主要问题：</font></strong> </p><ul><li><p><strong><font color=#ff8aaf>衰减：</font></strong> 衰减程度与频率有关 </p></li><li><p><strong><font color=#ff8aaf>延迟畸变：</font></strong> 频率不一样，传播速率也不一样，一个早到一个晚到会导致变形</p></li><li><p><strong><font color=#ff8aaf>噪音：</font></strong> </p><ul><li><p><font color=#DA70D6>热噪声</font>（沙沙声）</p></li><li><p><font color=#DA70D6>串音</font>（许多双绞线捆在一起，有电信号时会产生磁场，造成干扰）</p></li><li><p><font color=#DA70D6>脉冲噪音</font>（电流由小突然变大会产生电磁波，产生噪音）</p></li></ul></li></ul></li><li><p><strong><font color=#ff8b61>传输线有三个主要问题：使用DMT(Discrete MultiTone)的ADSL：</font></strong> </p><ul><li><p>本地回路上的1.1 MHz频谱被分成<font color=#FF6347>256</font>条独立的信道，每条信道宽4312.5 Hz</p></li><li><p>信道0用于简单老式电话服务，信道1〜5空闲，目的是防止语音信号与数据信号相互干扰。在剩下的250条信道中，一条用于上行流控制， 另一条用于下行流控制，其他<font color=#FF6347>248</font>条信道全部用于用户数据</p></li><li><p>在每条信道内使用了<font color=#FF6347>QAM</font>调制方案，波特率约为<font color=#FF6347>4000符号/秒</font></p><p><img src="https://s1.ax1x.com/2023/03/09/ppnM0bV.png" alt="使用DMT的ADSL"></p></li></ul></li><li><p>利用电话网来实现数据通信，要采取调制和解调的方法</p><ul><li><p><strong><font color=#ff8aaf>调制：</font></strong> 计算机的数字信号变成模拟信号，变成声音</p></li><li><p><strong><font color=#ff8aaf>解调：</font></strong> 再将声音信号还原为数字信号 </p></li></ul></li></ul><p><strong><font color=#fea401>中继：</font></strong> 连接交换局的数字光纤</p><ul><li><p><strong><font color=#ff8b61>问题：</font></strong> 光纤传播速度很快，但是光电转换的速度没有传播的速度快，因此一根光纤只能携带一小部分的数据</p></li><li><p><strong><font color=#ff8b61>解决方法：</font></strong> </p><ul><li><p><strong><font color=#ff8aaf>波分复用：</font></strong> 把多根光纤的数据搬迁到频谱上去，这样多根光纤可以合并成一路。传输到接收方后再用分波器分开</p></li><li><p><strong><font color=#ff8aaf>时分复用：</font></strong> 基于PCM（脉冲编码调制，Pulse Code Modulation）的TDM可在中继线上运送多路电话语音。话音信道的带宽为4000Hz，按照奈奎斯特定理，采样频率应该为带宽的两倍，即每秒采样8000次，因此PCM每125μs采样一次</p><ul><li><font color=#DA70D6>T1：</font>所有电话都是八千分之一秒采样一次，每次采样7个比特</li></ul><p><img src="https://s1.ax1x.com/2023/03/09/ppmq6L8.jpg" alt="T1"></p><p><img src="https://s1.ax1x.com/2023/03/09/ppmqoQ0.png" alt="T1"></p><ul><li><font color=#DA70D6>E1：</font>32个8比特信道，其中只有30路用于传输数据，剩下两路用于信令控制和同步</li></ul></li></ul></li></ul><p><strong><font color=#fea401>交换局：</font></strong> 使呼叫从一个中继转移到另一个中继</p><ul><li><p><strong><font color=#ff8b61>电路交换：</font></strong> 是一种<font color=#FF6347>面向连接</font>的通信方式。在电路交换中，通信双方在建立通信之前需要进行一次预处理，即<font color=#FF6347>建立一条专用的物理链路</font>来传输数据。这条链路在整个通信过程中都被保留，并且只能由两个通信方使用。当通信结束后，该链路会被释放。在电路交换中，数据通过这条链路进行传输，<font color=#FF6347>具有稳定性和可靠性，但是资源利用率较低</font>，因为这条链路在通信期间无法被其他用户使用</p></li><li><p><strong><font color=#ff8b61>分组交换：</font></strong> 是一种<font color=#FF6347>无连接</font>的通信方式。在分组交换中，数据被打包成一个个固定大小的数据块，即数据包（packet）。每个数据包都包含了目标地址、源地址和有效载荷等信息。在传输过程中，数据包会通过网络节点逐一转发，直到到达目标地址。在分组交换中，网络资源可以被多个用户共享，因此<font color=#FF6347>资源利用率比较高，但是传输的可靠性低于电路交换</font></p></li></ul><p><img src="https://s1.ax1x.com/2023/03/09/ppmq2dg.jpg" alt="交换"></p><p><img src="https://s1.ax1x.com/2023/03/09/ppnsym6.png" alt="电路交换和数据包交换网络的比较"><br>包交换不透明，因为需要对每一包的数据格式有所规定，要知道包长什么样；而电路交换是透明的</p><p>……未完待续♬</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%BA%8C%E7%</summary>
      
    
    
    
    <category term="专业课" scheme="https://jayerine.top/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="计网" scheme="https://jayerine.top/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
</feed>
