<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jay and Erine&#39;s Blog</title>
  
  
  <link href="https://jayerine.top/atom.xml" rel="self"/>
  
  <link href="https://jayerine.top/"/>
  <updated>2024-02-06T04:00:21.577Z</updated>
  <id>https://jayerine.top/</id>
  
  <author>
    <name>Jay and Erine</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试记录</title>
    <link href="https://jayerine.top/2024/02/06/137184bfb43a/"/>
    <id>https://jayerine.top/2024/02/06/137184bfb43a/</id>
    <published>2024-02-06T04:00:21.577Z</published>
    <updated>2024-02-06T04:00:21.577Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2023-11-10"><a href="#2023-11-10" class="headerlink" title="2023.11.10"></a>2023.11.10</h3><ul><li>单位：字节跳动</li><li>类型：开发<br>第一次面试，有很多可以改进的地方：</li><li>线上面试，最好使用电脑，因为可能需要做题。</li><li>项目经历没有准备充分。自我介绍和后续的提问会主要围绕项目展开。</li><li>考察了数据库的相关内容，问了数据隔离和建立索引，没有答上来</li><li>出了一个简单的编程题，括号匹配，使用oj作答。<br>总共面试了快一个小时，面试老师感觉比较有耐心，没想到会让现场答题。总体感觉不太好，应该是寄了。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;2023-11-10&quot;&gt;&lt;a href=&quot;#2023-11-10&quot; class=&quot;headerlink&quot; title=&quot;2023.11.10&quot;&gt;&lt;/a&gt;2023.11.10&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;单位：字节跳动&lt;/li&gt;
&lt;li&gt;类型：开发&lt;br&gt;第一次面试，</summary>
      
    
    
    
    <category term="简历" scheme="https://jayerine.top/categories/%E7%AE%80%E5%8E%86/"/>
    
    
  </entry>
  
  <entry>
    <title>git使用</title>
    <link href="https://jayerine.top/2024/02/06/bb4263303c4c/"/>
    <id>https://jayerine.top/2024/02/06/bb4263303c4c/</id>
    <published>2024-02-06T04:00:21.577Z</published>
    <updated>2024-02-06T04:00:21.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目分支情况"><a href="#项目分支情况" class="headerlink" title="项目分支情况"></a>项目分支情况</h2><ul><li>远程分支：目前只需要一个远程master分支就好，大家直接在上面开发提交。</li><li>本地分支，建议也是一个就够用了，绑定远程的master分支。如果想随便写东西实验，新建其他分支就好。</li></ul><h2 id="安装项目到本地"><a href="#安装项目到本地" class="headerlink" title="安装项目到本地"></a>安装项目到本地</h2><ol><li>在新建文件夹路径下创建git仓库：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li><li>添加远程仓库：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin https://gitee.com/lei-xilin/ScheduleManager.git</span><br></pre></td></tr></table></figure></li><li>下拉远程分支：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></li><li>本地master分支绑定远程master分支：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/master master</span><br></pre></td></tr></table></figure></li><li>测试：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure> 若出现“Already up to date.”说明成功。</li></ol><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h3 id="打开电脑，首先先拉取最新的代码："><a href="#打开电脑，首先先拉取最新的代码：" class="headerlink" title="打开电脑，首先先拉取最新的代码："></a>打开电脑，首先先拉取最新的代码：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h4 id="若出现冲突，则进行解决-解决完冲突之后，先提交，然后再次拉取代码，最后将解决完冲突的合并代码上传。"><a href="#若出现冲突，则进行解决-解决完冲突之后，先提交，然后再次拉取代码，最后将解决完冲突的合并代码上传。" class="headerlink" title="若出现冲突，则进行解决,解决完冲突之后，先提交，然后再次拉取代码，最后将解决完冲突的合并代码上传。"></a>若出现冲突，则进行解决,解决完冲突之后，先提交，然后再次拉取代码，最后将解决完冲突的合并代码上传。</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -a -m 解决冲突</span><br><span class="line">git pull</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h4 id="若无冲突，正常开始工作。"><a href="#若无冲突，正常开始工作。" class="headerlink" title="若无冲突，正常开始工作。"></a>若无冲突，正常开始工作。</h4><h3 id="工作完成，进行代码提交"><a href="#工作完成，进行代码提交" class="headerlink" title="工作完成，进行代码提交"></a>工作完成，进行代码提交</h3><p>若有新建文件需要上传，先添加该文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add &lt;新加入的文件&gt;</span><br></pre></td></tr></table></figure><p>之后进行本地提交：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -a -m 某工作完成</span><br></pre></td></tr></table></figure><p>最后提交到远程分支：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p>若出现冲突，则先pull，手动修改冲突，本地提交之后重新提交到远程分支。</p><h2 id="常用git命令"><a href="#常用git命令" class="headerlink" title="常用git命令"></a>常用git命令</h2><p>追踪所有文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add -A .</span><br></pre></td></tr></table></figure><p>合并分支：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge &lt;branch name&gt;</span><br></pre></td></tr></table></figure><p>强制覆盖本地分支：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull --allow-unrelated-histories</span><br></pre></td></tr></table></figure><p>抛弃所有未保存的修改，回到最近一次commit的状态：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure><p>本地回滚到某个commit，xxxxxx为commit编号：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard xxxxxx</span><br></pre></td></tr></table></figure><p>查看当前文件状态，文件状态常见的有untracked(未跟踪)，modified(已修改)，deleted(已删除)等：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>查看所有分支名称:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p>查看所有分支的绑定情况：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure><p>新建本地分支：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;name&gt;</span><br></pre></td></tr></table></figure><p>删除本地分支：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure><p>查看本地提交记录：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p>查看远程分支</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>移除远程分支</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote remove &lt;name&gt;</span><br></pre></td></tr></table></figure><h2 id="本地项目首次上传远程仓库"><a href="#本地项目首次上传远程仓库" class="headerlink" title="本地项目首次上传远程仓库"></a>本地项目首次上传远程仓库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> existing_git_repo</span><br><span class="line">git remote add origin https://gitee.com/lei-xilin/chat-gpt.git</span><br><span class="line">git push --set-upstream origin master</span><br></pre></td></tr></table></figure><p>将不想上传的文件加入.gitignore文件中。</p><p>查看追踪的文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git ls-tree -r master --name-only</span><br></pre></td></tr></table></figure><h2 id="设置-gitignore文件"><a href="#设置-gitignore文件" class="headerlink" title="设置.gitignore文件"></a>设置.gitignore文件</h2><p>对于一些本地化的配置，或者运行时生成文件，最好设置成.gitignore。<br>清除所有索引：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> -r --cached .</span><br></pre></td></tr></table></figure><p>修改.gitignore文件，重新提交，设置忽略文件完成。</p><h2 id="设置ssh协议提交"><a href="#设置ssh协议提交" class="headerlink" title="设置ssh协议提交"></a>设置ssh协议提交</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;comment&quot;</span></span><br></pre></td></tr></table></figure><p>查看ssh的公钥，提交到网站上</p><p>注意，添加远程仓库的时候，必须要添加ssh的链接</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;项目分支情况&quot;&gt;&lt;a href=&quot;#项目分支情况&quot; class=&quot;headerlink&quot; title=&quot;项目分支情况&quot;&gt;&lt;/a&gt;项目分支情况&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;远程分支：目前只需要一个远程master分支就好，大家直接在上面开发提交。&lt;/li&gt;
&lt;li&gt;本</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="git" scheme="https://jayerine.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>两棵树（可持久线段树+Hash+高精度数）</title>
    <link href="https://jayerine.top/2024/02/06/0e751f91670a/"/>
    <id>https://jayerine.top/2024/02/06/0e751f91670a/</id>
    <published>2024-02-06T04:00:21.577Z</published>
    <updated>2024-02-06T04:00:21.577Z</updated>
    
    <content type="html"><![CDATA[<p>​<a href="https://blog.csdn.net/m0_61322309/article/details/123586007?spm=1001.2014.3001.5502">csdn</a><br>Problem Description</p><p>给定两棵n个点的有根树，每棵 树的根节点都是1，点的编号为1到n。 定义d(x)为x在第一棵树上到1号点的最短路加上x在 第二棵树上到1号点的最短路，请将1到n按照d从小到 大排序。如果两个点的d相等，则编号小的排在前面。</p><p>Input</p><p>第一行一个正整数T(1 ≤ T ≤ 5)，表示测试数 据的数量。</p><p>每组数据第一行一个正整数n(2 ≤ n ≤ 100000)。 接下来n − 1行，第i行4个正整数a, x, b, y(1 ≤ a, b ≤ i, 1 ≤ x, y ≤ n)，表示i + 1号点在第一棵树上的父亲 是a，它到它父亲的距离为100000000x，i+1号点在第二 棵树上的父亲是b，它到它父亲的距离为100000000y。</p><p>Output</p><p>每组数据输出n行，第i行输出排序结果中 第i小的点的编号。</p><p>输入样例</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br><span class="line">1 2 1 3</span><br><span class="line">2 1 1 5</span><br><span class="line">1 2 3 1</span><br><span class="line">4 2 2 4</span><br></pre></td></tr></table></figure><p>输出样例</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>题意很简单，就是给定两棵有n个节点的树，以1作为树根，求某一个点在两棵树中到1号树根节点的距离之和，按照距离之和从小到大输出节点的编号。若不考虑数据范围，可以通过链式前向星建立两个有向图，从根节点两遍深度优先搜索记录每一个点到根节点的距离之和，然后利用sort函数排序输出。但是考虑到树的边权很大，都是100000000的x次方，无法用正常的变量存储距离的值。</p><p>于是使用高精度数处理。将每条边的值看作100000000进制下的数，则长为100000000的x次方的边可表示为100*****00（1后面x个零）。在一棵树中，一个点到树根的距离等于其父亲节点到树根的距离，加上该节点到其父亲节点的距离。由于这个高精度数距离很大，所以不会发生进位（发生进位需要加100000000次1，而数据范围最多到十万），从父亲节点到该节点，只是在某一位加上了1，由此可联想到可持久线段树的单点修改。</p><p>维护这样一个可持久线段树，线段树中的元素为高精度数的其中一位。每一个版本的线段树，表示一个n位的点到树根距离的高精度数。因为x,y范围小于十万，所以高精度数的位数不会超过十万，因此线段树中维护的元素不会超过十万。在网上查了下可持久线段树的内存，一般说开到三十二倍数据范围，但是这题其实开到lg100000&#x2F;lg2+1,差不多20倍就可以了，开到32倍100000kb都容易MLE。</p><p>解决了单棵树的建图和存储，接下来的问题是比较两棵树节点距离之和的大小关系。直接去从高到低一位一位相加再比较大小的话，每比较两个数，复杂度都是n，加上sort的复杂度，n^2lgn很明显会超时。这时候想到用字符串hash实现。由于不太会字符串hash，开始写WA了好多次，在大佬的帮助下才找到正确的hash算法。</p><p>在线段树二分结构和hash的帮助下，通过递归判断两棵树的子树hash值相加是否相等，可以在lgn的复杂度下判断高精度数的前n位是否相等，直到找到第n位不一样的位数值，判断大小即可。这个hash函数，首先要满足可加性，其次是冲突的概率要非常的小，以正确的去维护两棵树的和。最开始为了减小冲突，想到用普通的双hash，但是这样的话一来减小冲突的作用有限，二来要存两遍hash值很容易MLE。问大佬告诉使用字符串hash，先预处理生成一个用于取模的数的数组。这样能尽可能避免冲突。</p><p>下面是AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span><span class="comment">//getline的头文件，与string.h不同</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P1 233</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P 1000000007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> si maxn*20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> l[si][<span class="number">2</span>],r[si][<span class="number">2</span>],root[maxn][<span class="number">2</span>],tot[<span class="number">2</span>];</span><br><span class="line">ll ha[maxn],val[si][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> head[maxn][<span class="number">2</span>],ne[maxn&lt;&lt;<span class="number">1</span>],len[maxn&lt;&lt;<span class="number">1</span>],to[maxn&lt;&lt;<span class="number">1</span>],cnt;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hash1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ha[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;maxn;i++)&#123;</span><br><span class="line">        ha[i]=ha[i<span class="number">-1</span>]*<span class="number">10007</span>;</span><br><span class="line">        ha[i]%=P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> lenth,<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">    ne[cnt]=head[a][now];</span><br><span class="line">    len[cnt]=lenth;</span><br><span class="line">    to[cnt]=b;</span><br><span class="line">    head[a][now]=cnt;</span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">initia</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y=tot[now]++;</span><br><span class="line">    <span class="keyword">if</span>(left==right)<span class="keyword">return</span> y;</span><br><span class="line">    <span class="type">int</span> m=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    l[y][now]=<span class="built_in">initia</span>(left,m,now);</span><br><span class="line">    r[y][now]=<span class="built_in">initia</span>(m+<span class="number">1</span>,right,now);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hash</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num=R-(R+L)/<span class="number">2</span>;</span><br><span class="line">    val[y][now]=(val[l[y][now]][now]*ha[num]+val[r[y][now]][now])%P;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> od,<span class="type">int</span> num,<span class="type">int</span> lf,<span class="type">int</span> ri,<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y=tot[now]++;</span><br><span class="line">    <span class="keyword">if</span>(lf==ri)&#123;</span><br><span class="line">        val[y][now]=val[od][now]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m=(lf+ri)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=m)&#123;</span><br><span class="line">        l[y][now]=<span class="built_in">build</span>(l[od][now],num,lf,m,now);</span><br><span class="line">        r[y][now]=r[od][now];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        l[y][now]=l[od][now];</span><br><span class="line">        r[y][now]=<span class="built_in">build</span>(r[od][now],num,m+<span class="number">1</span>,ri,now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Hash</span>(y,lf,ri,now);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> lf=<span class="number">1</span>,ri=n,x1=root[a][<span class="number">0</span>],x2=root[a][<span class="number">1</span>],y1=root[b][<span class="number">0</span>],y2=root[b][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(lf!=ri)&#123;</span><br><span class="line">        <span class="type">int</span> m=(lf+ri)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="type">bool</span> an=(val[r[x1][<span class="number">0</span>]][<span class="number">0</span>]+val[r[x2][<span class="number">1</span>]][<span class="number">1</span>])%P==(val[r[y1][<span class="number">0</span>]][<span class="number">0</span>]+val[r[y2][<span class="number">1</span>]][<span class="number">1</span>])%P;<span class="comment">//一定要将hash值相加后取余数再判断是否相等！！！</span></span><br><span class="line">        <span class="keyword">if</span>(an)&#123;</span><br><span class="line">            ri=m;</span><br><span class="line">            x1=l[x1][<span class="number">0</span>];</span><br><span class="line">            x2=l[x2][<span class="number">1</span>];</span><br><span class="line">            y1=l[y1][<span class="number">0</span>];</span><br><span class="line">            y2=l[y2][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            lf=m+<span class="number">1</span>;</span><br><span class="line">            x1=r[x1][<span class="number">0</span>];</span><br><span class="line">            x2=r[x2][<span class="number">1</span>];</span><br><span class="line">            y1=r[y1][<span class="number">0</span>];</span><br><span class="line">            y2=r[y2][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((val[x1][<span class="number">0</span>]+val[x2][<span class="number">1</span>])%P==(val[y1][<span class="number">0</span>]+val[y2][<span class="number">1</span>])%P)<span class="keyword">return</span> a&lt;b;</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">return</span> val[x1][<span class="number">0</span>]+val[x2][<span class="number">1</span>]&lt;val[y1][<span class="number">0</span>]+val[y2][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> fa,<span class="type">int</span> lenth,<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">    root[node][now]=<span class="built_in">build</span>(root[fa][now],lenth,<span class="number">1</span>,n,now);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[node][now];~i;i=ne[i])<span class="built_in">dfs</span>(to[i],node,len[i],now);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T,a,x,b,y;</span><br><span class="line">    <span class="built_in">hash1</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;T;t++)&#123;</span><br><span class="line">        cnt=<span class="number">0</span>,tot[<span class="number">0</span>]=<span class="number">0</span>,tot[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(val,<span class="number">0</span>,<span class="built_in">sizeof</span>(val));</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;a,&amp;x,&amp;b,&amp;y);</span><br><span class="line">            <span class="built_in">add</span>(a,i,x,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">add</span>(b,i,y,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        root[<span class="number">0</span>][<span class="number">0</span>]=<span class="built_in">initia</span>(<span class="number">1</span>,n,<span class="number">0</span>);</span><br><span class="line">        root[<span class="number">0</span>][<span class="number">1</span>]=<span class="built_in">initia</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> ans[maxn];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)ans[i]=i;</span><br><span class="line">        <span class="built_in">sort</span>(ans+<span class="number">1</span>,ans+n+<span class="number">1</span>,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一步，输入，链式前向星分别对两棵树建立有向图</span></span><br><span class="line"><span class="comment">第二步，从一号节点开始，分别对两棵树进行深度搜索，并用可持久线段树记录相应节点到一号节点距离的高精度数</span></span><br><span class="line"><span class="comment">注意到对于树中的每个节点，其到一号点的距离等于他父亲节点的距离大小，在高精度进制下某一位加一，故可以用节点的编号作为可持久线段树的版本树根，对于每一个节点到一号点的距离，</span></span><br><span class="line"><span class="comment">可通过其父亲节点的对应版本的线段树进行单点修改</span></span><br><span class="line"><span class="comment">第三步，利用cmp函数排序，递归判断线段树左右子树的Hash值，若右子树的的hash相等，说明高位相等，递归搜索左子树，直到l==r，判断两树节点到一号点的距离和是否相等，</span></span><br><span class="line"><span class="comment">若相等，则按序号大小排序，否则按该位的大小排序</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​&lt;a href=&quot;https://blog.csdn.net/m0_61322309/article/details/123586007?spm=1001.2014.3001.5502&quot;&gt;csdn&lt;/a&gt;&lt;br&gt;Problem Description&lt;/p&gt;
&lt;p&gt;给定两</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="csdn" scheme="https://jayerine.top/tags/csdn/"/>
    
    <category term="ACM" scheme="https://jayerine.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>vscode配置opencv C++ 环境与人脸检测（不是人脸识别）算法的尝试</title>
    <link href="https://jayerine.top/2024/02/06/f554b43ffd79/"/>
    <id>https://jayerine.top/2024/02/06/f554b43ffd79/</id>
    <published>2024-02-06T04:00:21.577Z</published>
    <updated>2024-02-06T04:00:21.577Z</updated>
    
    <content type="html"><![CDATA[<p>​<a href="https://blog.csdn.net/m0_61322309/article/details/124214186?spm=1001.2014.3001.5501">csdn</a><br>估计这学期都去不了学校了，家里蹲大学马上要线上期中考。。。在家呆久了无聊想学点机器视觉的东西，之前在学校双创课上做过python的机器视觉实验，想起来挺有意思的，但是还是比较喜欢C++，就找到了这个看上去还不错的C++开源项目 ，opencv。</p><p>首先是配置opencv环境。看了很多教程，下面这个是最详细的，最后是参照上面这篇博客 成功完成了配置，感谢大佬。之前出现过很多奇怪的问题，也学到了一些经验，在这里记录一下。</p><p>1.MinGW的版本问题：之前是在电脑里装了MinGW环境的，所以直接按照教程安装了Cmake，结果configure的时候一直报错“MinGW缺少mingw-make.exe”，查找MinGW目录，明明有这个文件。后来发现MinGW不是最新版的，而且有博客提起过，只有seh版的MinGW才能Cmake中成功的configure。于是删了MinGW，重新安装了一下MinGW。而且发现由于奇怪的网络问题，MinGW不能在线安装了，于是下载安装压缩包安装上了版本正确的MinGW。好像这种python库或c++库的安装都很有时效性，各软件版本正确是很关键的。</p><p>2.Cmake的configure过程，要下载一些东西，有时候由于奇怪的问题下载不了，列表会变红，这时候可以通过科学上网，或者手动搜索下载无法下载的文件补上。新建一个文件夹作为“where to build the binaries”地址选项，不然后面会很乱。</p><p>3.由于之前配置过了vscode的各种json文件，就直接在上面改了，开始我只在IncludePath下添加了新的opencv的相关头文件路径，结果是编辑器检测没报错，按住ctrl键也可以打开查看源文件，但是一编译就报错无法打开头文件，查了好多资料才知道，c_cpp_properties.josn中添加的路径只是告诉编辑器的，让编辑器不打红色波浪线，但是此时编译器还不知道这个引用，要在tasks.json中添加相关的路径才会正常编译。并且了解到了.dll(用于动态链接库导出函数，在运行期间链接）.lib(用于动态链接库导出函数，在编译期间）和.a（静态库文件）的区别。以及“-I”（小写L） “-I”（大写i）命令，相当于添加动态程序库链接，静态文件库链接之类的。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;tasks&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">        <span class="string">&quot;label&quot;</span>: <span class="string">&quot;opencv&quot;</span>,</span><br><span class="line">        <span class="string">&quot;command&quot;</span>: <span class="string">&quot;D:/mingw64/bin/g++.exe&quot;</span>,</span><br><span class="line">        <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;-g&quot;</span>,</span><br><span class="line">            <span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-o&quot;</span>,</span><br><span class="line">            <span class="string">&quot;$&#123;workspaceFolder&#125;\\Debugger\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>,</span><br><span class="line">            <span class="string">&quot;D:/opencv/build/x64/mingw/bin/libopencv_world455.dll&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-I&quot;</span>,</span><br><span class="line">            <span class="string">&quot;D:/opencv/build/x64/mingw/install/include&quot;</span>,<span class="comment">//需要添加的路径</span></span><br><span class="line">            <span class="string">&quot;-I&quot;</span>,</span><br><span class="line">            <span class="string">&quot;D:/opencv/build/x64/mingw/install/include/opencv2&quot;</span>,<span class="comment">//需要添加的路径</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;options&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;D:/mingw64/bin&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;problemMatcher&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;group&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">            <span class="string">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>4.发现搞清楚这个问题之后，face.cpp头文件还是会报错，结果是最新版的opencv把这个头文件暂时下架了，原因是不稳定，要重新开发，网上教程说要在另一个库里opencv_contrib自行下载。。。这个源文件。</p><p>搞清楚了环境的安装配置之后，头文件终于不报错了，也可以正常编译了。马上按照网上的代码学习尝试了下opencv自带的人脸检测算法。在刚刚下载的opencv中，可以找到这些文件。</p><p> 据说这些文件是github大佬们将模型训练之后得到的数据样本库，通过调用一个opencv里的函数就可以利用这些模型的数据做相关的一些实验了。里面有各种各样的模型，有的是检测人脸的，有的是检测上半身的，有的是检测眼睛部位的。总之感觉都很神奇。</p><p>然后是学习代码时间，了解一下相关的工序，将图片灰度化，均衡化什么的，建立连级检测器，导入刚刚的分类器训练文件，熟悉下opencv的基本文件操作：</p><p>1-遍历文件夹内的文件，通过glode函数实现，大概就是读取指定文件夹下的路径保存在一个vector中；</p><p>2-imread()读取图片文件，namewindow()显示图片的窗体。imwrite()写入图片；</p><p>之后我利用下面的代码尝试了下，在一个文件夹下挑选出含有人脸的jpg或png格式的图片，看看效果。<br>​</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/objdetect.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line">CascadeClassifier face_cascade[<span class="number">4</span>];<span class="comment">//建立连级采样器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">detect</span><span class="params">( Mat frame ,<span class="type">int</span> i,cv::String name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat frame_gray;</span><br><span class="line">Mat converse;</span><br><span class="line">    <span class="built_in">cvtColor</span>( frame, frame_gray, COLOR_BGR2GRAY );<span class="comment">//颜色空间转换函数，将图像转化为灰度图像</span></span><br><span class="line">    <span class="built_in">equalizeHist</span>( frame_gray, frame_gray );<span class="comment">//直方图均衡化函数</span></span><br><span class="line">    std::vector&lt;Rect&gt; faces;<span class="comment">//RECT类用于描述矩形</span></span><br><span class="line"><span class="comment">//flip(frame_gray,converse,1);//反转图片,可用于侧脸检测</span></span><br><span class="line"><span class="type">bool</span> isfind=<span class="literal">false</span>;</span><br><span class="line">face_cascade[<span class="number">1</span>].<span class="built_in">detectMultiScale</span>(frame_gray, faces);<span class="comment">//用于检测的函数</span></span><br><span class="line"><span class="keyword">if</span>(faces.<span class="built_in">size</span>())&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;张图片中发现&quot;</span>&lt;&lt;faces.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;张脸&quot;</span>&lt;&lt;endl;</span><br><span class="line">string a;</span><br><span class="line"><span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">itoa</span>(i+<span class="number">1</span>,s,<span class="number">10</span>);</span><br><span class="line">a=s;</span><br><span class="line"><span class="built_in">imwrite</span>(<span class="string">&quot;C:/Users/notbadhhhh/Desktop/4\\&quot;</span>+a+<span class="string">&quot;.jpg&quot;</span>,frame);</span><br><span class="line">a=name;</span><br><span class="line"><span class="type">int</span> resort=<span class="built_in">remove</span>(a.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="comment">//namedWindow(&quot;w&quot;);</span></span><br><span class="line"><span class="comment">//imshow( &quot;w&quot;, frame );</span></span><br><span class="line"><span class="comment">//waitKey(3000);</span></span><br><span class="line"><span class="comment">//显示图片</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;张图片中未发现人脸&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pre_check</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!face_cascade[<span class="number">1</span>].<span class="built_in">load</span>(<span class="string">&quot;C:/Users/notbadhhhh/Desktop/haarcascade_frontalface_default.xml&quot;</span>)) <span class="comment">//opencv自带的人脸识别,需要下载</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--(!)Error loading face cascade\n&quot;</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(!face_cascade[<span class="number">2</span>].<span class="built_in">load</span>(<span class="string">&quot;C:/Users/notbadhhhh/Desktop/haarcascade_profileface.xml&quot;</span>)) <span class="comment">//opencv自带的人脸识别,需要下载</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--(!)Error loading face cascade\n&quot;</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(!face_cascade[<span class="number">3</span>].<span class="built_in">load</span>(<span class="string">&quot;C:/Users/notbadhhhh/Desktop/haarcascade_eye_tree_eyeglasses.xml&quot;</span>)) <span class="comment">//opencv自带的人脸识别,需要下载</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--(!)Error loading face cascade\n&quot;</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(!face_cascade[<span class="number">4</span>].<span class="built_in">load</span>(<span class="string">&quot;C:/Users/notbadhhhh/Desktop/haarcascade_eye.xml&quot;</span>)) <span class="comment">//opencv自带的人脸识别,需要下载</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;--(!)Error loading face cascade\n&quot;</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//可同时导入多个训练模型文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;chcp 65001&quot;</span>),<span class="built_in">system</span>(<span class="string">&quot;cls&quot;</span>);<span class="comment">//让编译器能输出中文</span></span><br><span class="line"><span class="type">bool</span> is=<span class="built_in">pre_check</span>();</span><br><span class="line">    <span class="keyword">if</span>(!is)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">string origin_deposite=<span class="string">&quot;C:/Users/notbadhhhh/Desktop/python1.4&quot;</span>;<span class="comment">//目标文件夹</span></span><br><span class="line">string pattern_jpg=origin_deposite+<span class="string">&quot;/*jpg&quot;</span>;</span><br><span class="line">string pattern_png=origin_deposite+<span class="string">&quot;/*png&quot;</span>;</span><br><span class="line">vector&lt;cv::String&gt; image_files_jpg,image_files_png;</span><br><span class="line"><span class="built_in">glob</span>(pattern_jpg,image_files_jpg);</span><br><span class="line"><span class="built_in">glob</span>(pattern_png,image_files_png);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;image_files_jpg.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">Mat pic=<span class="built_in">imread</span>(image_files_jpg[i]);</span><br><span class="line"><span class="keyword">if</span> (pic.<span class="built_in">empty</span>())cout &lt;&lt; <span class="string">&quot; wrong&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">bool</span> b=<span class="built_in">detect</span>(pic,i,image_files_jpg[i]);</span><br><span class="line"><span class="keyword">if</span>(b)sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//遍历文件夹下的jpg图片</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;image_files_png.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">Mat pic=<span class="built_in">imread</span>(image_files_png[i]);</span><br><span class="line"><span class="keyword">if</span> (pic.<span class="built_in">empty</span>())cout &lt;&lt; <span class="string">&quot; wrong&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">bool</span> b=<span class="built_in">detect</span>(pic,i,image_files_png[i]);</span><br><span class="line"><span class="keyword">if</span>(b)sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//遍历文件夹下的png图片</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;一共筛选出了&quot;</span>&lt;&lt;sum&lt;&lt;<span class="string">&quot;张含有人脸的照片&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反复测试了多个训练器模型文件后，发现这些模型的识别准确率远低于我的预期，误检率和漏检率都非常的高。。。反复调试了detectMultiScale的七个参数，发现正确率始终不是很高。用三十张含有人脸的照片，最好的一次检出了二十一张含有人脸，也就是70%左右。不知道是我的参数没设置合适还是其他什么原因，正确率基本上不超过70%。检测人眼的，和检测上半身的正确率更离谱。。。上网也没查到什么资料（一查人脸检测的讨论，出来的都是人脸识别）。而且检测很耗时，基本上一张图片要几秒钟。</p><p>虽然这不是最好的人脸检测算法，但是也不至于这么低吧，我以为至少有百分之九十以上准确率。结果比较失望。了解到还有一些其他的比较优秀的人脸检测算法，但是限于缺少获取途径和能力（好像他们不是开源的），无法再简单的实践体验了。</p><p>想问问有大佬知道这个算法的最优正确率有多高吗？或者怎么改进提高检测正确率？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​&lt;a href=&quot;https://blog.csdn.net/m0_61322309/article/details/124214186?spm=1001.2014.3001.5501&quot;&gt;csdn&lt;/a&gt;&lt;br&gt;估计这学期都去不了学校了，家里蹲大学马上要线上期中考。。。在</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="csdn" scheme="https://jayerine.top/tags/csdn/"/>
    
    <category term="机器学习" scheme="https://jayerine.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>创新课程</title>
    <link href="https://jayerine.top/2024/02/06/19d418e9f6fa/"/>
    <id>https://jayerine.top/2024/02/06/19d418e9f6fa/</id>
    <published>2024-02-06T04:00:21.577Z</published>
    <updated>2024-02-06T04:00:21.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TRIZ"><a href="#TRIZ" class="headerlink" title="TRIZ"></a>TRIZ</h2><ul><li>创始人：阿奇舒勒</li><li>40种原理</li><li>发明家式的解决任务理论</li></ul><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul><li>解决技术问题</li><li>预测未来难题</li></ul><h3 id="如何解决一个问题？"><a href="#如何解决一个问题？" class="headerlink" title="如何解决一个问题？"></a>如何解决一个问题？</h3><ul><li>传统解决方案：</li></ul><ol><li>灵光乍现</li><li>试错</li></ol><ul><li>TRIZ：<br>  例如：组合原理<ol><li>空间、时间上将各种功能整合</li><li>将相同或相反的功能整合</li></ol></li><li>技术矛盾<br>“又要马儿跑，又要马儿不吃草。”————了解改善参数、恶化参数，通过统计学方法查表分析。</li><li>技术进化趋势：</li></ul><ol><li>产品发展有固定规律吗？<br> 由功能简单，到功能复杂，再由结构复杂，到结构尽量简单。</li><li>产品生命周期不同阶段研发侧重点：<br>功能实现-&gt;功能实现最大化-&gt;性能最大化-&gt;效率最大化-&gt;可靠性最大化-&gt;成本最小化</li><li>常见发展规律<ul><li>由静态变为动态</li><li>由单体变为系统</li><li>空间分割趋势</li><li>物体分割趋势</li><li>可控度增加（手动向自动发展）</li><li>引入物质的趋势</li><li>表面分割的趋势</li><li>维度的上升</li><li>表面曲面化趋势</li><li>增加裁剪度</li></ul></li></ol><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>栈帧（stack frame）和堆：</p><ul><li>一个线程一个栈</li><li>堆是程序运行时动态分配的空间<br>栈里的空间随着程序弹栈自动释放，JVM负责堆的空间管理。</li></ul><p>同一个对象，释放了两次，则会产生NullPointerException（野指针），这是所有语言需要面对的问题。go语言和Java类似，使用GC自动维护内存空间。在不同线程中，都存在并发问题，同时访问一个内存空间。</p><p>语言的发展历史：</p><ul><li>C&#x2F;C++：手工管理内存（malloc free &#x2F; new delete），容易产生内存泄漏，可以通过重启电脑解决，容易产生释放多次，产生非常难调试的bug，导致运行效率高，但是开发效率低。</li><li>python java go: 自带GC机制，方便内存管理。只需要分配内存，垃圾回收器负责回收。但是Java没有解决空指针的问题。执行效率相对比较低。</li><li>rust：严格的内存安全，兼顾运行效率。</li></ul><p>Garbage如何确定？  </p><ul><li>引用指向法（reference count）：python使用，在每个引用下计数，当计数为0时标记为垃圾。存在问题，当循环引用时，出现一堆垃圾。</li><li>根可达算法（root searching）：从根开始遍历，如果没有遍历到，则为垃圾。根包括一些栈，静态池等。</li></ul><p>GC算法</p><ul><li>Mark-Sweep 标记清除<br>容易导致内存碎片化</li><li>Copying 拷贝<br>边找边复制，但是浪费内存</li><li>Mark-Compact 标记压缩<br>在回收的过程中整理，但是效率低</li></ul><p>三种算法的综合运用，诞生了各种各样的垃圾回收器。</p><p>GC的演化过程（随着内存大小的不断增大而演进）</p><ul><li><p>分带算法：分为新生带和老年代<br>新生带使用拷贝算法，会回收90%的对象。<br>eden(8)—survivor(1)—survivor(1)—tenured(30)</p></li><li><p>内存几兆-几十兆时，使用Serial，单线程时间停止复制回收。</p></li><li><p>内存几十兆-上百兆1G时，parallel并行多线程</p></li><li><p>内存几十G时，线程过多，线程上下文切换需要巨大的资源，concurrent GC，此时业务线程和GC线程并发。</p></li></ul><p>通常情况，Java 1.8版本使用ps+po。ParNew 工作在年轻带的多线程。</p><p>CMS concurrent mark sweep：<br>初始标记（stw标记root）-&gt;并发标记-&gt;重新标记（stw三色标记算法）-&gt;并发清理</p><h2 id="自主研修学习心得"><a href="#自主研修学习心得" class="headerlink" title="自主研修学习心得"></a>自主研修学习心得</h2><h3 id="自主研修课一：创新创业类教育"><a href="#自主研修课一：创新创业类教育" class="headerlink" title="自主研修课一：创新创业类教育"></a>自主研修课一：创新创业类教育</h3><ol><li>学习内容：<br>  Triz理论的发展历史、Triz理论的用途，产品的创新过程，人类社会发展中，科学技术进步的规律，如以下常见的产品技术发展规律：</li></ol><ul><li>由静态变为动态</li><li>由单体变为系统</li><li>空间分割趋势</li><li>物体分割趋势</li><li>可控度增加（手动向自动发展）</li><li>引入物质的趋势</li><li>表面分割的趋势</li><li>维度的上升</li><li>表面曲面化趋势</li><li>增加裁剪度</li></ul><ol start="2"><li>学习收获：<br>以前在思考创新点的时候，缺少系统的训练和方法，导致经常缺乏灵感。通过学习Triz理论，我学习到了如何利用这些方法和规律，进行思考和创新。</li></ol><h3 id="自主研修课二：系统地学习一门软件或硬件开发"><a href="#自主研修课二：系统地学习一门软件或硬件开发" class="headerlink" title="自主研修课二：系统地学习一门软件或硬件开发"></a>自主研修课二：系统地学习一门软件或硬件开发</h3><ol><li>学习内容：<br>android应用程序的开发，包括android studio软件的使用，android虚拟机和真机的编程调试，android系统的内存交互。Java语言语法，包括面向对象编程的各种技术，多线程技术，lambda表达式。学习了android底层DVM的工作机制和kotlin语言的编译运行原理，了解了Java语言中的JVM，JDK，JRE，深入学习了JVM中的内存管理机制GC中的CMS垃圾回收算法。</li><li>学习收获：<br>对于android应用程序的开发，更加熟悉了，同时借助android开发的实践，学习了解了Java语言的语法知识，并且深入学习了Java虚拟机的原理，对于以后的移动应用开发打下了基础。</li></ol><h3 id="自主研修课三：人工智能类"><a href="#自主研修课三：人工智能类" class="headerlink" title="自主研修课三：人工智能类"></a>自主研修课三：人工智能类</h3><ol><li>学习内容：<br>吴恩达机器学习，基础机器学习算法，包括线性回归，最小梯度法，K-Means，支持向量机等算法。<br>数据结构的相关算法，如Splay算法，二分答案、贪心搜索、模拟、压状dp、平衡树算法、查并集、欧拉线性筛、图论、拓扑排序、数论基础（费马小定理、逆元运算、欧拉线性筛）、快速幂等。</li><li>学习收获：<br>通过学习和实践各种算法，打牢算法和数学基础，为将来学习和使用更高级的算法做铺垫。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TRIZ&quot;&gt;&lt;a href=&quot;#TRIZ&quot; class=&quot;headerlink&quot; title=&quot;TRIZ&quot;&gt;&lt;/a&gt;TRIZ&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;创始人：阿奇舒勒&lt;/li&gt;
&lt;li&gt;40种原理&lt;/li&gt;
&lt;li&gt;发明家式的解决任务理论&lt;/li&gt;
&lt;/ul&gt;
</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://jayerine.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>奇怪名词解释</title>
    <link href="https://jayerine.top/2024/02/06/feae35703595/"/>
    <id>https://jayerine.top/2024/02/06/feae35703595/</id>
    <published>2024-02-06T04:00:21.577Z</published>
    <updated>2024-02-06T04:00:21.577Z</updated>
    
    <content type="html"><![CDATA[<p>PowerPC（Power Processor Architecture）是一种基于精简指令集计算机（RISC）架构的中央处理器（CPU）系列，最早由IBM、苹果公司和摩托罗拉共同开发。PowerPC CPU被广泛应用于高性能计算机、嵌入式系统、网络设备以及游戏机等领域。</p><p>DSP（Digital Signal Processor）是数字信号处理器的缩写。它是专门为数字信号处理而设计的微处理器，通常具有更快的时钟速度和更高的运算能力，适用于音频、视频、语音、图像等实时信号的处理和分析。DSP广泛应用于通信、音频、视频、雷达、医疗等领域。</p><p>SRIO（Serial RapidIO）是一种串行高速总线标准，旨在提供高速数据传输和低延迟的通信解决方案。SRIO被设计用于高性能计算、数据中心、网络设备、电信设备等领域，可以连接多个处理器、DSP、FPGA等芯片以及外围设备。</p><p>SRIO总线具有以下特点：</p><ol><li>高速传输：SRIO的速度可达到5Gbps或更高，可满足高带宽应用的需求。</li><li>低延迟：SRIO采用专门的协议和硬件架构，降低了数据传输的延迟，适用于实时应用。</li><li>可靠性：SRIO具有较强的错误检测和纠正能力，保证了数据传输的可靠性。</li><li>扩展性：SRIO支持多主机和多处理器连接，可扩展性极强。</li><li>灵活性：SRIO支持多种拓扑结构和数据传输模式，适应不同应用场景的需求。</li></ol><p>SLAM（Simultaneous Localization and Mapping）算法是指同时实现机器人的自主定位和地图构建的一类算法。在SLAM算法中，机器人通过搭载传感器（如激光雷达、相机等）进行环境探测，从而实现对机器人周围环境的感知和地图构建；同时，机器人通过自身的运动信息和传感器数据进行定位，实现自主导航。</p><p>SLAM算法通常涉及到对机器人的传感器数据进行处理和分析，包括特征提取、匹配、滤波、优化等步骤。根据不同的应用场景和环境，SLAM算法可以采用不同的方法和技术，例如基于滤波的方法、基于优化的方法、基于深度学习的方法等。</p><p>SLAM算法被广泛应用于无人车、无人机、服务机器人以及工业自动化等领域，为机器人实现自主感知和导航提供了重要的技术支持。</p><p>Redis是一种内存数据结构存储系统，它可以用作数据库、缓存和消息队列。Redis支持多种数据结构，包括字符串、哈希表、列表、集合等。与传统的关系型数据库不同，Redis将所有数据保存在内存中，因此访问速度非常快。此外，Redis还提供了一些高级功能，如发布&#x2F;订阅、事务处理、Lua脚本等。Redis的主要优点是快速、灵活、可扩展，并且具有广泛的应用场景，如Web应用程序、游戏、移动应用程序等。</p><p>Flask是一个轻量级的Web应用框架，它基于Python语言编写而成。Flask旨在提供一种简单易用、灵活性高、扩展能力强的开发方式，适用于快速搭建小型Web应用程序。</p><p>Flask具有以下特点：</p><ol><li>简单易用：Flask采用简洁的结构设计，易于理解和上手。</li><li>轻量级：Flask核心代码库非常小，运行起来非常快。</li><li>扩展性强：Flask提供了丰富的插件和扩展库，可以方便地实现各种功能。</li><li>模板引擎：Flask内置了Jinja2模板引擎，可以灵活地构建Web界面。</li><li>松耦合：Flask框架没有强制的目录结构和组织方式，可以根据需求自由定制。</li></ol><p>Flask可以用于构建各种类型的Web应用程序，包括博客、社交网络、电子商务等。同时，Flask也可以和其他Python库和框架配合使用，如NumPy、Pandas、Django等，满足更加复杂的需求。</p><p>AWS是Amazon Web Services的缩写，是亚马逊公司提供的一整套云计算服务。AWS提供了各种基础设施和应用程序服务，涵盖了计算、存储、数据库、网络、分析、人工智能、开发工具等多个领域。</p><p>AWS的主要产品和服务包括：</p><ol><li>EC2：弹性云服务器，可以在几分钟内启动虚拟机实例。</li><li>S3：简单存储服务，可提供安全、高扩展性的对象存储服务。</li><li>RDS：关系型数据库服务，支持多种数据库引擎，如MySQL、PostgreSQL、Oracle等。</li><li>Lambda：事件驱动计算平台，可运行代码片段并按使用时间计费。</li><li>Elastic Beanstalk：自动化部署和管理平台，可快速部署Web应用程序。</li><li>CloudFront：全球内容分发网络，可将静态和动态内容快速分发到全球各地。</li><li>DynamoDB：NoSQL数据库服务，可处理大量非结构化数据。</li><li>Glacier：低成本的云归档存储服务，支持长期数据存储和备份。</li></ol><p>AWS的优点包括可靠性高、安全性好、灵活性强、可扩展性高，并且具有广泛的应用场景。AWS已经成为当今最为流行的云计算服务提供商之一。</p><p>RESTful（Representational State Transfer）是一种基于Web的架构风格，用于设计分布式系统。它是一组约束和属性的集合，可以使应用程序更加简单、可扩展和易于维护。</p><p>RESTful架构风格的核心概念包括：</p><ol><li>资源：系统中任何可以被访问的信息都被视为资源，每个资源都有唯一的标识符。</li><li>表述：资源的状态可以通过表述来传输，例如JSON、XML等格式。</li><li>状态转移：客户端通过HTTP协议对资源进行操作，包括GET、POST、PUT、DELETE等方法。</li><li>无状态：RESTful服务不维护客户端状态，每个请求都包含了足够的信息，服务器可以独立处理。</li></ol><p>RESTful设计规范通常遵循以下几个原则：</p><ol><li>URI表示资源：URI是资源的唯一标识符，每个资源都应该有一个固定的URI。</li><li>HTTP动词操作资源：HTTP动词表示对资源进行的操作，如GET表示读取资源，POST表示创建资源，PUT表示更新资源，DELETE表示删除资源等。</li><li>返回资源的表述：响应应该返回资源的表述，例如JSON或XML格式的数据。</li><li>超媒体驱动：超媒体链接可以提供应用程序自我描述的能力。</li></ol><p>RESTful架构在Web开发中被广泛使用，尤其适用于移动应用程序、API服务等分布式系统。它可以简化系统架构，提高系统的灵活性和可扩展性。</p><p>Docker是一种开源的容器化平台，用于构建、部署和运行应用程序。它基于Linux操作系统中的容器技术，可以将应用程序及其依赖项封装在一个可移植的容器中，并提供了标准化的接口和工具集，使得应用程序的部署和管理变得更加简单、灵活和可靠。</p><p>Docker的核心组件包括：</p><ol><li>Docker引擎：Docker的主要组件，负责管理容器的生命周期。</li><li>Docker镜像：容器运行的时候需要的文件系统和参数的集合。</li><li>Docker容器：Docker中的运行实例，包含了应用程序和其所有的依赖项。</li><li>Docker仓库：用于存储和分享Docker镜像的集合。</li></ol><p>Docker的主要优点包括：</p><ol><li>快速、高效：Docker利用容器技术，可以快速地创建、启动和停止容器，提高开发和部署效率。</li><li>简单、易用：Docker提供了简单易用的命令行工具，使得容器的管理和部署变得非常方便。</li><li>可移植、可扩展：Docker的容器可以在不同的环境中运行，具有很好的可移植性和可扩展性。</li><li>安全、隔离：Docker利用容器技术实现应用程序之间的隔离，保证了系统的安全性。</li><li>生态丰富：Docker拥有一个庞大的生态系统，提供了大量的工具和插件，满足了不同场景下的需求。</li></ol><p>Docker在云计算、DevOps等领域得到了广泛的应用，成为了一种重要的容器化平台。</p><p>Spark、Kafka和Presto都是大数据处理领域的重要工具和技术。</p><ol><li><p>Spark：Spark是一个快速的、可扩展的、通用的大数据处理框架，支持多种数据处理场景，如批处理、流处理、机器学习等。Spark采用内存计算技术，可以提高数据处理速度，同时也支持多种编程语言和数据源。</p></li><li><p>Kafka：Kafka是一种分布式消息队列系统，主要用于高吞吐量的数据流处理。它支持消息的发布和订阅机制，支持多种数据源和数据消费端，同时还提供了容错性和可伸缩性。</p></li><li><p>Presto：Presto是一种分布式SQL查询引擎，可以快速地查询大规模的数据集。它支持多种数据源，如Hadoop、Cassandra、MySQL等，并且具有高性能和易用性。</p></li></ol><p>这三个工具在大数据处理中经常被同时使用。例如，可以使用Kafka作为数据输入源，将数据流传输到Spark中进行实时处理，然后使用Presto对结果进行查询。这样的组合可以提供灵活、高效、可靠的数据处理解决方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PowerPC（Power Processor Architecture）是一种基于精简指令集计算机（RISC）架构的中央处理器（CPU）系列，最早由IBM、苹果公司和摩托罗拉共同开发。PowerPC CPU被广泛应用于高性能计算机、嵌入式系统、网络设备以及游戏机等领域。&lt;</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://jayerine.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>工具使用</title>
    <link href="https://jayerine.top/2024/02/06/16139088fdfb/"/>
    <id>https://jayerine.top/2024/02/06/16139088fdfb/</id>
    <published>2024-02-06T04:00:21.577Z</published>
    <updated>2024-02-06T04:00:21.577Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些好用的工具</p><p>voicemeeter banana：可以输出声音到多个耳机</p><p>ffmpeg——音频处理开源工具，可以进行音频格式转换：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i 白日梦想家.rmvb -c:v libx264 -strict -2 白日梦想家.mp4</span><br></pre></td></tr></table></figure><p>runfuns：iso系统镜像制作软件，制作好的U盘镜像可以安装系统</p><p>Termus：可以通过手机使用ssh</p><p>TTS-coqui-ai开源项目，可以很方便的使用命令行或Python实现文字语音合成。若模型下载太慢，可以到huggingface网站或者其他镜像站下载模型，再手动拷贝到本地的cache目录中。使用的时候需要注意，中文一定要用句号结尾，否则会产生杂音。</p><p>stability-ai的开源diffusion模型，可以实现本地部署AI绘画。</p><p>chatglm6B，可以实现本地部署的LLM大模型，效果还不错。</p><p>rocm可能可以让amd的显卡使用pytorch进行机器学习。经过一天的研究发现，rocm的不同版本（5.0-5.71）之间非常不一样，一定要注意适配的相应pytorch版本。而且较新版本的rocm支持不了比较老的显卡，如RX580，据说5.30版本可以使用，但是到了5.70版本后，虽然可以配置rocm环境，但是经过简单测试可以发现，无法进行任何cuda计算，只要使用cuda计算，程序就会毫无征兆的挂掉内核。机器学习可能还是N卡比较好。</p><p>smab协议可以让局域网电脑之间相互共享文件，类似于ftp。需要注意的是，smab协议有3个版本，其中android系统常使用1.0版本，若需要电脑和手机文件共享，需要电脑端降低设置到1.0版本。</p><p>jupyter可以实现浏览器登录服务器，使用服务器的计算资源跑程序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一些好用的工具&lt;/p&gt;
&lt;p&gt;voicemeeter banana：可以输出声音到多个耳机&lt;/p&gt;
&lt;p&gt;ffmpeg——音频处理开源工具，可以进行音频格式转换：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://jayerine.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习</title>
    <link href="https://jayerine.top/2024/02/06/602d3832692a/"/>
    <id>https://jayerine.top/2024/02/06/602d3832692a/</id>
    <published>2024-02-06T04:00:21.577Z</published>
    <updated>2024-02-06T04:00:21.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means"></a><a href="https://zhuanlan.zhihu.com/p/184686598">K-Means</a></h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">方以类聚，物以群分。</span><br><span class="line">                    ——《易经》</span><br></pre></td></tr></table></figure><p>聚类算法KMeans是无监督学习的杰出代表之一，K-Means可以做为其他聚类算法的基础。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>通过迭代寻找K个簇（Cluster）的一种划分方案，使得聚类结果对应的损失函数最小。其中，损失函数可以定义为各个样本距离所属簇中心点的误差平方和：</p><p>$$J(c, \mu)&#x3D;\sum_{i&#x3D;1}^{M}{||x_{i}-\mu_{c_{i}}||^{2}}$$</p><p>其中 $x_{i}$ 代表第 $i$ 个样本， $c_{i}$ 是 $x_{i}$ 所属的簇， $\mu_{c_{i}}$ 代表簇对应的中心点， $M$ 是样本总数。</p><h3 id="主要过程"><a href="#主要过程" class="headerlink" title="主要过程"></a>主要过程</h3><ol><li>选定初始簇中心</li><li>更新簇中心位置</li><li>更新分类归属</li><li>重复2、3步到簇中心不在变化</li></ol><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>KMeans的核心目标是将给定的数据集划分成K个簇（K是超参），并给出每个样本数据对应的中心点。具体步骤非常简单，可以分为4步：</p><p>（1）数据预处理。主要是标准化、异常点过滤。</p><p>（2）随机选取K个中心，记为 $\mu_{1}^{(0)},\mu_{2}^{(0)},…,\mu_{k}^{(0)}$</p><p>（3）定义损失函数： $J(c, \mu)&#x3D;min\sum_{i&#x3D;1}^{M}{||x_{i}-\mu_{c_{i}}||^{2}}$</p><p>（4）令$t&#x3D;0,1,2,…$ 为迭代步数，重复如下过程直到 J 收敛：</p><ul><li>对于每一个样本 $x_{i}$ ，将其分配到距离最近的中心</li></ul><p>$$c_{i}^{t} &lt;—argmin_{k}{||x_{i}-\mu_{k}^{t}||^{2}}$$</p><ul><li>对于每一个类中心k，重新计算该类的中心</li></ul><p>$$\mu_{k}^{(t+1)} &lt;—argmin_{\mu}\sum_{i:c_{i}^{t}&#x3D;k}^{b}{||x_{i}-\mu||^{2}}$$</p><p>KMeans最核心的部分就是先固定中心点，调整每个样本所属的类别来减少 J ；再固定每个样本的类别，调整中心点继续减小J 。两个过程交替循环， J 单调递减直到最（极）小值，中心点和样本划分的类别同时收敛。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>KMenas的优点：</p><ul><li>高效可伸缩，计算复杂度 为O(NKt)接近于线性（N是数据量，K是聚类总数，t是迭代轮数）。</li><li>收敛速度快，原理相对通俗易懂，可解释性强。</li></ul><p>KMeans也有一些明显的缺点：</p><ul><li>受初始值和异常点影响，聚类结果可能不是全局最优而是局部最优。</li><li>K是超参数，一般需要按经验选择。</li><li>样本点只能划分到单一的类中。</li><li>不适合圆形数据集的分类（非凸数据集）。</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>图像压缩：图像矢量量化。</p><blockquote><p>对颜色进行聚类，若原图256*256，每个像素用24个比特的RGB表示。若经过聚类颜色之后剩下64种颜色，只用6比特表示颜色，压缩率为$\frac{6}{24}\times 100%$。</p></blockquote><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol><li><p>数据预处理：归一化和异常点过滤</p><p> KMeans本质上是一种基于欧式距离度量的数据划分方法，均值和方差大的维度将对数据的聚类结果产生决定性影响。所以在聚类前对数据（具体的说是每一个维度的特征）做归一化和单位统一至关重要。此外，异常值会对均值计算产生较大影响，导致中心偏移，这些噪声点最好能提前过滤。</p></li><li><p>合理选择K值</p><p> K值的选择一般基于实验和多次实验结果。例如采用手肘法，尝试不同K值并将对应的损失函数画成折线。手肘法认为图上的拐点就是K的最佳值。</p><p> 为了将找寻最佳K值的过程自动化，研究人员提出了Gap Statistic方法。它的有点是我们不再需要肉眼判断，只需要找到最大的Gap Statistic对应的K即可。</p><p> 沿用第一节中损失函数记为 $D_{k}$ ，当分为K类时，Gap Statistic定义为： $Gap(k)&#x3D;E(logD_{k})-logD_{k}$ 。 $E(logD_{k})$ 是 $logD_{k}$ 的期望，一般由蒙特卡洛模拟产生。我们在样本所在的区域内按照均匀分布随机地产生和原始样本数一样多的随机样本，并对这个随机样本做KMeans，得到一个 $D_{k}$ ，重复多次就可以计算出 $E(logD_{k})$ 的近似值。</p><p> $Gap(K)$ 的物理含义是随机样本的损失与实际样本的损失之差。$Gap$越大说明聚类的效果越好。一种极端情况是，随着K的变化 $Gap(K)$ 几乎维持一条直线保持不变。说明这些样本间没有明显的类别关系，数据分布几乎和均匀分布一致，近似随机。此时做聚类没有意义。</p></li><li><p>改进初始值的选择</p><p> 之前我们采取随机选择K个中心的做法，可能导致不同的中心点距离很近，就需要更多的迭代次数才能收敛。如果在选择初始中心点时能让不同的中心尽可能远离，效果往往更好。这类算法中，以K-Means++算法最具影响力。</p></li><li><p>采用核函数</p><p> 主要思想是通过一个非线性映射，将输入空间中的数据点映射到高位的特征空间中，并在新的空间进行聚类。非线性映射增加了数据点线性可分的概率（与SVM中使用核函数思想类似）对于非凸的数据分布可以达到更为准确的聚类结果。</p></li></ol><h2 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a><a href="https://zhuanlan.zhihu.com/p/31886934">SVM</a></h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>支持向量机（support vector machines, SVM）是一种二分类模型，它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机；SVM还包括核技巧，这使它成为实质上的非线性分类器。SVM的的学习策略就是间隔最大化，可形式化为一个求解凸二次规划的问题，也等价于正则化的合页损失函数的最小化问题。SVM的的学习算法就是求解凸二次规划的最优化算法。属于有监督学习。</p><p>研究对线性二分类问题的凸优化问题的表示，以及支持向量机的求解。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>SVM学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。如下图所示， $\boldsymbol{w}\cdot x+b&#x3D;0$ 即为分离超平面，对于线性可分的数据集来说，这样的超平面有无穷多个（即感知机），但是几何间隔最大的分离超平面却是唯一的。<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.jpg" alt="二分类划分"><br>$$w&#x3D;[w1,w2]\quad x&#x3D;[x,y]^T$$<br>点到超平面的距离是<br>$$d&#x3D;\frac{|xX_0+b|}{||w||}$$<br>若$X_0$为支持向量，<br>$$d&#x3D;\frac{1}{||w||}$$</p><p>用a缩放w和b，$(w,b)\rightarrow(aw,ab)$</p><p>当$|wx_0+b|&#x3D;1$，$x_0$是支持向量。</p><p>当$|wx_0+b|&gt;1$，$x_0$非支持向量。</p><h3 id="支持向量机的求解"><a href="#支持向量机的求解" class="headerlink" title="支持向量机的求解"></a>支持向量机的求解</h3><p>支持向量机求解是一个凸问题，存在唯一一个全局极值。</p><p>凸问题总能找到高效快速的算法来解决。</p><ul><li>拉格朗日乘子法求解</li><li>用现成数学包求解</li></ul><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a><a href="https://zhuanlan.zhihu.com/p/30059442">决策树</a></h2><p>决策树是一种十分常用的分类方法，需要监管学习。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>熵：表示信息的不确定性，即混乱程度。<br>$$H(D)&#x3D;-\sum_{i&#x3D;1}^N p_ilog_2p_i$$<br>$p_i$表示取到某个信息元素D的概率。</p><p>信息增益：表示得知特征A的信息而使得类X得信息不确定性减少得程度。<br>若用g(D,A)表示特征A对训练数据集D得信息增益，则有：<br>$$g(D,A)&#x3D;H(D)-H(D|A)$$<br>D|A表示加入A特征之后的训练集D。</p><p>条件熵：假设在特征A上有m个分支节点，其中$D_i$表示特征A得第i个分支得节点的数据，则<br>$$H(D|A)&#x3D;\sum_{i&#x3D;1}^m\frac{|D_i|}{|D|}H(D_i)$$<br>即，特征A的分支节点的熵的加权和。</p><h3 id="训练期望"><a href="#训练期望" class="headerlink" title="训练期望"></a>训练期望</h3><ul><li>希望随着树深度的增加，节点的熵迅速的降低。</li><li>得到一个高度最矮的决策树。</li><li>到叶子节点的熵值为0，此时叶子节点为纯节点，即每个叶子节点中的实例都属于同一类。</li></ul><h3 id="决策树的构造"><a href="#决策树的构造" class="headerlink" title="决策树的构造"></a>决策树的构造</h3><p>计算所有属性的信息增益，选择当前信息增益最大的特征进行划分。</p><h3 id="改进算法"><a href="#改进算法" class="headerlink" title="改进算法"></a>改进算法</h3><p>CART算法。</p><h2 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h2><p>卷积神经网络（Convolutional Neural Networks）是一种深度学习模型或类似于人工神经网络的多层感知器，常用来分析视觉图像。</p><p>全连神经网络数量太庞大，不适合处理图像，因此需要通过CNN局部感知。<br>CNN特点：</p><ul><li><p>局部感知</p></li><li><p>参数共享</p></li><li><p>多卷积核</p></li><li><p>池化处理</p><p>最大池化、平均池化</p></li><li><p>多层结构</p><p>层数越多，学到的特征越全局化</p></li></ul><p>卷积计算，使用哈达玛积。</p><p>步长：滑动的长度</p><p>窄卷积和宽卷积：对图像边缘的处理，是否扩充图片边缘。</p><p>2023.3.18</p><h2 id="图像语义分割"><a href="#图像语义分割" class="headerlink" title="图像语义分割"></a>图像语义分割</h2><p>概念：对图像中的每个像素进行分类。</p><p>任务：识别图像中存在的内容及位置。</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>用$J(\theta_1)$表示$h_{\theta}(x)$的代价函数。<br>$$J(\theta_1)&#x3D;\frac{1}{2m}\sum(h_\theta(x^{(i)})-y^{(i)})^2$$</p><h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><p>$$\theta_j&#x3D;\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta_0,\theta_1) \space\space(for\space j&#x3D;0\space and\space j&#x3D;1)$$<br>$\alpha$称为学习率，学习率太大，会导致发散，学习率太小，会导致收敛过慢。<br>如何找到合适的学习率？<br>画出$min\space J(\theta)-No.of\space iteration$图像，判断算法是否已经收敛，挥着通过自动收敛测试判断。如果函数递增，则说明没有收敛，需要使用较小的学习率。最开始的时候可以每隔十倍取一次值尝试。<br>convex function 凸函数<br>Feature Scaling：通过放缩特征数据的范围一致，使得梯度下降法运行效果更加丝滑。<br>Mean normalization（均值归一化）：通过平移和放缩，使得特征数据的样本中心接近。<br>可以通过简单的特征变换，拟合不同的函数。</p><h2 id="正规方程法"><a href="#正规方程法" class="headerlink" title="正规方程法"></a>正规方程法</h2><p>正规方程法求$\Theta$推导：<br>设样本特征数为n，样本个数为m，则设$X$为样本构成的$n\times m$的矩阵，$Y_{m\times 1}$为真实预测值，$\Theta_{n\times 1}$为待求参数值，则价值函数的矩阵形式为：<br>$$J(\Theta)&#x3D;(X\Theta -Y)^T(X\Theta -Y)$$<br>由微分知识可知，当任意的$\theta_i$满足<br>$$\frac{\partial}{\partial\theta_i}J(\Theta)&#x3D;0$$<br>时，存在极值，于是对于每个$\theta_i$，求$J(\Theta)$的偏导等于0。化简，得到：<br>$$J(\Theta)&#x3D;\Theta^T X^TX\Theta-2Y^TX\Theta$$<br>考虑在$A_{1\times n}\Theta_{n\times 1}$中，对每一个$\theta_i$求导，得到极值条件：<br>$$A^T&#x3D;0$$<br>考虑在$\Theta_{n\times 1}^T A_{n\times n}\Theta_{n\times 1}$中，对每一个$\theta_i$求导，得到极值条件：<br>$$\frac{\partial}{\partial \theta_i}(\Theta_{n\times 1}^T A_{n\times n}\Theta_{n\times 1})&#x3D;\frac{\partial}{\partial \theta_i}(\Theta^Ta_{xi}+a_{ix}\Theta-\theta_i^2aii)&#x3D;2a_{ix}\theta_i$$<br>因此通过求导和重新排列，· 得到$J(\Theta)$的极值条件：<br>$$2X^TX\Theta -2X^TY&#x3D;0$$<br>即<br>$$\Theta&#x3D;(X^TX)^{-1}X^TY$$<br>线性代数中，可以通过正规方程法，直接求使得代价函数最小的$\Theta$，但是由于正规方程法是$O(n^3)$复杂度，在数据量很大时，只能使用梯度下降法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;K-Means&quot;&gt;&lt;a href=&quot;#K-Means&quot; class=&quot;headerlink&quot; title=&quot;K-Means&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/184686598&quot;&gt;K-Means&lt;/a&gt;&lt;/h2&gt;</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="机器学习" scheme="https://jayerine.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>鲲鹏软件迁移</title>
    <link href="https://jayerine.top/2024/02/06/125b95e4ccef/"/>
    <id>https://jayerine.top/2024/02/06/125b95e4ccef/</id>
    <published>2024-02-06T04:00:21.577Z</published>
    <updated>2024-02-06T04:00:21.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="周末和Erine去听了huawei的讲座"><a href="#周末和Erine去听了huawei的讲座" class="headerlink" title="周末和Erine去听了huawei的讲座"></a>周末和Erine去听了huawei的讲座</h2><p>开学的第一个星期，好好的周末选择去坐大牢了）。感觉整个实验做下来，很大部分内容就是跟着老是配环境，下载各种软件。有一次总是Missing file，结果是下载zip的时候没有下完整就解压了。然后动不动就有些环境掉了，爆出一大堆错，比较吓人。</p><p>感觉现在的网站搭建的各种工具有一个趋势，就是自动化水平越来越高了，各种组件和模板都有很多现成的，上手起来就方便了很多。还有就是大数据服务很高级，Hadoop、Hive之类的分析工具做的非常好。</p><p>前端的难感觉难在很多简单的东西凑在一起，就变得很复杂了，需要非常细心，有很多细节需要注意，一不小心就404了。以后可能不做前端工作，但是还是得会一点。</p><p>下面记录一些Jay通过鲲鹏软件迁移工具了解到的信息。</p><h2 id="常用网站部署工具"><a href="#常用网站部署工具" class="headerlink" title="常用网站部署工具"></a>常用网站部署工具</h2><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>反向代理，有利于保护服务器。直接在公网上部署服务器，容易受到攻击。Nginx可以用与实现反向代理，以及负载均衡，自动平衡服务器之间的业务量。负责运行前端应用。</p><h3 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h3><p>大数据分析工具，为海量数据提供存储和计算。</p><h4 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h4><p>Hadoop Distributed File System的简称，是Hadoop抽象文件系统的一种实现。Hadoop抽象文件系统可以与本地系统、Amazon S3等集成，甚至可以通过Web协议（webhsfs）来操作。HDFS的文件分布在集群机器上，同时提供副本进行容错及可靠性保证。例如客户端写入读取文件的直接操作都是分布在集群各个机器上的，没有单点性能压力。</p><h4 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h4><p>Yarn是一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的操作系统平台，而MapReduce等运算程序则相当于运行于操作系统之上的应用程序。</p><h3 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h3><p>大数据查询工具，提供SQL语句查询功能。</p><h3 id="apache"><a href="#apache" class="headerlink" title="apache"></a>apache</h3><p>开放源码的网页服务器，可以在大多数计算机操作系统中运行，由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。</p><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>SQL- 是structured query language简称。MySQL是数据库管理系统，能够帮助你管理关系型数据库，并且是开源的，意味着这是免费的，如果必要，你可以修改源代码。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mysql@ecs-3ddf bin]$ service mysql start</span><br><span class="line">//启动数据库</span><br><span class="line">[mysql@ecs-3ddf bin]$ mysql -uroot -p -S /data/mysql/run/mysql.sock</span><br><span class="line">//登录数据库</span><br></pre></td></tr></table></figure><h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><p>Spring Boot 是由 Pivotal 团队提供的基于 Spring 的全新框架，旨在简化 Spring 应用的初始搭建和开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。</p><p>Spring 官网给的定义是：Spring Boot 是所有基于 Spring 开发项目的起点。Spring Boot 集成了绝大部分目前流行的开发框架，就像 Maven 集成了所有的 JAR 包一样，Spring Boot 集成了几乎所有的框架，使得开发者能快速搭建 Spring 项目。</p><p>Spring Boot 的核心设计思想是“约定优于配置”。基于这一设计原则，Spring Boot 极大地简化了项目和框架的配置。比如在使用 Spring 开发 Web 项目时，我们需要配置 web.xml、Spring 和 MyBatis 等，还需要将它们集成在一起。而使用 Spring Boot 一切将变得极其简单，它采用了大量的默认配置来简化这些文件的配置过程，只需引入对应的 Starters（启动器）。</p><p>Spring Boot 可以构建一切。设计它就是为了使用最少的配置，以最快的速度来启动和运行 Spring 项目。</p><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a><a href="https://blog.csdn.net/chaizepeng/article/details/119384531">Mybatis</a></h3><p>mybatis是一款用于持久层的、轻量级的半自动化<a href="https://blog.csdn.net/Mr_VK/article/details/122930987#:~:text=%E4%BB%80%E4%B9%88%E6%98%AForm?">ORM框架</a>，封装了所有jdbc操作以及设置查询参数和获取结果集的操作，支持自定义sql、存储过程和高级映射。</p><h3 id="Layui"><a href="#Layui" class="headerlink" title="Layui"></a>Layui</h3><p>Layui是一套开源的 Web UI 组件库。layui采用自身极简的模块化规范，并遵循原生 HTML&#x2F;CSS&#x2F;JS 的开发模式，极易上手，开箱即用。非常适合网页界面的快速构建。</p><h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><p>jQuery是一个快速，小型且功能丰富的JavaScript库。借助易于使用的API（可在多种浏览器中使用），使HTML文档的遍历和操作，事件处理，动画和Ajax等事情变得更加简单。</p><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><p>Maven是基于项目对象模型(POM project object model)，可以通过一小段描述信息（配置）来管理项目的构建，报告和文档的软件项目管理工具.</p><h2 id="Linux常用操作"><a href="#Linux常用操作" class="headerlink" title="Linux常用操作"></a>Linux常用操作</h2><h3 id="配置yum源便于下载"><a href="#配置yum源便于下载" class="headerlink" title="配置yum源便于下载"></a>配置yum源便于下载</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ecs-3ddf yum.repos.d]<span class="comment"># wget -O /etc/yum.repos.d/openEulerOS.repo https://repo.huaweicloud.com/repository/conf/openeuler_aarch64.repo</span></span><br><span class="line">[root@ecs-3ddf yum.repos.d]<span class="comment"># yum clean all</span></span><br><span class="line">[root@ecs-3ddf yum.repos.d]<span class="comment"># yum makecache</span></span><br></pre></td></tr></table></figure><h3 id="echo-命令"><a href="#echo-命令" class="headerlink" title="echo 命令"></a>echo 命令</h3><p>用于显示和打印各种字符串或变量</p><h3 id="Linux-chown（英文全拼：change-owner）命令"><a href="#Linux-chown（英文全拼：change-owner）命令" class="headerlink" title="Linux chown（英文全拼：change owner）命令"></a>Linux chown（英文全拼：change owner）命令</h3><p>用于设置文件所有者和文件关联组的命令，chown 需要超级用户 root 的权限才能执行此命令。chown更改每个给定文件的用户和&#x2F;或组所有权。</p><p>例：修改配置文件&#x2F;etc&#x2F;my.cnf 的用户组和用户权限为 mysql:mysql。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ecs-3ddf <span class="built_in">local</span>]<span class="comment"># chown mysql:mysql /etc/my.cnf</span></span><br></pre></td></tr></table></figure><h3 id="vim使用"><a href="#vim使用" class="headerlink" title="vim使用"></a>vim使用</h3><p>命令模式下，输入:wq保存退出</p><p>命令模式下，输入u撤销操作</p><p>命令模式下，输入&#x2F;和Enter键进行查找，n键查找下一个选项</p><h3 id="source命令"><a href="#source命令" class="headerlink" title="source命令"></a>source命令</h3><p>保留、更改当前shell中的环境变量，用作配置环境后刷新。</p><p>例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ecs-3ddf <span class="built_in">local</span>]<span class="comment"># source /etc/profile</span></span><br></pre></td></tr></table></figure><h2 id="鲲鹏代码迁移工具"><a href="#鲲鹏代码迁移工具" class="headerlink" title="鲲鹏代码迁移工具"></a>鲲鹏代码迁移工具</h2><p>处理器所支持的指令集不同，意味着开发者可能需要对代码进行跨平台的迁移。我们常见到便是x86平台的代码往arm平台进行迁移。</p><p>通常，代码迁移是件复杂又繁琐的工作，需要花费开发者大量精力对软件包、源代码、依赖库文件进行人工分析、检查和识别，手动修正不同指令集之间的相关差异，这些差异主要涉及语法、指令、函数和库文件支持情况。</p><p>鲲鹏代码迁移工具是一款可以简化客户应用迁移到基于鲲鹏916&#x2F;920的服务器的过程的工具。工具仅支持x86 Linux到Kunpeng Linux的扫描与分析，不支持Windows软件代码的扫描、分析与迁移。</p><p>当用户有x86平台上源代码的软件要迁移到基于鲲鹏916&#x2F;920的服务器上时，既可以使用该工具分析可迁移性和迁移投入，也可以使用该工具自动分析出需修改的代码内容，并指导用户如何修改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;周末和Erine去听了huawei的讲座&quot;&gt;&lt;a href=&quot;#周末和Erine去听了huawei的讲座&quot; class=&quot;headerlink&quot; title=&quot;周末和Erine去听了huawei的讲座&quot;&gt;&lt;/a&gt;周末和Erine去听了huawei的讲座&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="华为" scheme="https://jayerine.top/tags/%E5%8D%8E%E4%B8%BA/"/>
    
    <category term="网站" scheme="https://jayerine.top/tags/%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>Erine的文案</title>
    <link href="https://jayerine.top/2024/02/06/2d0f77ed687f/"/>
    <id>https://jayerine.top/2024/02/06/2d0f77ed687f/</id>
    <published>2024-02-06T04:00:21.577Z</published>
    <updated>2024-02-06T04:00:21.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2023-3-11"><a href="#2023-3-11" class="headerlink" title="2023.3.11"></a>2023.3.11</h2><p>你是否有过这样的遭遇？<br>网购的商品收到后却是冒牌货<br>超市冰柜里买回来的酸奶却早已过期<br>路边疯狂推销的优惠办卡却在半个月后卷钱跑路  </p><p>第41个“3·15国际消费者权益日”即将到来<br>让我们来共同了解一下这个节日吧！ </p><h3 id="3·15国际消费者权益日简介"><a href="#3·15国际消费者权益日简介" class="headerlink" title="3·15国际消费者权益日简介"></a>3·15国际消费者权益日简介</h3><p>国际消费者权益日，最早由国际消费者联盟组织于1983年确定，目的在于扩大消费者权益保护的宣传，使之在世界范围内得到重视，促进各国和地区消费者组织之间的合作与交往，在国际范围内更好地保护消费者权益。<br>中国消费者协会确定2023年全国消协组织消费维权年主题为“提振消费信心”。<br>“提振消费信心”具有以下三个方面的涵义：<br>一是立足主责主业，推动消费者权益保护协同共治，打造更加安全放心消费环境；<br>二是坚持需求导向，顺应消费需求多元化趋势，推动消费供给提质升级，推动高质量发展；<br>三是坚持问题导向，找准主攻方向，解决“急难愁盼”，推动消费提质升级。  </p><h3 id="我国的《3·15晚会》"><a href="#我国的《3·15晚会》" class="headerlink" title="我国的《3·15晚会》"></a>我国的《3·15晚会》</h3><p>3·15国际消费者权益日的宗旨就是对消费者进行教育，提高消费者维护自身权益的意识和能力，并且处理消费者投诉，帮助消费者挽回损失。<br>1987年9月，中国消费者协会被国际消费者联盟组织接受为正式成员，中国消费者协会及地方各级协会都要联合各有关部门共同举办大规模的宣传活动。1991年，中央电视台、中国消费者报社、中华工商时报社与中国消费者协会联合举办了国际消费者权益日“消费者之友专题晚会”，从此拉开了中央电视台《3·15晚会》的序幕。从此以后，中央电视台《3·15晚会》已经成为一个符号，是中国消费者最信赖的守护消费品质的舆论阵地。<br>《3·15晚会》唤醒了消费者的权益意识，成为规范市场秩序、传播国家法规政策的强大平台。专题调查、权威发布等都成为广大观众最期待的节目亮点。目前，《3·15晚会》已成为一个符号，成为亿万消费者信赖的舆论阵地，成为国家有关部委规范市场秩序的重要力量，3·15也从一个简单的数字变成了维护消费者权益的代名词。  </p><h3 id="权益受到侵害，该怎么办"><a href="#权益受到侵害，该怎么办" class="headerlink" title="权益受到侵害，该怎么办?"></a>权益受到侵害，该怎么办?</h3><p>作为消费者，当我们的权益收到侵害时，可以拨打12315等举报电话，用好法律这把利器，在法治框架内维护自己的合法权益，让不良商家付出应有的代价。同时，也要增强我们作为消费者的安全意识和防范能力，树立理性消费观念。<br>但要守住消费安全这道防线，更重要的是需要商家承担起诚信经营的责任和义务，恪守商业道德，始终把消费者的人身生命财产和个人信息安全放在首位，自觉强化消费者权益保护第一责任人的意识，主动接受社会监督。  </p><p>让我们共同努力，创造更安全、更有保障的消费环境，维护消费者合法权益！  </p><p><a href="https://mp.weixin.qq.com/s/-5nglkRoT7Y8dLd9qkT5nw">提振消费信心 共筑消费和谐 | 3·15国际消费者权益日</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2023-3-11&quot;&gt;&lt;a href=&quot;#2023-3-11&quot; class=&quot;headerlink&quot; title=&quot;2023.3.11&quot;&gt;&lt;/a&gt;2023.3.11&lt;/h2&gt;&lt;p&gt;你是否有过这样的遭遇？&lt;br&gt;网购的商品收到后却是冒牌货&lt;br&gt;超市冰柜里买回来的酸</summary>
      
    
    
    
    <category term="随笔" scheme="https://jayerine.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>lichess记录</title>
    <link href="https://jayerine.top/2024/02/06/edea1504322d/"/>
    <id>https://jayerine.top/2024/02/06/edea1504322d/</id>
    <published>2024-02-06T04:00:21.561Z</published>
    <updated>2024-02-06T04:00:21.561Z</updated>
    
    
    
    
    <category term="兴趣爱好" scheme="https://jayerine.top/categories/%E5%85%B4%E8%B6%A3%E7%88%B1%E5%A5%BD/"/>
    
    
    <category term="chess" scheme="https://jayerine.top/tags/chess/"/>
    
  </entry>
  
  <entry>
    <title>C++</title>
    <link href="https://jayerine.top/2024/02/06/0ea105e1bfda/"/>
    <id>https://jayerine.top/2024/02/06/0ea105e1bfda/</id>
    <published>2024-02-06T04:00:21.561Z</published>
    <updated>2024-02-06T04:00:21.561Z</updated>
    
    <content type="html"><![CDATA[<p>很少注意到的main函数的另一个重载形式，int main(int argc,char *argv[])。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//main函数的重载，另一个是int main(void)</span></span><br><span class="line">    <span class="comment">//argc表示传进去多少个参数</span></span><br><span class="line">    <span class="comment">//argv是一个包含传入参数的默认二维char数组，调用函数，默认会将调用的函数名作为第一个参数</span></span><br><span class="line">    <span class="comment">//很像命令</span></span><br><span class="line">    <span class="built_in">int</span> (*f)(<span class="type">int</span>,<span class="type">char</span> *[])=main;</span><br><span class="line">    <span class="comment">//函数指针</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">char</span> ***a=&amp;argv,*first=argv[<span class="number">0</span>],ch=argv[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//printf(&quot;arg=\&quot;%s\&quot;;ch=&#x27;%c&#x27;\n&quot;,first,ch);</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;argc= &quot;</span>&lt;&lt;argc&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;argc;i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;argc[%d]= %s\n&quot;</span>,i,argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(***a ==ch);</span><br><span class="line">        <span class="comment">//assert的作用是先计算表达式expression，如果其值为假（即为0），那么它先向stderr打印一条出错信息，之后通过调用abort来终止程序运行。判断是否第一个字符是否等于第一个字符？一定会相等吧。</span></span><br><span class="line">        <span class="built_in">f</span>(argc - <span class="number">1</span>,argv+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//通过函数指针递归调用main.exe，并控制参数的传入，传入的参数减少一个，argv指针类型为char***，argv变量+1，应该是重载过加号，意思是指向下一个地址空间的char**地址，下一次进入递归，会打印下一个传入的参数。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面向对象课上学的c++类的基本元素：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>(arg);<span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Object</span>(arg):<span class="built_in">Object</span>(arg<span class="number">&#x27;</span>);<span class="comment">//构造函数列表</span></span><br><span class="line">    ~<span class="built_in">Object</span>(<span class="type">void</span>);<span class="comment">//析构函数</span></span><br><span class="line">    <span class="built_in">Object</span>(<span class="type">const</span> Object &amp;object);<span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">func</span><span class="params">(arg)</span></span>;<span class="comment">//友元函数</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ObjFriend</span>;<span class="comment">//友元类</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;<span class="comment">//虚函数，用于实现多态</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>=<span class="number">0</span>;<span class="comment">//纯虚函数，用于实现接口和抽象类</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;<span class="comment">//重写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(arg)</span></span>;<span class="comment">//重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前一直没有理解多态的作用，多态可以使编写父类的程序员无需关心子类的情况，可以将一个子类的实例赋值给父类，此时这个实例拥有子类的细节，当调用其中的虚方法的时候，能正确调用子类的实现方法，方便上游程序员编写类的相关方法。</p><p>一些细节:</p><ul><li>无参构造方法，实例化的时候不能带括号。</li><li>time(0)函数返回的是秒。</li><li>尽量多用const修饰。</li></ul><p>一些好用的库：</p><ul><li>正则表达式regix，可以方便的进行自定义字符提取，判断是否匹配格式。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很少注意到的main函数的另一个重载形式，int main(int argc,char *argv[])。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;lin</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://jayerine.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>IDE使用记录</title>
    <link href="https://jayerine.top/2024/02/06/a8fa2ad5debf/"/>
    <id>https://jayerine.top/2024/02/06/a8fa2ad5debf/</id>
    <published>2024-02-06T04:00:21.561Z</published>
    <updated>2024-02-06T04:00:21.561Z</updated>
    
    <content type="html"><![CDATA[<p>今天初次使用了QT，安装的时候，出了一些问题记录一下。</p><p>QT6版本必须在线下载，网速其实还可以。</p><p>安装的时候，选择它给的默认安装组件就行。</p><p>记得把“D:\QT\6.5.0\mingw_64\bin”加入环境变量，否则会因为找不到DLL库报错。</p><p>在项目中配置运行环境，注意可能自动选择了vs的工具，导致编译出错。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天初次使用了QT，安装的时候，出了一些问题记录一下。&lt;/p&gt;
&lt;p&gt;QT6版本必须在线下载，网速其实还可以。&lt;/p&gt;
&lt;p&gt;安装的时候，选择它给的默认安装组件就行。&lt;/p&gt;
&lt;p&gt;记得把“D:&#92;QT&#92;6.5.0&#92;mingw_64&#92;bin”加入环境变量，否则会因为找不到DL</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://jayerine.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ROS2学习</title>
    <link href="https://jayerine.top/2024/02/06/b6336b6b162f/"/>
    <id>https://jayerine.top/2024/02/06/b6336b6b162f/</id>
    <published>2024-02-06T04:00:21.561Z</published>
    <updated>2024-02-06T04:00:21.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ROS1和ROS2的选择"><a href="#ROS1和ROS2的选择" class="headerlink" title="ROS1和ROS2的选择"></a>ROS1和ROS2的选择</h2><p>小车型号是HUNTER SE，给的官方教程是使用ROS1操作，但是安装教程过于陈旧，需要使用ubuntu16版本，和ROS KENICT版本，网上说ROS2是兼容ROS1的，而且有更好的性能，所以选择ROS2。</p><h2 id="配置ROS2环境记录"><a href="#配置ROS2环境记录" class="headerlink" title="配置ROS2环境记录"></a>配置ROS2环境记录</h2><p>环境：ubuntu22.04+vscode</p><p><a href="https://fishros.com/d2lros2/#/humble/chapt1/%E7%AB%A0%E8%8A%82%E5%AF%BC%E8%AF%BB">教程1</a></p><h3 id="一、安装必要的ROS2工具"><a href="#一、安装必要的ROS2工具" class="headerlink" title="一、安装必要的ROS2工具"></a>一、安装必要的ROS2工具</h3><p>网上教程很丰富，采用了直接进入官网下载安装包本地安装，选择代号为rolling的最新版本。</p><h3 id="二、配置vscode环境"><a href="#二、配置vscode环境" class="headerlink" title="二、配置vscode环境"></a>二、<a href="https://blog.csdn.net/m0_52332336/article/details/127452907">配置vscode环境</a></h3><p>考虑使用cmake+ament_cmake+colcon构建。<br>可以使用教程中的ros2 pkg命令创建新的项目，参数可以问chatgpt。</p><p>需要的包和工具：</p><ul><li>cmake是多文件编译的基本工具，可以根据CMakeLists.txt自动生成MakeFile文件</li><li>ament_cmake用于辅助ROS2的项目构建，注意这个包不会随着ROS工具集一起下载，需要使用apt-get命令单独安装。</li><li>colcon用于管理ros2的package的工作空间。这个工具是一个vscode插件。colcon基于CMake工作，在调试过程中，可单独使用CMake运行项目，在最终完成项目时，按下ctrl+shift+B，使用colcon build进行package的安装。</li></ul><h3 id="需要注意的坑"><a href="#需要注意的坑" class="headerlink" title="需要注意的坑"></a>需要注意的坑</h3><h4 id="坑1：装好ROS相关工具之后，无法在命令行使用"><a href="#坑1：装好ROS相关工具之后，无法在命令行使用" class="headerlink" title="坑1：装好ROS相关工具之后，无法在命令行使用"></a>坑1：装好ROS相关工具之后，无法在命令行使用</h4><ul><li>解决1：每次打开shell前，需要运行命令  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /opt/ros/rolling.setup.bash</span><br></pre></td></tr></table></figure>  可以通过修改shell配置的方法，使得每次打开shell时自动运行该命令。  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure>  在文件的末尾加入该命令。</li></ul><h4 id="坑2：ztrl-shift-P，输入Edit-Config，配置好c-cpp-preproperties的第三方引用路径之后，代码提示中还是报错，找不到头文件。"><a href="#坑2：ztrl-shift-P，输入Edit-Config，配置好c-cpp-preproperties的第三方引用路径之后，代码提示中还是报错，找不到头文件。" class="headerlink" title="坑2：ztrl+shift+P，输入Edit Config，配置好c_cpp_preproperties的第三方引用路径之后，代码提示中还是报错，找不到头文件。"></a>坑2：ztrl+shift+P，输入Edit Config，配置好c_cpp_preproperties的第三方引用路径之后，代码提示中还是报错，找不到头文件。</h4><ul><li>解决2：在CmakeLists.txt文件中，使用include_directories语句，将需要使用的头文件地址引用。注意，这个语句不会进行递归搜索，所以需要写清楚引用头文件的相对路径。</li></ul><h4 id="坑3：习惯性的想使用External-consoler，但是launch-json文件配置不成功"><a href="#坑3：习惯性的想使用External-consoler，但是launch-json文件配置不成功" class="headerlink" title="坑3：习惯性的想使用External consoler，但是launch.json文件配置不成功"></a>坑3：习惯性的想使用External consoler，但是launch.json文件配置不成功</h4><ul><li>解决3：没什么办法，想要使用外部终端，只能在外面打开一个新的shell了</li></ul><h4 id="坑4：CMake编译运行成功之后，没有install的输出"><a href="#坑4：CMake编译运行成功之后，没有install的输出" class="headerlink" title="坑4：CMake编译运行成功之后，没有install的输出"></a>坑4：CMake编译运行成功之后，没有install的输出</h4><ul><li>解决4：install的默认路径中的lib，是 $CMAKE_INSTALL_PREFIX的相对路径，需要单独使用make install命令才会有输出。注意需要在cmake ..之后使用，即在CMakeLists.txt的子目录下进行使用。</li></ul><h4 id="坑5：CMake编译运行成功，但是使用ros2-run命令找不到package"><a href="#坑5：CMake编译运行成功，但是使用ros2-run命令找不到package" class="headerlink" title="坑5：CMake编译运行成功，但是使用ros2 run命令找不到package"></a>坑5：CMake编译运行成功，但是使用ros2 run命令找不到package</h4><ul><li>解决5：没有理解colcon的作用，需要先使用colcon build构建工作空间，然后必须运行source install&#x2F;setup.bat，之后才能找到自定义的package。package的名称，可以在package.pom中设置，executable_name可以在CMakeLists.txt中设置，即导出文件的名称。</li></ul><h3 id="ROS2工作原理的初步理解"><a href="#ROS2工作原理的初步理解" class="headerlink" title="ROS2工作原理的初步理解"></a>ROS2工作原理的初步理解</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ROS1和ROS2的选择&quot;&gt;&lt;a href=&quot;#ROS1和ROS2的选择&quot; class=&quot;headerlink&quot; title=&quot;ROS1和ROS2的选择&quot;&gt;&lt;/a&gt;ROS1和ROS2的选择&lt;/h2&gt;&lt;p&gt;小车型号是HUNTER SE，给的官方教程是使用ROS1操作</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="硬件" scheme="https://jayerine.top/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="https://jayerine.top/2024/02/06/00c22e4202c6/"/>
    <id>https://jayerine.top/2024/02/06/00c22e4202c6/</id>
    <published>2024-02-06T04:00:21.561Z</published>
    <updated>2024-02-06T04:00:21.561Z</updated>
    
    <content type="html"><![CDATA[<p>记录最难受的一次ubuntu ssh使用经历。<br>今天想尝试一下ssh免密码登录服务器，本来以为几分钟就完事了，结果发现按照网上的教程没有成功。</p><p>首先在客户端生成ssh密钥</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -f C:\Users\JayL/.ssh/ubuntu_key</span><br></pre></td></tr></table></figure><p>注意windows下不能直接使用ssh-copy-id命令，所以选择手动拷贝pub到&#x2F;home&#x2F;jayl&#x2F;.ssh&#x2F;authorized_keys下。</p><p>发现还是不能免密码连接。</p><p>打开客户端ssh调试信息打印，发现信息很粗略，没有什么价值。</p><p>反复查看网上说的文件权限的问题，发现一切正常。</p><p>按照教程，开始折腾rsyslog和&#x2F;etc&#x2F;ssh&#x2F;sshd_config配置文件，但是由于没找到官方文档，设置的依托答辩，后来还不小心给把日志文件auth给弄没了。</p><p>最后使用下面的命令，打印sshd的调试信息。</p><p>sudo &#x2F;usr&#x2F;sbin&#x2F;sshd -p 2222 -d</p><p>ssh -vvv -p 2222 jayl@玺.top</p><p>结果只是说找不到公钥。</p><p>最后，偶然间发现，在&#x2F;home&#x2F;jayl&#x2F;.ssh&#x2F;authorized_keys 第一行加一行空行，就可以正常运行了。</p><p>以后找奇怪的bug，调试信息非常重要，不然很难定位到一个点。<br>从一开始没有想过去看官方文档，浪费了很多时间。<br>还有就是，这个奇怪的错误太阴间了，不知道是为什么。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录最难受的一次ubuntu ssh使用经历。&lt;br&gt;今天想尝试一下ssh免密码登录服务器，本来以为几分钟就完事了，结果发现按照网上的教程没有成功。&lt;/p&gt;
&lt;p&gt;首先在客户端生成ssh密钥&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://jayerine.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>android文本路径选择器</title>
    <link href="https://jayerine.top/2024/02/06/8311e7629f95/"/>
    <id>https://jayerine.top/2024/02/06/8311e7629f95/</id>
    <published>2024-02-06T04:00:21.561Z</published>
    <updated>2024-02-06T04:00:21.561Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/m0_61322309/article/details/126552369?spm=1001.2014.3001.5501">csdn</a></p><ul><li>​预期效果：通过点击文件夹或文件，选择文件或文件夹，并返回选择的路径</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>花了几天时间，做这个小程序，初步学习并体验了一下android开发。没想到看似这么基础的功能，也需要五六百行代码来实现。学习过程就是把网上前人的代码片段扒下来，然后一点点看懂，纠错，完善，通过看懂别人写的代码来学习。把学习到的东西，后来遇到的一些困难，以及解决的方法，作为笔记整理记录一下。</p><p>1.第一次深入了解面向对象语言，了解了面向对象语言的很多基础知识，如基类，派生类，接口，继承，implements的使用条件和规范，this的各种用法，和一些基础的方法，如super()。第一次学习xml文件的标签语言，如何用xml文件组织运行程序的各种资源，以及不同activity之间的通信方法。</p><p>2.学习了android软件开发的一些流程，从package下的文件构成，res下文件的作用，gradle的使用，manifest中注册activity，签名打包成apk文件，初步了解了整个android开发的基本流程。</p><p>3.了解了一些在android开发debug的一些基本方法。</p><p>（1）由于没学Kotlin，只会用Java，因此在网上看教程的时候，常常出现看不懂别人写的kotlin代码的情况。这时候可以用android studio中tools的Java和Kotlin代码互相转化的工具，将看不懂的Kotlin代码转化为Java代码帮助理解。</p><p>（2）最开始是用usb连接手机和电脑进行调试的，后来发现了一个更方便，更快捷的调试方法，就是用adb插件进行无线调试，网上很多教程，就是注意一点，华为的鸿蒙系统，设置里没有直接进行扫码与android studio链接的功能，需要手动开启电脑的命令框，进行连接，网上也很多教程。</p><p>（3）刚开始不知道有LogCat这样一个android studio自带的日志记录软件，程序崩溃退出老是找不到原因，也不会去看报错，就直接用Toast向屏幕发信息来调试。知道LogCat之后，程序崩溃的Log可以看的到，调试就方便了太多了。</p><p>(4)对于一些常见的报错和崩溃，有了些认识。比如空指针报错，在Java开发中算是最常见的了。往往就是初始化对象，没有实例化，在之后的使用中就报错，让程序崩溃了。或者是findObjectById的方法，必须先将Object在layout中加载出来，不然绑定的时候程序会直接崩溃退出。所以要养成好习惯，设置好异常流的检查，用try,catch,finally的语句控制检查运行异常。</p><p>（5）比较离谱的bug，实在绕不过可以换种方式写。在这次实践中，就有一处写的和官方一摸一样，编译器还报错的，换了种类似的写法，就完全没有问题了。还有些离谱的问题，就只能靠经验积累了。比如有一次突然就不能显示文字了，反复查看才发现字体颜色没设置，与背景混为一体了。</p><p>（6）由于android更新换代非常快，经常会出现一些方法突然用不了了，过时了之类的问题。这时候就需要仔细鉴别和设置各种版本了。利用gradle下的版本管理，非常的方便，可以很容易的设置sdk版本，编译器版本，依赖库资源等各种版本。遇到最新的问题时，可能有用的中文教程非常有限，还是需要到官网上学习最新方法的使用。这一次实践中，由于要切换activity,并在不同的activity之间进行通信，原有的教程中，使用的是setActivityForStart()和OnActivitySet方法。在最新的sdk30版本中，已经标记为废弃该方法进行活动间通信了，要使用最新的ActivityContracts，来规范信息传递，让方法更高效安全。网上很多教程都不合适，于是只能去官网上学习了contracts的写法。还有一个版本带来的问题。早在android 4.0之后，系统就开始对app的存储修改权限做出了限制，无法随意修改读取。在最近的android10.0更新之后，又做了一次修改，使得android系统中app的读取权限更小了。在manifest文件中申请的权限，实际上十分小了，仅限于app安装的目录下的cache文件。若要进行越界内存访问，需要更多的内存申请方法。在了解这些版本问题之前，经常被莫名奇妙的bug困扰，这就是为什么，有时候照抄别人代码，程序也会报错崩溃。</p><p>(7)关于uft8编码和另一种中文编码不能被app读取路径的问题，其实是不存在的。后面看Log才发现，程序闪退是因为List为null，和编码没关系。比较新的android版本对于中文的支持都挺好了。</p><p>4.csdn帮助了我很多，有很多很不错的大佬写的教程。但是面对有些棘手的bug，中文教程看了几十篇也找不到可行方案时，就很头疼了。这时候最好应该直接去官网上学习，看不懂英文也没关系，反正有翻译。官网上的教程可以说是最好最详尽的了，是个高质量的学习途径。</p><p>5.有时候发现一个bug改不出来，可以向大佬们请教，相互交流。在一些QQ群中，或者交流网站，都有很多厉害的大佬，说不定困扰很久的问题，大佬一眼就能帮自己点破，而且能了解一些高效学习的方法。这对于初学者来说帮助挺大的。</p><p>6.不足和改进：这个程序只能读取app中cache下的文件资料，因为版本问题，高版本的android限制了app对公共存储的访问。如果要申请对其他内存的访问，应该使用最新的访问api协议。对于面向对象编程方法的巧妙之处理解还很浅显。写的代码很容易就变成面向过程了，就失去了面向对象编程的意义。大佬说最新的androiid提供了一个全局管理activity的方法，就不用intent来切换activity了，这样反而更慢。全局管理应该是个好东西，值得学一手。</p><p>除了作为笔记，还有一点就是看到好的教程太少了，基本上都是代码片段，或者不完整，或者版本陈旧，无法参考，因此发了个最完整的带各种注释的文件供初学者实践参考。</p><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/m0_61322309/article/details/126552369?spm=1001.2014.3001.5501&quot;&gt;csdn&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;​预期效果：通过点击文件夹或文件，选择文件</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="android" scheme="https://jayerine.top/tags/android/"/>
    
    <category term="csdn" scheme="https://jayerine.top/tags/csdn/"/>
    
  </entry>
  
  <entry>
    <title>TSN网络</title>
    <link href="https://jayerine.top/2024/02/06/8513ff2ec67a/"/>
    <id>https://jayerine.top/2024/02/06/8513ff2ec67a/</id>
    <published>2024-02-06T04:00:21.561Z</published>
    <updated>2024-02-06T04:00:21.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TSN"><a href="#TSN" class="headerlink" title="TSN"></a><a href="https://zhuanlan.zhihu.com/p/342289546">TSN</a></h1><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="GCL："><a href="#GCL：" class="headerlink" title="GCL："></a>GCL：</h3><p>门控列表（Gate Control List，GCL）</p><h3 id="CNC："><a href="#CNC：" class="headerlink" title="CNC："></a>CNC：</h3><p>集中网络控制器（centralized network configuration，CNC）</p><h3 id="CUC："><a href="#CUC：" class="headerlink" title="CUC："></a>CUC：</h3><p>集中用户控制器（centralized user configuration，CUC）</p><h3 id="802-1AS："><a href="#802-1AS：" class="headerlink" title="802.1AS："></a><a href="https://www.polelink.com/index.php?m=content&c=index&a=show&catid=93&id=53">802.1AS</a>：</h3><p>通用精确时间协议（Generalized Precision Time Protocol），将为汽车、工业自动化控制等领域实现精确时间的测量。</p><h3 id="Linux-Traffic-Control"><a href="#Linux-Traffic-Control" class="headerlink" title="Linux Traffic Control:"></a><a href="https://blog.csdn.net/qinyushuang/article/details/46611709">Linux Traffic Control</a>:</h3><p>Linux TC(Traffic Control) 众所周知，在互联网诞生之初都是各个高校和科研机构相互通讯，并没有网络流量控制方面的考虑和设计，IP协议的原则是尽可能好地为所有数据流服务，不同的数据流之间是平等的。然而多年的实践表明，这种原则并不是最理想的，有些数据流应该得到特别的照顾，比如，远程登录的交互数据流应该比数据下载有更高的优先级。</p><h3 id="NETCONF"><a href="#NETCONF" class="headerlink" title="NETCONF:"></a><a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/NETCONF.html">NETCONF</a>:</h3><p>网络配置协议NETCONF（Network Configuration Protocol）为网管和网络设备之间通信提供了一套协议，网管通过NETCONF协议对远端设备的配置进行下发、修改和删除等操作。网络设备提供了规范的应用程序编程接口API（Application Programming Interface），网管可以通过NETCONF使用这些API管理网络设备。<br>NETCONF是基于可扩展标记语言XML（Extensible Markup Language）的网络配置和管理协议，使用简单的基于RPC（Remote Procedure Call）机制实现客户端和服务器之间通信。客户端可以是脚本或者网管上运行的一个应用程序。服务器是一个典型的网络设备。</p><p>云时代对网络的关键诉求之一是网络自动化，包括业务快速按需自动发放、自动化运维等。传统的命令行和SNMP已经不适应云化网络的诉求。在网络自动化方面，NETCONF越来越受欢迎，并被广泛采用。</p><h3 id="OPC-UA"><a href="#OPC-UA" class="headerlink" title="OPC UA:"></a><a href="https://zhuanlan.zhihu.com/p/430243728">OPC UA</a>:</h3><p>在网络化、标准化或网络安全方面，对工业网络的要求正以非凡的速度增长。在这些问题重重的领域，基于以太网的 OPC UA（Open Platform Communications – Unified Architecture，开放平台通信 - 统一架构）通信标准正在快速发展。凭借其集成的安全机制，独立于供应商和平台的特性， OPC UA 为数字化提供了优异基础条件。</p><p><strong>交换机</strong></p><p>Gbps:</p><p>也称交换带宽，是衡量交换机总的数据交换能力的单位，以太网是IEEE802.3以太网标准的扩展，传输速度为每秒1024兆位(即1Gbps)。</p><h2 id="调度模型1-0"><a href="#调度模型1-0" class="headerlink" title="调度模型1.0"></a>调度模型1.0</h2><p>TSN调度问题简化：<br><img src="https://s1.ax1x.com/2023/03/03/ppA8keU.png" alt="TSN调度问题"></p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Q:通过调整每个f的一个开始发送时间，把周期性数据给错开，假如发送周期都是离散的数值，每个数据发送占一个周期的时间，就取一个所有周期的最大公因数，在这个最大公因数长度的时间段中依次发送初始数据，计算offset就不会冲突了?</span><br><span class="line"></span><br><span class="line">A:最大公约数这个是一个方法，可以先这样做。显示上也足够了。之后的展示更加复杂后，若没有最大公约数，这个方法就行不通了。</span><br><span class="line"></span><br><span class="line">Q:但是如果没有最大公约数的话，会不会有无法避免冲突的情况产生呀</span><br><span class="line"></span><br><span class="line">A:肯定有无法避免的情况产生。那就是调度不成功的情况，例如说有1000个流，你只能调度600个，那就展示600个的结果就可以了。</span><br><span class="line">数据包在网络中传输经过了传输，传播，处理以及排队时延。1m的链路长度用于计算传播时延。</span><br><span class="line"></span><br><span class="line">Q:在TSN提前计算好了冲突解决，就不存在排队时延了吗？</span><br><span class="line">A:TSN交换机可以控制流什么时候被传输，因此调度就是能够控制排队时延。简单来讲，我给你的题目是计算出offset以完成无等待传输（即排队时延为0），这样最简明易懂。更复杂的就是你可以有目的的让某些流延迟，以传输更为紧急的流量。</span><br><span class="line"></span><br><span class="line">Q:那我们目前是不需要考虑优先等级吗，先满足能正常调度，然后做出展示就好了？</span><br><span class="line">A:目前先不考虑，这个在之后的细节丰富中增加。例如说当网络负载变大时，低优先级的受到影响，但是依然能保持高优先级的传输。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TSN&quot;&gt;&lt;a href=&quot;#TSN&quot; class=&quot;headerlink&quot; title=&quot;TSN&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/342289546&quot;&gt;TSN&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;名词解释&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="笔记" scheme="https://jayerine.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="TSN" scheme="https://jayerine.top/tags/TSN/"/>
    
    <category term="网络" scheme="https://jayerine.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理 第二章</title>
    <link href="https://jayerine.top/2024/02/06/b7e90535f5c5/"/>
    <id>https://jayerine.top/2024/02/06/b7e90535f5c5/</id>
    <published>2024-02-06T04:00:21.561Z</published>
    <updated>2024-02-06T04:00:21.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章：运算方法和运算器"><a href="#第二章：运算方法和运算器" class="headerlink" title="第二章：运算方法和运算器"></a>第二章：运算方法和运算器</h1><h2 id="数据与文字的表示方式"><a href="#数据与文字的表示方式" class="headerlink" title="数据与文字的表示方式"></a>数据与文字的表示方式</h2><h3 id="真值和机器数"><a href="#真值和机器数" class="headerlink" title="真值和机器数"></a>真值和机器数</h3><p>数据表示需要考虑的因素：</p><blockquote><ol><li>数据的类型</li><li>可能遇到的数值范围</li><li>数值精确度</li><li>数据存储和运算的硬件代价</li></ol></blockquote><p>数据的表示格式：</p><blockquote><ol><li>定点格式</li><li>浮点格式</li></ol></blockquote><p>真值： 现实中真实的数值<br>机器数： 计算机中用0和1组合表示的数值<br>定点数：固定小数点的未至表达数值的机器数  </p><ul><li>定点整数：将小数点固定在机器数的最右侧表达的整数  </li><li>定点小数：将小数点固定在机器数的最左侧表达的小数</li></ul><p>浮点数：小数点浮动表达的实数<br>无符号数：只表达0和正整数的定点整数<br>有符号数：表达负整数、0和正整数的定点整数  </p><ul><li>符号位需要占用一个位，常用机器的最高位  </li><li>0表示正数，1表示负数  </li><li>具有原码、反码、补码、移码</li></ul><h3 id="无符号数与定点数的表示"><a href="#无符号数与定点数的表示" class="headerlink" title="无符号数与定点数的表示"></a>无符号数与定点数的表示</h3><p>没有符号位，使用全部字长来表示数值大小<br>举例：</p><blockquote><p>字长N&#x3D;8时，编码00000000<del>11111111<br>取值范围： 0</del>255（2<sup>8</sup>-1）</p></blockquote><p>定点表示：约定机器中所有数据的小数点位置是固定不变的。通常将数据表示成纯小数或者纯整数。<br>定点数x&#x3D;x<sub>0</sub>x<sub>1</sub>x<sub>2</sub>……x<sub>n</sub>表示如下（x<sub>0</sub>表示符号位，0正1负）<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/afc38de8f86b43c5a36f7fddb7d56dbc.png" alt="定点小数和定点正数"><br>举例：<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/cdcca528f3f445dcb7c9d839e9200da9.png" alt="举例"></p><p><strong>定点小数的取值范围</strong><br>纯小数的表示范围为：<br>x<sub>1</sub>x<sub>2</sub>x<sub>3</sub>……x<sub>n</sub>各位均为0时最小，各位均为1时最大，x<sub>0</sub>为符号位</p><blockquote><p>0 ≤ |x| ≤ 1 - 2<sup>-n</sup></p></blockquote><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/2ca8aa9ef1114ef98908e928bc574586.png" alt="举例"><br><strong>定点整数</strong>的表示范围：<br>纯整数的表示范围为：<br>x<sub>1</sub>x<sub>2</sub>x<sub>3</sub>……x<sub>n</sub>各位均为0时最小，各位均为1时最大，x<sub>0</sub>为符号位</p><blockquote><p>0 ≤ |x| ≤ 2<sup>n</sup> - 1<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/80128bad07f54b6a94e18207909265ec.png" alt="举例"></p></blockquote><p>目前计算机中多采用定点纯整数表示，因此将定点数的运算简称为<strong>整数运算</strong></p><p>既然定点数有大小范围，那我们如何用定点数表示非常大的数和非常小的数呢？<br>我们可以引入比例因子：<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/0cb749db0389413994a4cdae51096663.png" alt="举例"></p><p>优点:方法简单，计算方便<br>缺点:表示数字的范围有限，要表示大或小的数字必须使用很多比特<br>大数量级数据的表示：  </p><ul><li>定点计算机间接表示:运算前按一定的固定比例(比例因子)缩放</li><li>运算后再用幂方式</li></ul><h3 id="浮点数的表示方法"><a href="#浮点数的表示方法" class="headerlink" title="浮点数的表示方法"></a>浮点数的表示方法</h3><p>把一个数的有效数字和数的范围在计算机的一个存储单元中分别予以表示。<br>数的小数点位置随比例因子的不同而在一定范围内自由移动。</p><p>一个十进制数N可以写成：</p><blockquote><p>N &#x3D; 10<sup>e</sup>×M</p></blockquote><p>则，一个R进制数N可写成：</p><blockquote><p>N &#x3D; R<sup>e</sup>× M</p></blockquote><p>M：尾数<br>e：指数<br>R：基数</p><p><strong>阶码和尾数</strong><br><code>阶码</code>：表达指数部分。用整数形式表示，指明小数点在数据中的位置，决定浮点数的<strong>表示范围</strong>。<br><code>尾数</code>：用定点小数表示，给出有效数字的位数，决定了浮点数的<strong>表示精度</strong>。</p><p><img src="https://s1.ax1x.com/2023/03/06/ppZ1nJJ.png" alt="浮点数的表示"><br>十进制数串的表示方法（非压缩型<br>）：<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/dc325918f27d4850b945e771c256b56e.png" alt="十进制数串的表示方法"><br><strong>BCD码</strong><br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/5b969734637e4a58bfc5d7ae0886c8a4.png" alt="BCD码"><br>二十进制编码部分方案<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/7cf7be5932fe4187b564292e827609fb.png" alt="二十进制编码部分方案"><br>二十进制有权码：<br>对于有权码，将每位的数码与相应的位权相乘，再求和，就可以得到它所代表的十进制数值。<br>8421码实现加减运算时的修正规则：</p><blockquote><ol><li>未超出9（1001），不进行修正</li><li>超出9（1001），不超过16（10000），加6修正，使它向高一组产生进位，省去最高位。</li><li>超出16（10000），加6修正。</li></ol></blockquote><p><strong>余三码</strong><br>余三码是在8421码的基础上，把每个代码都加上0011而形成的。<br>普通8421码的加法器仍能为余三码加法器直接利用，具体规则如下：</p><blockquote><ol><li>若两个十进制数的余三码相加，如果结果不产生进位，则从所得和值减去0011，便得十进制位和的余三码。</li><li>若两个十进制的余三码相加，如果结果有进位，则其进位正确，但仍需将所得值加上0011.才求的十进制和的余三码。</li></ol></blockquote><p><strong>格雷码</strong><br>格雷码的编码规则是使相邻的两个代码，只有一个二进制的状态不同，其余三个二进制位必须有相同状态。<br>优点：从一个编码变到下一个相邻编码时，只有一个位的状态发生变化，有利于保证代码变换的连续性。在模拟&#x2F;数字转换和产生节拍电位等应用场合特别有用。</p><h3 id="数的机器码表示"><a href="#数的机器码表示" class="headerlink" title="数的机器码表示"></a>数的机器码表示</h3><p>把符号位和数值位一起编码来表示相应的数。</p><ul><li>原码  </li><li>补码  </li><li>反码  </li><li>移码</li></ul><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/%E6%95%B4%E5%90%88.jpg" alt="四种码"></p><h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p>定点整数的原码形式为x<sub>0</sub>x<sub>1</sub>x<sub>2</sub>……x<sub>n</sub>（x<sub>0</sub>为符号位）<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/183bf68e7279486c9e48e62289d21d51.png" alt="在这里插入图片描述">举例：<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/86dad7279c3c46cb8b8341f5dd4f0b1a.png" alt="在这里插入图片描述">定点小数的原码形式为x<sub>0</sub>x<sub>1</sub>x<sub>2</sub>……x<sub>n</sub>（x<sub>0</sub>为符号位）<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/3a1bf91679574ea4907fb7cfde14235e.png" alt="在这里插入图片描述"><br>举例：<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/9b02a282ddec4fb38fe423d61fbc7622.png" alt="在这里插入图片描述"><br>原码的表示范围：<br><img src="https://img-blog.csdnimg.cn/ba8e3956a6f44b1e80d11ffebd672b0f.png" alt="在这里插入图片描述"><strong>原码总结</strong></p><ol><li>原码为符号位加上数的绝对值，0正1负。</li><li>原码0有两个编码，+0和-0编码不同</li><li>原码表示简单，易于同真值之间进行转换。</li><li>原码乘除运算规则简单</li><li>原码加减运算负责<br>当两数相加时，同号则相加；如果是异号则相减。而在进行减法运算时，还要比较绝对值的大小，然后大数减去小数，最后还要给结果选择符号。</li></ol><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>模的概念：<br>计算机中运算器、寄存器、计数器都有一定的位数，不可能容纳无限大的任意数。当运算结果超出实际的最大表示范围，就会发生溢出，此时所产生的<strong>溢出量</strong>就是<strong>模</strong>(module)。<br>模定义为<strong>一个计量器的容量</strong>。如：一个4位的计数器它的计数值为0~15。当计数器计满15之后再加1，这个计数器就发生溢出，其溢出量为16，模等于16。定点小数的溢出量为2，即以2为模；<br>一个字长为n+1位的定点整数的溢出量为2<sup>n+1</sup>,即以2<sup>n+1</sup>为模。</p><p>定点整数的补码形式：x<sub>0</sub>x<sub>1</sub>x<sub>2</sub>……x<sub>n</sub>（x<sub>0</sub>为符号位）<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/7698b812aa3d4792968763d337e2cb8d.png" alt="定点整数的补码形式"><br>举例：<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/f5a2e96acc1f4ebba3589371b66ca175.png" alt="举例"></p><p>定点小数的补码形式：<br><img src="https://s1.ax1x.com/2023/03/10/ppnbpRI.png" alt="定点小数的补码形式"></p><p>补码与真值：<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/02c5f6d133cf4fb18fdd660db0eb4134.png" alt="补码与真值"><br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/6166862f331e47559b2092e7c6b196b9.png" alt="补码与真值推导"><br>举例：<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/a106f050030b4b8d97a279538253954f.png" alt="举例"><br>定点整数的补码表示：<br>有符号整数在计算机中默认采用补码。  </p><ul><li>最高位表示符号，0正1负  </li><li>正数补码：直接表示数值大小（&#x3D;原码&#x3D;无符号数）  </li><li>负数补码：将对应的正数原码取反加1</li></ul><p>举例：<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/679e1debdd4a4eaba2074f65e692e2c3.png" alt="举例"></p><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/082d78608bea4b9ebc426b1bb15afba4.png" alt="数值范围"><br>负数求补:<br>负数真值“取反加一”得到机器数补码<br>负数补码“取反加一”得到负数真值</p><p>负数求补运算，等效于用带借位的0做减法</p><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/ee9e52a70c45492ba6b60b7d9bd3885a.png" alt="举例"><br><strong>补码的特点</strong></p><ol><li>补码最高一位为符号位，0正1负</li><li>补码零具有<strong>唯一</strong>编码</li><li>补码的加减运算规则简单<br>最高位参与运算，与其他位一样对待</li></ol><h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p>反码：二进制的各位数码0变1，1变0<br>有符号整数的反码：</p><ol><li>最高位表示符号，0正1负</li><li>正数反码：直接表示数值大小（&#x3D;原码&#x3D;补码）</li><li>负数反码：<strong>将原码符号位不变其他位取反</strong></li></ol><p><img src="https://s1.ax1x.com/2023/03/10/ppnHvIH.png" alt="反码"><br>例题：<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/bbd7be2f64464893ba64b1799adde98c.png" alt="例题"><br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/1678876587421.jpg" alt="例题"></p><p>反码和补码的关系：<br>同一个负数的补码和反码只在最低有效比特上差1<br>$[X]<em>{补}&#x3D;[X]</em>{反}+2^{-n}$</p><h4 id="机器码右移位"><a href="#机器码右移位" class="headerlink" title="机器码右移位"></a>机器码右移位</h4><p>原则：移位时应保持移位前后机器码的对应关系与真值移位相同</p><ul><li>每右移一位，真值的绝对值减为1&#x2F;2</li></ul><p>原码:符号位固定在最高位，左边空出的数值位补<strong>0</strong><br>补位和反码:符号位固定在最高位，左边空出的数值位补<strong>符号位</strong></p><p>例如：$[X]<em>{补}&#x3D;1.01001110$<br>    &#x3D;&gt; $[X&#x2F;2]</em>{补}&#x3D;1.10100111$ </p><h4 id="补码位数扩展"><a href="#补码位数扩展" class="headerlink" title="补码位数扩展"></a>补码位数扩展</h4><p>原则：扩展后真值不变</p><ul><li>定点纯整数<br>补码：符号位固定在最高位，左边空出的数值补<strong>符号位</strong>  </li><li>定点纯小数<br>补码：右边空出的数值位补<strong>0</strong></li></ul><h4 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h4><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/70afc2a36cf9444aad2b652f515f01da.png" alt="移码"><br>移码符号位表示的规律与原码、补码、反码相反<br>移码与补码仅差符号位</p><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/a2668cc7a6034320a9c319f6c92c77b3.png"></p><h2 id="定点加法、减法运算"><a href="#定点加法、减法运算" class="headerlink" title="定点加法、减法运算"></a>定点加法、减法运算</h2><h3 id="补码加法"><a href="#补码加法" class="headerlink" title="补码加法"></a>补码加法</h3><p>补码加法的公式为：<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/1678702135748.png" alt="在这里插入图片描述"><br>在模2<sup>n+1</sup>意义下，任意两数的补码之和等于改两数之和的补码。</p><p>例题：<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/f995ad2536f84c75899b29d94ed40e62.png" alt="在这里插入图片描述"><br><strong>补码加法的特点：</strong></p><ol><li>符号位要作为数的一部分一起参加运算</li><li>要在模2<sup>n+1</sup>的意义下相加，即超过模的进位要丢掉</li></ol><h3 id="补码减法"><a href="#补码减法" class="headerlink" title="补码减法"></a>补码减法</h3><p>补码减法公式是：<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/4.jpg" alt="补码减法公式"><br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9B%BE%E7%89%87/5.png" alt="例题"></p><h3 id="溢出概念与检验方法"><a href="#溢出概念与检验方法" class="headerlink" title="溢出概念与检验方法"></a>溢出概念与检验方法</h3><p>在定点整数机器中，n+1位数的表示范围为$-2^{n}&lt;X&lt;2^{n+1}-1$<br>在定点小数机器中，n+1位数的表示范围为$-1&lt;X&lt;1-2^{-n}$<br>在运算过程中如出现大于绝对值的现象，称为<strong>溢出</strong><br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/9d17381548d14a1e8b8f44cb7da6cf0c.png" alt="溢出"><br>两个正数相加，结果大于机器所能表示的最大正数，称为<strong>正溢</strong><br>两个负数相加，结果小于机器所能表示的最小负数，称为<strong>负溢</strong></p><p>例题：<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/9d80b297ff0b49ac91f38919418af843.png" alt="例题"><br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/1d27cf6e21314edab527e331a81a4fb9.png" alt="例题"></p><p><strong>溢出原因分析：</strong><br>分析可知，当最高有效数值位的运算进位与符号位的运算进位<strong>不一致</strong>时，将产生运算<strong>溢出</strong></p><h3 id="溢出检测方法"><a href="#溢出检测方法" class="headerlink" title="溢出检测方法"></a>溢出检测方法</h3><h4 id="单符号位法"><a href="#单符号位法" class="headerlink" title="单符号位法"></a>单符号位法</h4><p>当<code>最高有效位有进位而符号位无进位</code>时，产生<strong>正溢</strong><br>当<code>最高有效位无进位而符号位有进位</code>时，产生<strong>负溢</strong><br>溢出检测逻辑表达式：$V&#x3D;C_{f}\oplus C_{0}$</p><h4 id="变形补码法"><a href="#变形补码法" class="headerlink" title="变形补码法"></a>变形补码法</h4><p><strong>双符号位法</strong>，称为“变形补码”或 模2<sup>n+2</sup>补码<br>可使模2<sup>n+2</sup>补码所能表示的数的范围扩大一倍<br>变形补码定义为：<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/a71caa4cf27a4879bd314f58e7988fc1.png" alt="变形补码定义"><br>计算时：</p><ol><li>两个符号位都看作数码一样参加运算，两数进行2<sup>n+2</sup>为模的加法，即最高符号位上产生进位要丢掉 ，模2<sup>n+2</sup>补码相加的结果，不论谥出与否，最高符号位始终指示正确的符号。</li><li>当以变形补码运算，运算结果的二符号位相异时，表示溢出，溢出类型和最高符号位有关；相同时，表示未溢出，没有发生溢出的情况下，正数符号位为00，负数符号位为11。</li><li>溢出逻辑表达式为$V&#x3D;S_{f1}⊕S_{f2}$,其中$S_{f1}$和$S_{f2}$分别为最高符号位和第二符号位。此逻辑表达式可用异或门实现。</li></ol><p>例题：<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/095a2a9f514d45a7a0ebe9b5ee27a511.png" alt="例题"><br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/584ca630ce06402ca7a4d975f0457d71.png" alt="例题"><br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/e1247e1dedd54dec97651072d8f7ef1c.png" alt="例题"><br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/e1c3fa98f0cc428690a193ecc58a9520.png" alt="例题">  </p><h3 id="基本二进制加法-减法器"><a href="#基本二进制加法-减法器" class="headerlink" title="基本二进制加法 &#x2F; 减法器"></a>基本二进制加法 &#x2F; 减法器</h3><h4 id="一位全加器"><a href="#一位全加器" class="headerlink" title="一位全加器"></a>一位全加器</h4><p>两个二进制数字A<sub>i</sub>，B<sub>i</sub>和一个进位输入C<sub>i</sub>相加，产生一个和输出S<sub>i</sub>，以及一个进位输出C<sub>i+1</sub></p><p><img src="https://img-blog.csdnimg.cn/4ca48b0f6d8f457abbfda75cb4f36249.png" alt="真值表"></p><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/1678711346947.png" alt="一位全加器"></p><p>根据真值表，三个输入端和两个输出端可按如下逻辑方程进行联系：<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/cfed855397a34cb1aa972da17465576c.png" alt="逻辑方程"></p><p>门电路的延迟时间：<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/1678704271330.png" alt="门电路的延迟时间"><br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/1678711135891.jpg" alt="门电路的延迟时间"></p><h4 id="串行加法器"><a href="#串行加法器" class="headerlink" title="串行加法器"></a>串行加法器</h4><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/20180327105153710.png" alt="串行加法器"><br>在串行加法器中，只有一个全加器，数据逐位串行送入加法器进行运算，如图所示：图中FA是全加器，A、B是两个具有右移功能的寄存器，C为进位触发器。<br>由移位寄存器从低位到高位逐位串行提供操作数相加。如果操作数长n位，加法就要分n次进行，每次产生一位和，并串行地送回A寄存器。进位触发器用来寄存进位信号，以便参与下一次的运算。</p><h4 id="串行进位加法器"><a href="#串行进位加法器" class="headerlink" title="串行进位加法器"></a>串行进位加法器</h4><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/1678721918505.png" alt="串行进位加法器"><br>并行加法器中的每一个全加器都有一个从低位送来的进位输入和一个传送给高位的进位输出。通常将传递进位信号的逻辑线路连接起来构成的进位网络称为进位链。每一位的进位表达式为：<br>$C_i&#x3D;A_iB_i+(A_i⊕B_i)C_{i-1}$</p><h4 id="串行进位并行补码加减法器"><a href="#串行进位并行补码加减法器" class="headerlink" title="串行进位并行补码加减法器"></a>串行进位并行补码加减法器</h4><p>n个1位的<strong>全加器(FA)<strong>可级联成一个n位的</strong>行波进位加减法器</strong><br>M为<strong>方式控制输入线</strong>：<br>当M&#x3D;0时，作加法(A+B)运算；<br>当M&#x3D;1时，作减法(A-B)运算，相当于在加法器的最低位上加1。转化成[A]<sub>补</sub> + [-B]<sub>补</sub>运算，求补过程由¬[B]<sub>补</sub>+1来实现，起始进位连接到M上。<br>单符号位法的溢出检测逻辑；当C<sub>n</sub>=C<sub>n-1</sub>时，运算无溢出<br>而当C<sub>n</sub>≠C<sub>n-1</sub>时，运算有溢出，经异或门产生溢出信号。<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/30ed56936c424ebba16e061664b61f6c.png" alt="串行进位并行补码加减法器"><br><strong>延迟时间计算：</strong></p><blockquote><p>$t&#x3D;0: A_0\thicksim A_{n-1}, b_0\thicksim B_{n-1}, C_0&#x3D;M$ 有效<br>$t&#x3D;3T: B_i’ &#x3D; (B_i\enspace xor\enspace M)$ 有效<br>$t&#x3D;6T: B_i’\enspace xor\enspace A_i$ 有效<br>$t&#x3D;6T + 2T: C1$ 有效<br>$t&#x3D;6T + 4T: C2$ 有效<br>$t&#x3D;6T + 6T: C3$ 有效<br>……<br>$t&#x3D;6T + 2(n-1)t: Cn-1$ 有效<br>$t&#x3D;6T + 2nT: Cn$ 有效<br>$t&#x3D;6T + 2(n-1)t + 3T&#x3D;7T + 2nT: S_{n-1}$ 有效（还需要使用一个异或门）<br>$t&#x3D;9T + 2nT:$ 溢出有效</p></blockquote><p>考虑溢出检测的延迟: $t_a&#x3D;(2n + 9)T$<br>不考虑溢出检测的延迟: $t_a&#x3D;(2n + 7)T$</p><h4 id="进位产生和传递函数"><a href="#进位产生和传递函数" class="headerlink" title="进位产生和传递函数"></a>进位产生和传递函数</h4><p>并行加法器进位链的基本逻辑关系：<br>$$C_{i+1}&#x3D;A_iB_i+(A_i⊕B_i)C_i$$<br>令$G_i&#x3D;A_iB_i$为进位产生函数（本地进位）<br>令$P_i&#x3D;A_i⊕B_i$为进位传递函数（进位条件）<br>$P_iC_i$为传送进位（条件进位）<br>于是有：<br>$$C_{i+1}&#x3D;G_i+P_iC_i$$<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/cbcfd46055d0e97f2bd9435f913ca23.jpg" alt="进位产生和传递函数"></p><h4 id="4位先行进位部件-CLA"><a href="#4位先行进位部件-CLA" class="headerlink" title="4位先行进位部件(CLA)"></a>4位先行进位部件(CLA)</h4><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/1678760254859.jpg" alt="4位先行进位部件"></p><h4 id="16位单极分组先行进位并行加法器"><a href="#16位单极分组先行进位并行加法器" class="headerlink" title="16位单极分组先行进位并行加法器"></a>16位单极分组先行进位并行加法器</h4><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/f34473f4e15b7eadd0fe8ee9a9eab7b.jpg"><br>若使用16位串行进位加法器，则总延迟时间为<br>$t&#x3D;9T+2nT&#x3D;9T+2×16T&#x3D;41T$</p><h4 id="多级分组先行进位方式"><a href="#多级分组先行进位方式" class="headerlink" title="多级分组先行进位方式"></a>多级分组先行进位方式</h4><p>将若干小组编成一大组  </p><ul><li>小组内为先行进位  </li><li>同一大组内的各小组之间也采用并行进位</li></ul><p>一个加法器有一个或多个大组</p><ul><li>如果有多个大组，每个大组可以既可以使用串行进位，也可以使用并行进位、</li></ul><h4 id="两级分组16位先行进位加法器"><a href="#两级分组16位先行进位加法器" class="headerlink" title="两级分组16位先行进位加法器"></a>两级分组16位先行进位加法器</h4><p>先计算 $P^*$ 和 $G^*$，求出进位，再做加法<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/1678762806809.jpg" alt="两级分组16位先行进位加法器"></p><ul><li><p>组间先行进位逻辑公式<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/11fc46f15f79741794136659c58f240.jpg" alt="组间先行进位逻辑公式">  </p><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/167876825az4369.png" alt="组间先行进位逻辑公式"></p></li></ul><h4 id="进位选择加法器"><a href="#进位选择加法器" class="headerlink" title="进位选择加法器"></a>进位选择加法器</h4><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/1678768885499.png" alt="进位选择加法器"></p><h2 id="定点运算器的组成"><a href="#定点运算器的组成" class="headerlink" title="定点运算器的组成"></a>定点运算器的组成</h2><ul><li>逻辑运算：<br>只在无符号数之间进行逻辑运算  </li><li>逻辑运算和算数运算的区别：<br>逻辑运算只在对应的位之间进行<br>各位之间没有进位&#x2F;借位关系  </li><li>计算机中的逻辑运算：逻辑非，逻辑加，逻辑乘，逻辑异</li></ul><h3 id="多功能算术-逻辑运算单元-ALU"><a href="#多功能算术-逻辑运算单元-ALU" class="headerlink" title="多功能算术&#x2F;逻辑运算单元(ALU)"></a>多功能算术&#x2F;逻辑运算单元(ALU)</h3><h4 id="四位多功能ALU：74181"><a href="#四位多功能ALU：74181" class="headerlink" title="四位多功能ALU：74181"></a>四位多功能ALU：74181</h4><p><strong>引脚介绍</strong><br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/93b947b96ec2d3128d11a8bd39a7403.png" alt="74ls181截图"><br>74ls181芯片总共有22个引脚。</p><ul><li><p>数据引脚</p><ul><li>8个数据输入端，A0m、A1n、A2n、A3n，B0n、B1n、B2n、B3n，（其中A3和B3是高位）。</li><li>4个二进制输出端F0、F1、F2、F3，以四位二进制形式输出运算的结果。</li><li>CN端处理进入芯片前进位值，CN4记录运算后的进位。</li><li>GN先行进位产生端。PN先行进位传递函数。</li></ul></li><li><p>控制引脚</p><ul><li>4个控制端，S0、S1、S2、S3，控制两个四位输入数据的运算，例如加、减、与、或。</li><li>M控制芯片的运算方式，包括算术运算和逻辑运算。</li></ul></li></ul><p><strong>功能表</strong><br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/31148fc43db4b942926d684c4599a24.png" alt="功能表"></p><p>补充：<br><strong>算术运算操作</strong>是用<strong>补码</strong>表示法来表示的<code>加</code>是指<code>算术加</code>，运算时要考虑进位。<br>符号“+ ”是指“逻辑加。<br>减法是用补码方法进行的，其中数的反码是内部产生的，而结果输出“A减B减1”，因此做减法时需在最末位产生一个强迫进位(加1)，以便产生<code>A减B</code>的结果。<br><code>A=B</code>输出端可指示两个数相等，因此它与其他ALU的<code>A=B</code>输出端按“与”逻辑连接后，可以检测两个数的相等条件。  </p><h4 id="超前进位产生器：74182"><a href="#超前进位产生器：74182" class="headerlink" title="超前进位产生器：74182"></a>超前进位产生器：74182</h4><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/1678779945119.jpg" alt="74182"></p><h4 id="三级分组“并-并-串”先行进位并行ALU"><a href="#三级分组“并-并-串”先行进位并行ALU" class="headerlink" title="三级分组“并-并-串”先行进位并行ALU"></a>三级分组“并-并-串”先行进位并行ALU</h4><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9B%BE%E7%89%87/f75b9faab8eab0f752adb4bb24debe3.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第二章：运算方法和运算器&quot;&gt;&lt;a href=&quot;#第二章：运算方法和运算器&quot; class=&quot;headerlink&quot; title=&quot;第二章：运算方法和运算器&quot;&gt;&lt;/a&gt;第二章：运算方法和运算器&lt;/h1&gt;&lt;h2 id=&quot;数据与文字的表示方式&quot;&gt;&lt;a href=&quot;#数据与</summary>
      
    
    
    
    <category term="专业课" scheme="https://jayerine.top/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="计组" scheme="https://jayerine.top/tags/%E8%AE%A1%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 第一章 引言</title>
    <link href="https://jayerine.top/2024/02/06/812f344402b9/"/>
    <id>https://jayerine.top/2024/02/06/812f344402b9/</id>
    <published>2024-02-06T04:00:21.561Z</published>
    <updated>2024-02-06T04:00:21.561Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%80%E7%AB%A0.png"></p><h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><p><strong><font color=#fea401>Computer network（计算机网络）：</font></strong></p><ul><li><p>一组互联的计算机，通过同一种技术自主交换信息</p></li><li><p>可看见实际的计算机情况，即<font color=#FF6347>可见，不透明</font></p></li><li><p>计算机网络不是Internet因特网（因特网是一种特殊的覆盖全球的计算机网络）</p></li><li><p>计算机网络不是WWW万维网（万维网是建立在因特网之上的分布式系统）</p></li><li><p><strong><font color=#ff8b61>计算机网络的组成：</font></strong></p><ul><li><p>计算机&#x2F;主机&#x2F;端系统（数据通信的源端和数据端）</p></li><li><p>通信链路（分为有线和无线）</p></li><li><p>交换机&#x2F;路由器，作为Node节点</p></li></ul></li></ul><p><strong><font color=#fea401>Distributed system（分布式系统）：</font></strong></p><ul><li><p>一组独立的计算机，对外是一个统一的系统，是<font color=#FF6347>不可见，透明</font>的</p></li><li><p>在计算机网络的基础上加入中间件（一种应用于分布式系统的基础软件），来实现这个模型</p></li><li><p>典型的分布式系统：万维网</p></li></ul><h2 id="网络硬件"><a href="#网络硬件" class="headerlink" title="网络硬件"></a>网络硬件</h2><p><strong><font color=#fea401>计算机网络的分类方式：</font></strong></p><ul><li><p><strong><font color=#ff8b61>以传输技术分类：</font></strong></p><ul><li><p><strong><font color=#ff8aaf>广播网络：</font></strong> 向所有的目的地发送数据包，如果接收机器正确，那么接收机器就会处理数据包，否则不接收直接忽略。</p><ul><li><p>多播&#x2F;组播：向一组机器发送数据包</p></li><li><p>典型：局域网</p></li></ul></li><li><p><strong><font color=#ff8aaf>点到点网络：</font></strong> 通过访问多个中间设备，将数据包从源端传送到目的端，有时候也称为unicasting单播</p><ul><li><p>一个发送方，一个接收方</p></li><li><p>路由选择很重要</p></li></ul></li></ul><p>  <img src="https://s1.ax1x.com/2023/03/02/ppFmvOs.jpg" alt="广播网络对比点到点网络"></p></li><li><p><strong><font color=#ff8b61>以传输技术分类：</font></strong></p><ul><li><p><strong><font color=#ff8aaf>Personal area network（个域网）：</font></strong> 允许设备围绕着一个人进行通信，例如蓝牙网络</p></li><li><p><strong><font color=#ff8aaf>Local area network（局域网）：</font></strong> 将主机和边缘路由器链接起来，共享<font color=#FF6347>同一个</font>通信链路，分为有线局域网和无线局域网</p><ul><li>在大多数情况下，每台计算机与安装在天花板上的一个设备通信，这个设备，称为接入点、无线路由器或者基站,它主要负责中继无线计算机之间的数据包，还负责中继无线计算机和Internet之间的数据包</li></ul><p>  <img src="https://s1.ax1x.com/2023/03/02/ppF8ly8.jpg" alt="局域网"></p><ul><li><p><font color=#b59bfd>拓扑结构：</font>总线型或环型</p></li><li><p><font color=#b59bfd>信道分配：</font></p><ul><li><p><font color=#DA70D6>静态</font>：将时间划分成时间槽，并使用轮循算法，每台机器只能在分配给它的时间槽到来时广播。当一台机器在分配给它的时间槽到来时没有任何数据需要发送，这种静态分配算法就浪费了信道容量</p></li><li><p><font color=#DA70D6>动态</font>：按需分配，可以是集中式的，也可以是分散式的。在集中式的信道分配方法中，有一个中心实体，由这个中心实体决定接下来谁使用信道；在分散式信道分配方法中，没有一个中央实体，每台机器必须自行决定是否可以传输</p></li></ul></li></ul></li><li><p><strong><font color=#ff8aaf>Metropolitan area network（城域网）：</font></strong> 范围可覆盖一个城市，例如有线电视网</p><ul><li><font color=#b59bfd>拓扑结构：</font>树型</li></ul></li><li><p><strong><font color=#ff8aaf>Wide area network（广域网）：</font></strong> 覆盖范围较广泛的通信网，通常是一个国家、地区或者一个大陆</p><ul><li><p>专门运行用户程序的计算机称为<font color=#FF6347>主机</font>；连接这些主机的网络其余部分称为<font color=#FF6347>通信子网</font>，子网的工作是把信息从一个主机携带到另一个主机</p><ul><li><p><font color=#DA70D6>通信子网:</font></p><ul><li><p><font color=#63B8FF>传输线路：</font>负责在机器之间移动比特，它们可以是铜线、光纤，甚至无线链路</p></li><li><p><font color=#63B8FF>交换元素：</font>简称为交换机，负责连接两条或两条以上的传输线路</p></li></ul></li></ul><p>  <img src="https://s1.ax1x.com/2023/03/02/ppFy8mj.jpg" alt="通信子网"></p></li><li><p><font color=#b59bfd>拓扑结构：</font>网孔型</p></li></ul></li><li><p><strong><font color=#ff8aaf>The Internet（互联网）</font></strong></p><ul><li><p><font color=#b59bfd>Internet和internet的区别：</font></p><ul><li><p><font color=#DA70D6>internet互联网：</font>网络与网络之间所串连成的庞大网络</p></li><li><p><font color=#DA70D6>Internet因特网：</font>一种特殊的覆盖全球的互联网</p><ul><li><font color=#63B8FF>网关：</font>在硬件和软件方面提供必要的翻译，将两个或多个不同的网络连接起来并提供必要转换的机器</li></ul></li></ul></li></ul></li></ul></li></ul><p><strong><font color=#fea401>子网，网络，互联网：</font></strong></p><ul><li><p><font color=#ff8b61>子网：</font><font color=#FF6347>路由器</font>和<font color=#FF6347>通信链路</font>的集合</p></li><li><p><font color=#ff8b61>网络：</font><font color=#FF6347>子网</font>和它的<font color=#FF6347>主机</font>的结合</p></li><li><p><font color=#ff8b61>互联网：</font>不同的网络互联</p></li></ul><h2 id="网络软件"><a href="#网络软件" class="headerlink" title="网络软件"></a>网络软件</h2><p><strong><font color=#fea401>协议层次结构：</font></strong></p><ul><li><p><strong><font color=#ff8b61>网络体系结构：</font></strong> 层和协议的集合，实现的细节和接口的规范都不是体系结构的一部分</p><ul><li><p>为了降低网络设计的复杂性，绝大多数网络都组织成一个层次栈或分级栈</p></li><li><p>每一层都是一个虚拟机，的目的是向更高的层提供特定服务，每层具体实现的细节对外不可见</p></li></ul></li><li><p><strong><font color=#ff8b61>层，对等体，协议，接口</font></strong></p><p>  <img src="https://s1.ax1x.com/2023/03/02/ppFgnt1.jpg" alt="协议层次结构"></p><ul><li><p><strong><font color=#ff8aaf>协议：</font></strong> 通信双方就如何进行通信的一种约定</p></li><li><p><strong><font color=#ff8aaf>对等体：</font></strong> 不同机器上构成对应层次相同的实体，可能是软件过程、硬件设备</p></li><li><p><strong><font color=#ff8aaf>物理介质：</font></strong>  第1层的下面是物理介质，通过它进行实际的通信</p></li><li><p><strong><font color=#ff8aaf>界面&#x2F;接口：</font></strong> 定义了下层向上层提供哪些原语操作和服务</p></li></ul><p>  <img src="https://s1.ax1x.com/2023/03/02/ppFRGFA.jpg" alt="层次举例"></p></li><li><p><strong><font color=#ff8b61>5层网络</font></strong></p><p>  <img src="https://s1.ax1x.com/2023/03/02/ppFRhmF.jpg" alt="5层网络"></p><ul><li><p><strong><font color=#ff8aaf>第5层：</font></strong> 报文M由应用层产生，并交给第4层进行传输</p></li><li><p><strong><font color=#ff8aaf>第4层：</font></strong> 在报文前面加上一个头部以识别消息，并将结果传递给第3层</p><ul><li><font color=#DA70D6>头部：</font>控制信息，例如地址；在某些层中，Header还可以包含消息序号，消息大小、时间和其他控制字段</li></ul></li><li><p><strong><font color=#ff8aaf>第3层：</font></strong> 在第3层协议中传输的消息大小是有限制的，因此必须把入境消息分割成较小的单元，即<font color=#FF6347>数据包</font>或<font color=#FF6347>包</font>，并且在每个数据包前面加上第3层的头，决定使用哪条出站线路并将数据包传递到第2层</p></li><li><p><strong><font color=#ff8aaf>第2层：</font></strong> 不仅要加上一个头部还要加上一个<font color=#FF6347>尾部</font>用于差错检查，再将结果传输单元送给第1层以便进行物理传输</p></li><li><p><strong><font color=#ff8aaf>第1层：</font></strong> 把信息加载到物理介质上进行传输</p></li></ul><p>  <img src="https://s1.ax1x.com/2023/03/02/ppFf5GR.jpg" alt="实际例子"></p></li></ul><p><strong><font color=#fea401>层次设计问题：</font></strong></p><ul><li><p><strong><font color=#ff8b61>可靠性：</font></strong> 差错检测和差错修正；路由选择</p></li><li><p><strong><font color=#ff8b61>网络演进：</font></strong> 协议分层；addressing（寻址）和naming（命名）：识别发送者和接收者；internetworking（网络互联）：对消息进行拆分、传输，然后重组；可拓展性：网络规模变大时仍能工作良好</p></li><li><p><strong><font color=#ff8b61>资源分配：</font></strong> 统计复用：根据主机的短期需求变化动态共享网络带宽；流量控制，拥塞控制</p></li><li><p><strong><font color=#ff8b61>服务质量QoS：</font></strong><br>QoS包含的参数是带宽、时延、抖动、丢包率</p><ul><li><strong><font color=#ff8aaf>带宽：</font></strong> 在单位时间（一般指的是1秒钟）内能传输的数据量</li><li><strong><font color=#ff8aaf>时延：</font></strong> 一个报文或分组从一个网络的一端传送到另一个端所需要的时间。它包括了发送时延，传播时延，处理时延，排队时延。（时延&#x3D;发送时延+传播时延+处理时延+排队时延）</li><li><strong><font color=#ff8aaf>抖动：</font></strong> 如果网络发生拥塞，导致通过同一连接传输的分组延迟各不相同。抖动用来描述延迟变化的程度，也就是最大延迟与最小延迟的时间差</li><li><strong><font color=#ff8aaf>丢包率：</font></strong> 丢包率是指在网络传输过程中丢失报文的数量占传输报文总数的百分比</li></ul></li><li><p><strong><font color=#ff8b61>安全性</font></strong></p></li></ul><p><strong><font color=#fea401>面向连接和无连接服务：</font></strong></p><table><thead><tr><th></th><th><font color=#ff8b61>面向连接服务</font></th><th><font color=#ff8b61>无连接服务</font></th></tr></thead><tbody><tr><td>参考</td><td>电话系统</td><td>邮政系统</td></tr><tr><td>特点</td><td>建立连接时分配资源，预先分配资源</td><td>分配仅当数据到达，动态分配资源，接收机不需要在线</td></tr><tr><td>Qos</td><td>可靠的传输</td><td>数据会丢失，乱序或重复</td></tr><tr><td>目的地址</td><td>只有建立连接时需要完整地址，后续不用</td><td>需要完整的目的地址</td></tr><tr><td>应用</td><td>大量数据在短时间内转送到目的地</td><td>少量数据</td></tr><tr><td>包含服务类型</td><td>Reliable message stream(可靠的报文流)<br>Reliable byte stream（可靠的字节流）<br>Unreliable connection（不可靠的连接）</td><td>Unreliable datagram（不可靠的数据报）<br>Acknowledged datagram（有确认的数据报）<br>Request-reply（请求-响应）</td></tr></tbody></table><p><strong><font color=#ff8aaf>可靠的报文流和可靠的字节流的区别：</font></strong><br>可靠的字节流没有边界，而可靠的报文流则有边界<br>例如：一个发送进程向一个连接中写入了1024字节数据，然后又写入了1024字节数据。对于可靠的报文流服务，接收进程将收到两个1024字节的数据；而对于可靠的字节流服务，接收进程将可能收到一个完整的 2048 字节的数据，即不能保证上层信息的边界</p><ul><li><p><strong><font color=#ff8b61>接口和服务：</font></strong></p><ul><li><p><strong><font color=#ff8aaf>服务提供者和服务用户：</font></strong> 第n层的实体向第n+1层提供了服务，第n层称为服务提供者，第n+1层称为服务用户</p></li><li><p><strong><font color=#ff8aaf>服务访问点SAP：</font></strong> 第n层的SAP是第n+1层可以访问所提供服务的地方</p></li><li><p><strong><font color=#ff8aaf>协议数据单元PDU：</font></strong> 对等体之间通信所传输的信息，<font color=#FF6347>平常所称的包就是PDU</font>，PDU&#x3D;SDU+PCI（协议控制信息）</p></li></ul></li></ul><p><strong><font color=#fea401>服务原语：</font></strong> 同一个系统内相邻两层之间交互的信息</p><ul><li><p><strong><font color=#ff8b61>例子：</font></strong> </p><ul><li><p><strong><font color=#ff8aaf>CONNECT.request：</font></strong> 请求建立一个连接</p></li><li><p><strong><font color=#ff8aaf>CONNECT.indication：</font></strong> 通知被叫方有连接到达</p></li><li><p><strong><font color=#ff8aaf>CONNECT.response：</font></strong> 被叫方接收或拒绝呼叫</p></li><li><p><strong><font color=#ff8aaf>CONNECT.confirm：</font></strong> 告诉呼叫者是否被接受</p></li><li><p><strong><font color=#ff8aaf>DATA.request：</font></strong> 请求发送数据</p></li><li><p><strong><font color=#ff8aaf>DATA.indication：</font></strong> 通知有数据到达</p></li><li><p><strong><font color=#ff8aaf>DISCONNECT.request：</font></strong> 请求释放一个连接</p></li><li><p><strong><font color=#ff8aaf>ISCONNECT.indication：</font></strong> 通知有释放连接的请求到达</p></li></ul><p>  <img src="https://s1.ax1x.com/2023/03/02/ppkpk0e.png" alt="服务原语示例"></p></li><li><p><strong><font color=#ff8b61>简单的面向连接的服务：</font></strong></p><ul><li><strong><font color=#ff8aaf>系统调用：</font></strong> 操作系统提供给用户的API</li></ul></li></ul><table><thead><tr><th><font color=#ff8aaf>原语</font></th><th><font color=#ff8aaf>实例</font></th></tr></thead><tbody><tr><td>LISTEN</td><td>阻塞操作，等待入境连接请求</td></tr><tr><td>CONNECT</td><td>与等待中的对等实体建立连接</td></tr><tr><td>ACCEPT</td><td>接受来自对等实体的入境连接请求</td></tr><tr><td>RECEIVE</td><td>阻塞操作，等待入境报文</td></tr><tr><td>SEND</td><td>给对等实体发送一个报文</td></tr><tr><td>DISCONNECT</td><td>终止一个连接</td></tr></tbody></table><p><strong><font color=#fea401>服务和协议的关系：</font></strong> </p><ul><li><p><strong><font color=#ff8b61>服务（垂直）：</font></strong> 定义了<font color=#FF6347>某一层向它上一层</font>提供的一组原语（操作），但完全没有说明这些操作是如何实现的；与两层之间的接口有关，下层向上层提供服务</p></li><li><p><strong><font color=#ff8b61>协议（水平）：</font></strong> 规定了<font color=#FF6347>同一层上对等实体</font>之间所交换的数据包或者报文的格式和含义；<font color=#FF6347>服务通过协议实现它的定义</font></p></li><li><p>服务和协议是完全分开的，不更改服务的前提下，协议可以随意修改</p></li></ul><h2 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h2><p><strong><font color=#fea401>OSI参考模型：</font></strong></p><p><img src="https://s1.ax1x.com/2023/03/03/ppkmgC8.jpg" alt="OSI模型"></p><ul><li><p><strong><font color=#ff8b61>物理层：</font></strong> 在信道上传送原始的比特流</p></li><li><p><strong><font color=#ff8b61>数据链路层：</font></strong> 将一个原始的传输设施转变成一条没有漏检传输错误的线路</p><ul><li><p>发送方将输入的数据拆分成数据帧，然后顺序发送这些数据帧；如果服务是可靠的，则接收方必须给发送方发回一个确认帧</p></li><li><p><font color=#ff8aaf>流量控制：</font>避免一个快速发送方用数据“淹没”一个慢速接收方</p></li></ul></li><li><p><strong><font color=#ff8b61>网络层：</font></strong> 控制子网的运行</p><ul><li><p><font color=#ff8aaf>路由选择：</font>根据路由表决定转发到哪个链路</p></li><li><p><font color=#ff8aaf>拥塞控制</font></p></li><li><p><font color=#ff8aaf>异构网络互联：</font>技术不同的网络互联</p></li><li><p>在广播网络当中，路由问题比较简单</p></li></ul></li><li><p><strong><font color=#ff8b61>传输层：</font></strong> 接收来自上一层的数据，在必要的时候把这些数据分割成较小的单元，然后把这些数据单元传递给网络层，并且确保这些数据单元正确地到达另一端</p><ul><li><p>传输层还决定了向会话层提供哪种类型的服务</p><ul><li><p>一个完全无错的点到点信道（最为常见）</p></li><li><p>传输独立的报文但不保证传送的顺序</p></li><li><p>将报文广播给多个目标节点</p></li></ul></li></ul></li><li><p><strong><font color=#ff8b61>会话层：</font></strong> 允许不同机器上的用户建立会话</p><ul><li><p><font color=#ff8aaf>对话控制：</font>记录该由谁来传递数据</p></li><li><p><font color=#ff8aaf>令牌管理：</font>禁止双方同时执行同一个关键操作</p></li><li><p><font color=#ff8aaf>同步功能：</font>在一个长传输过程中设置一些断点，以便在系统崩溃之后还能恢复到崩溃前的状态继续运行</p></li></ul></li><li><p><strong><font color=#ff8b61>表示层：</font></strong> 规定传输信息的语法和语义</p><ul><li>交换的数据结构必须以一种抽象的方式来定义</li></ul></li><li><p><strong><font color=#ff8b61>应用层：</font></strong> 包含了用户通常需要的各种各样的协议</p><ul><li>超文本传输协议HTTP</li></ul></li></ul><p><strong><font color=#ff8b61>OSI模型的核心是如下3个概念：</font></strong> </p><ul><li><p><strong><font color=#ff8aaf>服务：</font></strong> 某层实体对于上一层实体的支持</p></li><li><p><strong><font color=#ff8aaf>接口：</font></strong> 某层实体对于上一层实体提供的原语操作</p></li><li><p><strong><font color=#ff8aaf>协议：</font></strong> 两个对等体之间进行通信所必须遵守的原则</p></li></ul><p><strong><font color=#fea401>TCP&#x2F;IP参考模型：</font></strong></p><p><img src="https://s1.ax1x.com/2023/03/03/ppkK3Hs.jpg" alt="两个参考模型对比"></p><ul><li><p><strong><font color=#ff8b61>链路层：</font></strong> 描述了链路必须完成什么功能才能满足无连接的互联网络层的需求；不是真正意义上的一个层，而是主机与传输线路之间的一个接口</p></li><li><p><strong><font color=#ff8b61>互联网层：</font></strong> 将整个网络体系结构贯穿在一起，是基于无连接互连层的分组交换网络</p><ul><li><p><font color=#ff8aaf>因特网协议IP：</font>正式的数据包格式和协议</p></li><li><p>互联网层的工作是把IP包送到它们应该去的地方</p><ul><li><p>分组路由，转发IP包</p></li><li><p>拥塞控制</p></li></ul></li></ul></li><li><p><strong><font color=#ff8b61>传输层：</font></strong> 允许源主机和目标主机上的对等实体进行对话，是在TCP&#x2F;IP模型中位于互联网层之上的那一层</p><ul><li><p>定义了两个端到端的传输协议：</p><ul><li><p><font color=#DA70D6>传输控制协议TCP：</font><font color=#FF6347>可靠的、面向连接</font>的协议，允许从一台机器发出的字节流正确无误地交付到互联网上的另一台机器</p><ul><li><p>把输入的字节流分割成离散的报文，并把每个报文传递给互联网层</p></li><li><p>接收TCP进程把收到的报文重新装配到输出流中</p></li><li><p>流量控制</p></li></ul></li><li><p><font color=#DA70D6>用户数据报协议UDP：</font><font color=#FF6347>不可靠的、无连接</font>协议</p><ul><li><p>适用于那些不想要TCP的有序性或流量控制功能，而宁可自己提供这些功能的应用程序</p></li><li><p>应用于及时交付比精确交付更加重要的应用，比如传输语音或者视频</p></li></ul></li></ul></li></ul></li><li><p><strong><font color=#ff8b61>应用层：</font></strong> 包含了所有的高层协议，以及所需的任何会话和表示功能</p></li></ul><p><img src="https://s1.ax1x.com/2023/03/04/ppA6B26.jpg" alt="TCP/IP模型"></p><p><img src="https://s1.ax1x.com/2023/03/04/ppAcPZ4.png" alt="TCP/IP模型以及一些协议"></p><p>……未完待续♬</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%80%E7%</summary>
      
    
    
    
    <category term="专业课" scheme="https://jayerine.top/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="计网" scheme="https://jayerine.top/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理 第四章</title>
    <link href="https://jayerine.top/2024/02/06/0364e15ddae1/"/>
    <id>https://jayerine.top/2024/02/06/0364e15ddae1/</id>
    <published>2024-02-06T04:00:21.561Z</published>
    <updated>2024-02-06T04:00:21.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四章-指令系统"><a href="#第四章-指令系统" class="headerlink" title="第四章 指令系统"></a>第四章 指令系统</h1><h2 id="指令系统的发展和性能要求"><a href="#指令系统的发展和性能要求" class="headerlink" title="指令系统的发展和性能要求"></a>指令系统的发展和性能要求</h2><h3 id="指令的概念"><a href="#指令的概念" class="headerlink" title="指令的概念"></a>指令的概念</h3><p><strong>计算机的程序是由一系列有序且有一定意义的指令组成的</strong><br><code>指令</code>：命令计算机执行某种基本操作的二进制代码串</p><ul><li>每条指令可以完成一个独立的算术运算或逻辑运算操作，或者数据传送等基本操作  </li><li>直接由硬件支持、软件可控制的最小的动作单位<br>程序员按照指令格式编写软件而不必考虑机器如何实现指令的功能（即，软硬件的设计是透明的）</li></ul><p><code>指令系统（Instruction Set）</code>：一台计算机能直接理解与执行的全部指令的集合  </p><blockquote><p>决定计算机的基本功能，软件与硬件的界面<br>计算机系统设计的一个核心问题<br>指令系统是软件和硬件之间的接口  </p></blockquote><p>指令:</p><blockquote><p><code>微指令</code>：微程序级的命令，属于硬件，软件不可见<br><code>宏指令</code>：由若干条机器指令组成的软件指令，属于软件，硬件不可见<br><code>机器指令</code>：介于微指令与宏指令之间，简称指令，每条指令可完成一个独立的算术运算或逻辑运算（软硬件可见）</p></blockquote><p><strong>指令系统的发展过程</strong></p><ol><li>50年代，指令系统只有定点加减、逻辑运算、数据传送、转移等十几至几十条指令</li><li>60年代后期，增加了乘除、浮点、十进制、字符串处理等指令，指令数目多达一二百条，寻址方式也趋多样化，开始出现系列计算机</li><li>70年代末期，大多数计算机的指令系统多达几百条，称这些计算机为复杂指令系统计算机(<code>CISC</code> Complex Instruction SetComputer)<br>庞大的指令系统难以保证正确性，不易调试维护，造成硬件资源浪费，精简指令系统计算机(<code>RISC</code> Reduced Instruction Set Computer)出现，可靠性高，速度快</li></ol><h3 id="指令系统的性能要求"><a href="#指令系统的性能要求" class="headerlink" title="指令系统的性能要求"></a>指令系统的性能要求</h3><p><strong>低级语言与硬件结构的关系</strong></p><p><code>高级语言（算法语言）</code>：语法与具体机器的指令系统基本无关，编程难度低，可维护性高  </p><p><code>低级语言</code>：面向机器，和具体机器的指令系统密切相关，时空效率高</p><ul><li>低级语言分为机器语言（二进制语言）和汇编语言（符号语言）</li><li>低级语言都是面向机器的语言，和具体机器的指令系统密切相关</li></ul><p><strong>高级语言与低级语言的性能比较</strong><br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/1.png" alt="高级语言与低级语言的性能比较"></p><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><p><code>指令字(指令)</code>：表示一条指令的机器字<br><code>指令格式</code>：指令字用二进制代码表示的结构形式<br>机器执行一条指令所必须的全部信息都必须 明显或隐含地在指令中给出</p><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/3.png" alt="指令格式"><br><code>操作码字段OC</code>:表征指令的操作特性与功能<br><code>地址码字段AC</code>:指定参与操作的操作数的地址<br><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/2.jpg" alt="指令格式"></p><p>计算机指令可以根据不同的分类方式进行归类。以下是几种常见的分类方式和对应的指令种类：</p><ul><li><p>操作类型分类：计算机指令可以分为数据传输指令、算术逻辑指令、转移指令、程序控制指令等。</p></li><li><p>寻址方式分类：计算机指令可以分为立即数寻址、直接寻址、间接寻址、相对寻址等。</p></li><li><p>指令长度分类：计算机指令可以分为定长指令和变长指令。</p></li><li><p>功能分类：计算机指令可以分为系统指令、用户指令等。</p></li><li><p>指令执行方式分类：计算机指令可以分为单操作数指令、双操作数指令等。</p></li></ul><p>以上仅仅是对于计算机指令的简单分类，具体的指令种类会因为各种架构而有所不同，同时不同的指令集还会在指令的数量、精度等方面存在差异。</p><h3 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h3><ul><li>每一条指令都有一个操作码，表示该指令应进行什么性质的操作</li><li>不同的指令用操作码字段的不同编码表示</li><li>操作码字段的位数一般取决于计算机指令系统的规模</li><li>一个特定的机器的指令系统，不同指令字中操作码字段和地址码字段的长度可以相同，也可以不同</li></ul><p><code>等长操作码</code>：</p><ul><li>固定长度，所占的二进制位数固定不变</li><li>如果系统中所有指令的操作码都用n位二进制数表示，则系统中的指令条数不会超过$2^n$条</li><li>有利于简化硬件设计，减少指令译码时间  </li><li>广泛用于字长较长的计算机的指令系统中</li></ul><p><code>可变长度操作码</code>：</p><ul><li>不同的指令的操作码长度不同</li><li>操作码扩展技术（使得平均操作码长度更短）：<ul><li>地址数少的指令使用较长的操作码，地址数多的指令使用较短的操作码  </li><li>使用频度高的指令分配短的操作码，使用频度低的指令分配较长的操作码</li></ul></li><li>优点：<ul><li>有效缩短操作码的平均长度，节省存储空间  </li><li>缩短常用指令的译码时间，提高程序的运行速度</li></ul></li><li>缺点：指令译码系统比等长操作码复杂，需要判断操作码字段</li><li>在字长较短的微型机中应用广泛</li></ul><h3 id="地址码"><a href="#地址码" class="headerlink" title="地址码"></a>地址码</h3><p>指令中的地址码用来指出该指令的源操作数地址（0至2个）、目标操作数（结果）地址，以及下一条指令的地址  </p><p>操作数的存放位置：<br>主存单元<br>CPU内部数据寄存器<br>I&#x2F;O设备接口内的寄存器  </p><p>如果一条指令中有n个操作数地址，则将该指令称为n操作数指令或n地址指令</p><p>地址码字段的基本信息</p><ol><li>操作数或操作数的地址</li><li>存放运算结果的地址:<br><code>寄存器编号</code><br><code>主存地址</code><br><code>I/O地址</code></li></ol><p>不同操作数的指令:</p><blockquote><p>三地址指令<br>二地址指令<br>一地址指令<br>零地址指令</p></blockquote><h3 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h3><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/4.png" alt="四地址指令"><br>OP:操作码<br>$A_1$：第一地址码，存放被操作数（第一源操作数）<br>$A_2$：第二地址码，存放操作数（第二源操作数）<br>$A_3$：第三地址码，存放操作结果<br>$A_4$：第四地址码，存放下条要执行指令的地址<br>操作：$(A_1)OP(A_2)→A_3$，从$A_4$取下一条</p><p>指令可直接寻址的地址范围与地址字段的位数有关  </p><ul><li>例：指令字长32位，操作码占8位，4个地址段各占6位，则指令的直接寻址范围为：$2^6 &#x3D; 64$</li></ul><p>如果地址字段均指示主存的地址，则一条四地址指令执行时共需访存四次<br>优点：指令直观易懂，后续指令的地址可任意安排<br>缺点：指令长度长</p><h3 id="地址的个数"><a href="#地址的个数" class="headerlink" title="地址的个数"></a>地址的个数</h3><p>非转移类指令的下一条指令地址：<br>用于算术运算、逻辑运算、数据传输<br>首地址+指令长度</p><p>转移类指令：<br>用于改变程序的执行顺序，包括跳转指令、条件跳转指令和调用指令等<br>通常不需要源操作数地址和结果地址</p><h3 id="三地址指令"><a href="#三地址指令" class="headerlink" title="三地址指令"></a>三地址指令</h3><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/5.png" alt="三地址指令"><br>A<sub>1</sub>： 被操作数（第一源操作数）地址<br>A<sub>2</sub> ：操作数（第二源操作数）地址<br>A<sub>3</sub> ：存放结果的地址<br>非转移类指令：顺序执行后续指令</p><p>功能： $(A_1) OP (A_2) → A_3$</p><p>注意：第二源操作数是用于计算结果的输入操作数；而目的操作数是用于存储结果的输出操作数</p><h3 id="二地址指令"><a href="#二地址指令" class="headerlink" title="二地址指令"></a>二地址指令</h3><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/6.png" alt="二地址指令">  </p><p>双操作数操作：<br>$(A_1) OP (A_2) → A_1$<br>A<sub>1</sub>：既作被操作数（第一源操作数）地址，又作目的操作数地址<br>A<sub>2</sub>：操作数（第二源操作数）地址  </p><p>$(A_1) OP (A_2) → A_2$<br>A<sub>1</sub>：被操作数（源操作数）地址<br>A<sub>2</sub>：操作数（目的操作数）地址  </p><h3 id="一地址指令（单操作数指令）"><a href="#一地址指令（单操作数指令）" class="headerlink" title="一地址指令（单操作数指令）"></a>一地址指令（单操作数指令）</h3><p><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/7.png" alt="一地址指令"> </p><p>双操作数操作：<br><code>(A) OP (X) → X</code><br>A：第一源操作数地址<br>X：第二源操作数地址和目的操作数地址，隐含使用寄存器或堆栈寻址</p><p>单操作数操作：<br><code>OP (A) → A</code><br> A：既作被操作数地址，又作目的操作数地址</p><h3 id="零地址指令"><a href="#零地址指令" class="headerlink" title="零地址指令"></a>零地址指令</h3><p>指令字中只有操作码，没有地址码<br>无需操作数的指令，如空操作（NOP，占用一段时间或空间）、停机等<br>运算的操作数地址全部隐含<br>源操作数和结果隐含使用寄存器、堆栈或特定操作数</p><h3 id="双操作数运算指令的三种类型"><a href="#双操作数运算指令的三种类型" class="headerlink" title="双操作数运算指令的三种类型"></a>双操作数运算指令的三种类型</h3><p>存储器-存储器（SS）型指令</p><ul><li>参与运算的操作数都放在内存中  </li><li>机器执行SS型指令需多次访问内存</li><li>执行时间最长</li></ul><p>寄存器-寄存器（RR）型指令</p><ul><li>参与运算的操作数都放CPU内部的数据寄存器中  </li><li>机器执行RR型指令速度快，但需要多个寄存器</li><li>执行速度快</li></ul><p>寄存器-存储器（RS）型指令</p><ul><li>执行RS型指令时，既要访存，又要访问寄存器</li><li>执行速度在SS和RR之间</li></ul><h3 id="定长操作码举例"><a href="#定长操作码举例" class="headerlink" title="定长操作码举例"></a>定长操作码举例</h3><blockquote><p>例：某指令字长16位，具有三地址、二地址、一地址和零地址4类指令，每个地址占4位，采用定长操作码方案，最多可表示多少条指令？<br>答：2<sup>4</sup>=16条</p></blockquote><h3 id="扩展操作码举例"><a href="#扩展操作码举例" class="headerlink" title="扩展操作码举例"></a>扩展操作码举例</h3><blockquote><p>例：某指令字长16位，具有三地址、二地址、一地址和零地址4类指令，每个地址占4位，要求有15条三地址指令、15条二地址指令、15条一地址指令和16条零地址指令，指令格式如何设计？</p></blockquote><p><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/8.png" alt="在这里插入图片描述"></p><p>例：设某指令系统字长为16位，地址码为4位。试设计指令格式，使该系统中有11条三地址指令、70条二地址指令和150条单地址指令。并指明该系统中最多还可以有多少条零地址指令</p><p><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/11.jpg"><br><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/12.png"></p><blockquote><p>注意：1，不允许短码是长码的前缀<br>2，各条指令的操作码一定不能重复</p></blockquote><p>例题：</p><p><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/9.png" alt="在这里插入图片描述"></p><h3 id="指令字长与机器字长"><a href="#指令字长与机器字长" class="headerlink" title="指令字长与机器字长"></a>指令字长与机器字长</h3><p><code>机器字长</code>（简称字长）：计算机能直接处理的二进制数据的位数，它决定了计算机的运算精度，通常是CPU运算器的字长  </p><ul><li>字长越长，计算机的运算精度越高</li><li>为便于处理字符数据及尽可能地利用存储空间，一般把机器字长定为字节长度的整数倍</li></ul><p><code>指令字长</code>：一个指令字中二进制代码的位数 </p><ul><li>取决于操作码的长度、操作数地址的长度和操作数地址的个数</li><li>通常指令字长等于机器字长的整数倍</li><li>如果机器字较长，指令字长也可是机器字长的一半的整数倍</li></ul><h3 id="指令字长与机器字长的关系"><a href="#指令字长与机器字长的关系" class="headerlink" title="指令字长与机器字长的关系"></a>指令字长与机器字长的关系</h3><p><strong>单字长指令</strong>：指令字长等于机器字长  </p><p><strong>半字长指令</strong>：指令字长等于半个机器字长 </p><p><strong>双字长指令</strong>：指令字长等于两个机器字长</p><p><strong>多字长指令</strong>：<br><code>优点</code>：可以给操作码和地址码提供较大的空间<br><code>缺点</code>：可以给操作码和地址码提供较大的空间  </p><h3 id="指令字结构"><a href="#指令字结构" class="headerlink" title="指令字结构"></a>指令字结构</h3><p><code>等长指令字结构</code>：一个指令系统中各种指令字长度是相等的<br>特点：结构简单，控制方便，实现复杂度低  </p><p><code>变长指令字结构</code>：一个指令系统中，指令字的长度随指令功能而变化<br>特点：结构灵活，能充分利用指令长度，但指令的译码及控制较复杂</p><h3 id="指令助记符"><a href="#指令助记符" class="headerlink" title="指令助记符"></a>指令助记符</h3><p>为了便于书写和阅读程序，每条指令通常用3个或4个英文缩写字母来表示。这种缩写字符叫做<code>指令助记符</code><br>不同的指令系统中，同样或类似的操作所采用的助记符并不相同</p><p><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/10.png" alt="在这里插入图片描述"></p><h2 id="指令和数据的寻址方式"><a href="#指令和数据的寻址方式" class="headerlink" title="指令和数据的寻址方式"></a>指令和数据的寻址方式</h2><h3 id="指令的寻址方式"><a href="#指令的寻址方式" class="headerlink" title="指令的寻址方式"></a>指令的寻址方式</h3><p>寻址方式：形成指令或操作数的内存地址的方式</p><blockquote><p>指令寻址方式：用于形成指令在内存中的地址<br>数据寻址方式：用于形成操作数在内存中的地址</p></blockquote><h4 id="顺序寻址方式："><a href="#顺序寻址方式：" class="headerlink" title="顺序寻址方式："></a>顺序寻址方式：</h4><p>通常情况下，指令在内存中是按顺序存放的：指令的执行顺序就是指令在内存中的存放顺序<br>程序顺序执行过程：  </p><ul><li>CPU从存储器地址A1取出第一条指令，然后执行这条指令  </li><li>接着从存储器地址A1后面相邻地址取出第二条指令，并执行第二条指令  </li><li>接着再取出第三条指令 </li><li>依此类推……</li></ul><p><code>程序计数器（指令指针寄存器）PC</code>：自动加上指令长度，形成下一次的取指地址<br><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/13.png" alt="指令的寻址方式"></p><h4 id="跳跃（转移）寻址方式"><a href="#跳跃（转移）寻址方式" class="headerlink" title="跳跃（转移）寻址方式"></a>跳跃（转移）寻址方式</h4><p>下条指令的地址码不是顺序地由程序计数器PC给出，而是由本条指令给出<br>转移指令的地址码字段包含下一条指令地址的信息<br>执行跳跃指令时，将通过指令获得的地址码送入PC中<br>采用跳跃寻址方式，可以实现程序转移或构成循环程序<br><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/14.png" alt="跳跃（转移）寻址方式"></p><h3 id="操作数寻址方式"><a href="#操作数寻址方式" class="headerlink" title="操作数寻址方式"></a>操作数寻址方式</h3><p>操作数的三个来源： </p><ul><li>由指令中的地址码部分直接给出操作数 </li><li>操作数存放在CPU内的数据寄存器中 </li><li>操作数存放在内存的数据区（含I&#x2F;O寄存器）中 <ul><li>在指令中直接给出操作数的内存有效地址 </li><li>指令的地址字段给出形式地址（位移量），在指令执行时，形式地址依据某种方式变换为有 效地址再存取操作数</li></ul></li></ul><p>有些指令固定使用某种寻址方式<br>有些指令允许使用多种寻址方式：  </p><ul><li>在指令中加入寻址方式字段指明 </li><li>对不同的寻址方式分配不同的操作码（看作不同指令）</li></ul><p><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/15.png" alt="在这里插入图片描述">  </p><p><strong>操作数寻址方式的类型</strong></p><ol><li>立即寻址</li><li>寄存器寻址</li><li>直接寻址</li><li>间接寻址</li><li>寄存器间接寻址</li><li>隐含寻址</li><li>偏移寻址</li><li>段寻址</li><li>堆栈寻址</li></ol><h4 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h4><p>指令的地址字段指出的不是操作数的地址，而是操作数本身<br><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/16.png" alt="在这里插入图片描述"><br>例：指令 <code>MOV AX,100H</code><br><code>100H</code>就是立即数  </p><p><code>特点</code>：<br>指令中直接给出了操作数，不需要通过访问内存来取数，因而指令执行时间很短<br>操作数的范围有限<br>灵活性差</p><h4 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h4><p>操作数不放在内存中，而是放在CPU内部的通用寄存器中<br>指令中给出的操作数地址不是内存的地址单元号，而是通用寄存器的编号<br>例如，指令： <code>ADD R0,R1</code></p><blockquote><p>(R0)+(R1)→R0 (操作数在寄存器中)  </p></blockquote><p><code>特点</code>：指令通常比较短，指令执行时间短</p><h4 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h4><p>在指令格式的地址字段中，直接给出操作数在内存的地址<code>A</code></p><p>指令字中的形式地址A，就是操作数的<code>有效地址EA</code>，通常把形式地址A又称为直接地址<br>用D表示操作数，那么直接寻址的表达式为：D＝（A）</p><p>例如： <code>MOV AX，[3000H]</code><br><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/17.png" alt="在这里插入图片描述">  </p><h4 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h4><p>形式地址A既不是操作数D，也不是操作数D的真正地址，而是操作数地址的指示器，即：<strong>A的内容才是操作数的有效地址</strong></p><p><strong>间接寻址示意图</strong><br><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/19.png" alt="在这里插入图片描述">  </p><p><strong>直接寻址和间接寻址结合起来，有如下形式：</strong><br><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/18.png" alt="在这里插入图片描述"><br>寻址特征位 I<br>I＝0，直接寻址，有效地址：EA＝A<br>I＝1，间接寻址，有效地址：EA＝(A)<br>在计算机的指令系统中，变址X和间址I是用于寻址内存位置的两个概念。它们通常与基址B和外设寄存器R一起使用。</p><p>变址X是指用于计算内存地址偏移量的值，通常是在执行指令时从寄存器或内存位置读取的一个值。当计算机需要访问某个内存位置时，会将变址X添加到基址B（如果有）上，得到最终的内存地址。</p><p>间址I是指直接指定的内存地址，通常是在指令本身中给定的一个值。当计算机需要访问间址I所指向的内存位置时，会忽略基址B和变址X。</p><p>在某些指令集中，寻址特征位是用来指示该指令是否使用了变址X或间址I的标志位。例如，在x86指令集中，可以使用如下方式来表示不同的寻址模式：</p><p>直接寻址：mov eax, [0x12345678]<br>基址加偏移量寻址：mov eax, [ebx + 0x10]<br>变址寻址：mov eax, [eax + edx * 4]<br>基址加变址寻址：mov eax, [ebx + eax * 2]<br>其中，第一种情况使用了间址I；第二种情况使用了基址B和固定的偏移量；第三种情况使用了变址X和一个固定的缩放因子；第四种情况同时使用了基址B和变址X。这些寻址特征位可以在指令编码中进行标记，以便计算机能够正确地解析指令并访问相应的内存位置。  </p><h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><p>指令中指定的寄存器中的内容不是操作数，而是操作数的地址，即：EA &#x3D;(R)指明的操作数是在内存中！</p><p>示意图：<br><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/20.png" alt="在这里插入图片描述">  </p><h4 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h4><p>在指令中不明显地给出操作数的地址<br>指令中的某个操作数或其地址隐含在某个通用寄存器或指定的内存单元中  </p><p>例：<code>DIV BL</code><br>AX &#x2F; BL，商存AL中，余数存AH中</p><h4 id="偏移寻址"><a href="#偏移寻址" class="headerlink" title="偏移寻址"></a>偏移寻址</h4><p>直接寻址和寄存器间接寻址的结合<br>有效地址：<code>EA=A+(R)</code><br>要求指令中有两个地址字段，至少其中一个是显式的  </p><p>三种类型：</p><blockquote><p>相对寻址<br>基址寻址<br>变址寻址</p></blockquote><h5 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h5><p>把程序计数器PC的内容加上指令中给出的形式地址A，进而形成操作数的有效地址<br>形式地址A称为位移量，其值可正可负，相对于当前指 令地址进行浮动<br>便于程序在内存中成块搬动</p><p>即： <code>EA =(PC)+A</code><br><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/21.png" alt="在这里插入图片描述">  </p><p><code>优点</code>：指令中不必给出绝对地址，指令长度可以缩短，程序可以放在内存任何位置</p><h5 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h5><p>将CPU中基址寄存器RB的内容加上指令中给定的形式地址A，而形成操作数的有效地址<br>基址寄存器的位数可以大于形式地址A的位数，从而可以扩大操作数的寻址范围</p><p>即：E&#x3D;(R<sub>B</sub>)+A<br><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/22.png" alt="在这里插入图片描述">  </p><h5 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h5><p>把CPU中某个变址寄存器RX的内容与偏移量A相加，形成操作数有效地址</p><p>即：EA&#x3D;(R<sub>X</sub>)+A<br><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/23.png" alt="在这里插入图片描述">  </p><p><strong>基址寻址和变址寻址的区别</strong>： </p><ul><li>基址寻址的目的：扩大寻址空间和实现多道程序 </li><li>变址寻址的目的：访问复合数据结构 </li><li>变址寄存器在每次使用后其值可以自动或用指令修改；基址寄存器通常是不变的</li></ul><h4 id="段寻址方式"><a href="#段寻址方式" class="headerlink" title="段寻址方式"></a>段寻址方式</h4><p>程序中的指令和数据按照逻辑结构首先分成段， 每个段内均以段起始地址为基址编址<br>微型机中采用了段寻址方式，其实质还是基址寻址基地址就是CPU中的<code>段寄存器</code></p><p>特例：<br>如何在16位机中形成20位的地址，从而获得1MB存储空间的直接寻址能力？</p><p>将整个1MB空间存储器按照最大长度64KB为单位划分成若干段。在寻址一个具体的内存单元时，由一个基地址（段寄存器）再加上寄存器提供的16位偏移量来形成实际的20位物理地址。<br>约定段的起始地址末四位必须为0000，故用16位段寄存器指明20位段基址<br>在形成20位物理地址时，段寄存器中的16位数会自动左移4位，然后与16位偏移量相加，即可形成所需的20位的内存地址</p><p><img src="https://img-blog.csdnimg.cn/8a7458c4129e4633aa23f46f4c6bdc07.png" alt="在这里插入图片描述"></p><h4 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h4><p>对堆栈的操作：<br>向堆栈中增加数据（数据入栈，进栈）<br>从堆栈中取走数据（数据出栈，退栈） </p><p>CPU执行入栈和出栈操作时并不直接给出被操作的单元的地址，而是依据数据入出栈的顺序由硬件或软件自动给出地址，或是自动保证按顺序对数据进行操作</p><p>存储原则：先进后出</p><p>堆栈有两种形式：<code>寄存器堆栈</code>和<code>存储器堆栈</code></p><h5 id="存储器堆栈（软堆栈）"><a href="#存储器堆栈（软堆栈）" class="headerlink" title="存储器堆栈（软堆栈）"></a>存储器堆栈（软堆栈）</h5><p>利用常规内存空间的某一部分或某几部分实现存储器堆栈<br>每个软堆栈有一个<strong>固定的栈底</strong>和一个<strong>浮动的栈顶</strong><br>CPU内部设置一个堆栈指针（堆栈指示器）SP指示当前栈顶的位置<br>堆栈指示器指定的存储器单元就是堆栈的栈顶<br>栈底的位置固定，无需存储</p><p><strong>存储器堆栈入栈（进栈）操作</strong><br>push A:<br>(A)→M[SP]<br>(SP)-1→SP</p><p> (A)：通用寄存器&#x2F;内存单元A的内容<br> SP：堆栈指示器<br> M[SP]：堆栈指针指示的存储器栈顶单元</p><p><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/24.jpg" alt="进栈"></p><p><strong>存储器堆栈出栈（退栈）操作</strong><br>pop A:<br>(SP)+1→SP<br>M[SP]→ A  </p><p>(A)：通用寄存器&#x2F;内存单元Ａ的内容<br>SP：堆栈指示器<br>M[SP]：堆栈指针指示的存储器栈顶单元</p><p><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/30.jpg" alt="退栈"></p><p>栈顶指针的位置：<br>实现方式一：总是指向下一个入栈位置（无内容的栈顶）<br>实现方式二：总是指向下一个出栈位置（有内容的栈顶）<br>两种实现方式入栈和出栈操作和修改堆栈指针的操作的 顺序相反  </p><p>堆栈指针的＋1和－1操作：以一个存储字的长度为 单位修改堆栈指针(+Δ;-Δ)  </p><p>软堆栈的两种生长方式<br>栈顶地址比栈底地址小：向下生长的堆栈<br>栈顶地址比栈底地址大：向上生长的堆栈</p><h4 id="Pentium寻址方式"><a href="#Pentium寻址方式" class="headerlink" title="Pentium寻址方式"></a>Pentium寻址方式</h4><p><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/31.png" alt="entium寻址方式">  </p><h2 id="典型指令"><a href="#典型指令" class="headerlink" title="典型指令"></a>典型指令</h2><p>一个较完善的指令系统，应当有<code>数据处理</code>、<code>数据存储</code>、<code>数据传送</code>、<code>程序控制</code>四大类。</p><p>指令类型：</p><blockquote><p>数据传送指令<br>算术运算指令<br>逻辑运算指令<br>移位操作指令<br>程序控制指令<br>输入输出指令<br>串处理指令<br>特权指令</p></blockquote><h3 id="数据传送类指令"><a href="#数据传送类指令" class="headerlink" title="数据传送类指令"></a>数据传送类指令</h3><p>功能：<br>实现寄存器与寄存器、寄存器与存储单元以及存储单元与存储单元之间的数据传送  </p><p>类型：  </p><p>一般传送指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">取数(load)、存数(store)、传送(mov)、成组传送</span><br></pre></td></tr></table></figure><p>堆栈操作指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">入栈、出栈</span><br></pre></td></tr></table></figure><p>数据交换指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字节交换、字交换</span><br></pre></td></tr></table></figure><h3 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h3><p>功能：定点数或浮点数的算术运算<br>依据机器硬件功能的不同，算术运算指令的多少各不相同：<br>简单的CPU无乘除法指令<br>高档的CPU支持浮点运算<br>并行机有向量运算指令</p><p>类型：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">二进制定点加、减、乘、除指令</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浮点加、减、乘、除指令</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">十进制加、减运算指令</span><br></pre></td></tr></table></figure><h3 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h3><p>功能：<br>与、或、非、异或等逻辑运算功能以及一些位操作<br>主要用于无符号数的位操作、代码的转换、判断及运算<br>各个比特之间无进位、借位关系</p><p>类型：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">与、或、非、异或、位测试、位置位、位清除、位取反</span><br></pre></td></tr></table></figure><h3 id="移位操作指令"><a href="#移位操作指令" class="headerlink" title="移位操作指令"></a>移位操作指令</h3><p>功能：<br>对寄存器或内存单元的内容实现左移、右移或循环移位<br>含算术移位（符号不移位）和逻辑移位（所有位均移位）指令</p><p>类型：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">左移、右移、算术移位、逻辑移位、循环移位、单向移位</span><br></pre></td></tr></table></figure><h3 id="程序控制类指令"><a href="#程序控制类指令" class="headerlink" title="程序控制类指令"></a>程序控制类指令</h3><p>功能：<br>控制程序的执行顺序，对PC进行操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">无条件转移、条件转移（进位、零、负、 溢出）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">循环指令</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子程序调用及返回指令、返回主程序指令</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">中断调用与中断返回指令（程序随机切换，无法预期）</span><br></pre></td></tr></table></figure><h3 id="输入输出类指令"><a href="#输入输出类指令" class="headerlink" title="输入输出类指令"></a>输入输出类指令</h3><p>功能：<br>在I&#x2F;O独立编址方式中，输入输出指令实现CPU内的寄存器与外部设备接口之间的信息交换  </p><ul><li>例如：启动外围设备，检查测试外围设备的工作状态等</li></ul><p>在I&#x2F;O与存储器统一编址方式中，由访存指令实现CPU内的寄存器与外部设备接口之间的信息交换<br>统一编址的机器指令系统中没有输入输出类指令</p><p>类型：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入指令、输出指令</span><br></pre></td></tr></table></figure><h3 id="串处理指令"><a href="#串处理指令" class="headerlink" title="串处理指令"></a>串处理指令</h3><p>功能：<br>对成批的数据进行处理</p><p>类型：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符串传送、字符串转换、字符串比较、字符串查找、字符串抽取、字符串替换</span><br></pre></td></tr></table></figure><h3 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h3><p>功能：<br>具有特殊权限的指令，只用于操作系统或其他系统软件<br>在多用户、多任务的计算机系统中用于系统资源的分配和管理  </p><p>类型：  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存储管理指令、停机指令、系统状态控制指令</span><br></pre></td></tr></table></figure><h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><p>类型： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">状态寄存器置位、复位指令 </span><br><span class="line">暂停指令 </span><br><span class="line">空操作指令 </span><br><span class="line">自陷（TRAP）指令 </span><br><span class="line">系统控制用的特殊指令</span><br></pre></td></tr></table></figure><h2 id="计算机指令系统的分类"><a href="#计算机指令系统的分类" class="headerlink" title="计算机指令系统的分类"></a>计算机指令系统的分类</h2><p><code>CISC</code>复杂指令系统<br><code>RISC</code>精简指令系统</p><h3 id="CISC的主要特点"><a href="#CISC的主要特点" class="headerlink" title="CISC的主要特点"></a>CISC的主要特点</h3><ol><li>指令系统复杂，指令数量多、寻址方式多、指令格式多</li><li>绝大多数指令需要多个CPU周期才能执行完成</li><li>各种指令都可访问存储器</li><li>采用微程序控制</li><li>有专用寄存器</li><li>难以用优化编译生成高效的目标代码程序</li></ol><blockquote><p>CISC举例<br>CISC(复杂指令集计算机)的指令系统一般多达二三百条指令<br>VAX11&#x2F;780计算机有303条指令，18种寻址方式<br>Pentium机也有191条指令，9种寻址方式</p></blockquote><h3 id="RISC的主要特点"><a href="#RISC的主要特点" class="headerlink" title="RISC的主要特点"></a>RISC的主要特点</h3><ol><li>简化的指令系统，指令数量少、寻址方式少、指令格式少、指令长度固定，选取使用频率最高的一些简单指令，去掉使用频率低而又可以通过高频率简单指令组合实现其功能的指令</li><li>尽量使用R-R操作指令，只有取数load&#x2F;存数store指令访问存储器</li><li>使用较多的通用寄存器以减少访存</li><li>一般采用硬布线控制方式，不采用或少采用微程序控制方式  </li><li>采用多级指令流水线结构，处理机在同一时间内可执行多条指令，可在一个机器周期内执行完毕</li><li>采用优化编译技术，保证流水线畅通，对寄存器分配进行优化</li></ol><h3 id="RISC和CISC的比较"><a href="#RISC和CISC的比较" class="headerlink" title="RISC和CISC的比较"></a>RISC和CISC的比较</h3><p>设<br>高级语言程序经编译后在机器上运行的机器指令数为I<br>每条机器指令执行时所需要的平均机器周期数是C<br>每个机器周期的执行时间为T<br>计算机执行程序的时间P计算：P&#x3D;I×C×T<br><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/32.jpg" alt="RISC和CISC的比较"></p><h3 id="RISC处理机实例：SPARC"><a href="#RISC处理机实例：SPARC" class="headerlink" title="RISC处理机实例：SPARC"></a>RISC处理机实例：SPARC</h3><p>在SPARC中，有一些指令没有选入指令系统，但很容易使用指令系统中的另外一条指令来替代实现。下表左半部列出 了6条指令的功能。请在表的右半部填入替代指令及实现方法。<br>约定：当某些指令中地址字段为寄存器R0的编号时，以<strong>立即数0</strong>（而不是R0的内容）作为操作数<br><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9B%BE%E7%89%87/33.jpg" alt="SPARC"></p><h3 id="ARMv8-A架构支持的指令集"><a href="#ARMv8-A架构支持的指令集" class="headerlink" title="ARMv8-A架构支持的指令集"></a>ARMv8-A架构支持的指令集</h3><p>两种执行状态（Execution State）：  </p><ul><li>AArch64执行状态  <ul><li>A64指令集则使用64位工作寄存器  </li><li>使用64位计算模式  </li><li>所有指令均为32位等长指令字（4字节）</li></ul></li><li>AArch32执行状态 <ul><li>A32指令集： <ul><li>对应ARMv7架构及其之前的ARM指令集 </li><li>32位等长指令字</li></ul></li><li>T32指令集 <ul><li>对应ARMv7架构及其之前的Thumb&#x2F;Thumb-2指 令集 </li><li>16位和32位可变长指令字结构</li></ul></li></ul></li><li>均支持SIMD（Single Instruction Multiple Data）和浮点运算指令</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第四章-指令系统&quot;&gt;&lt;a href=&quot;#第四章-指令系统&quot; class=&quot;headerlink&quot; title=&quot;第四章 指令系统&quot;&gt;&lt;/a&gt;第四章 指令系统&lt;/h1&gt;&lt;h2 id=&quot;指令系统的发展和性能要求&quot;&gt;&lt;a href=&quot;#指令系统的发展和性能要求&quot; cla</summary>
      
    
    
    
    <category term="专业课" scheme="https://jayerine.top/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="计组" scheme="https://jayerine.top/tags/%E8%AE%A1%E7%BB%84/"/>
    
  </entry>
  
</feed>
