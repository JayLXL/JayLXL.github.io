<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计算机组成原理 第五章 | Jay and Erine's Blog</title><meta name="author" content="Jay and Erine"><meta name="copyright" content="Jay and Erine"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="FFF6E2"><meta name="description" content="第五章 中央处理器CPU的功能和组成CPU的功能中央处理器（Central Processing Unit）是计算机的核心部件，通常简称为CPU，控制计算机自动完成取指令和执行指令任务 CPU对整个计算机系统的运行是极其重要的 CPU的基本功能：指令控制 ：    程序的顺序控制   将指令从内存中取到CPU里，并决定下条要执行的指令的地址  CPU内与指令控制功能相关的部件： 程序计数器PC（P">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机组成原理 第五章">
<meta property="og:url" content="https://jayerine.top/2024/02/06/af75ba95c6e9/index.html">
<meta property="og:site_name" content="Jay and Erine&#39;s Blog">
<meta property="og:description" content="第五章 中央处理器CPU的功能和组成CPU的功能中央处理器（Central Processing Unit）是计算机的核心部件，通常简称为CPU，控制计算机自动完成取指令和执行指令任务 CPU对整个计算机系统的运行是极其重要的 CPU的基本功能：指令控制 ：    程序的顺序控制   将指令从内存中取到CPU里，并决定下条要执行的指令的地址  CPU内与指令控制功能相关的部件： 程序计数器PC（P">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E5%B0%81%E9%9D%A2/%E8%AE%A1%E7%BB%84%E4%BA%94%E5%B0%81%E9%9D%A2.jpg">
<meta property="article:published_time" content="2024-02-06T04:00:21.561Z">
<meta property="article:modified_time" content="2024-02-06T04:00:21.561Z">
<meta property="article:author" content="Jay and Erine">
<meta property="article:tag" content="计组">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E5%B0%81%E9%9D%A2/%E8%AE%A1%E7%BB%84%E4%BA%94%E5%B0%81%E9%9D%A2.jpg"><link rel="shortcut icon" href="https://s1.ax1x.com/2023/03/01/ppieNl9.png"><link rel="canonical" href="https://jayerine.top/2024/02/06/af75ba95c6e9/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/all","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机组成原理 第五章',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-06 12:00:21'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/fish.css"><script src="/js/sakura.js"></script><link rel="stylesheet" href="/css/footer_trans.css"><link rel="stylesheet" href="/css/scrollbar.css"><link rel="stylesheet" href="/css/cursor.css"><link rel="stylesheet" href="/css/mathjax_display.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Jay and Erine's Blog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s1.ax1x.com/2023/02/27/ppCAPEQ.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Jay and Erine's Blog"><span class="site-name">Jay and Erine's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">计算机组成原理 第五章</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-02-06T04:00:21.561Z" title="Created 2024-02-06 12:00:21">2024-02-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-02-06T04:00:21.561Z" title="Updated 2024-02-06 12:00:21">2024-02-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/">专业课</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机组成原理 第五章"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="第五章-中央处理器"><a href="#第五章-中央处理器" class="headerlink" title="第五章 中央处理器"></a>第五章 中央处理器</h1><h2 id="CPU的功能和组成"><a href="#CPU的功能和组成" class="headerlink" title="CPU的功能和组成"></a>CPU的功能和组成</h2><h3 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a>CPU的功能</h3><p>中央处理器<code>（Central Processing Unit）</code>是计算机的核心部件，通常简称为<code>CPU</code>，控制计算机自动完成取指令和执行指令任务</p>
<p>CPU对整个计算机系统的运行是极其重要的</p>
<p><strong>CPU的基本功能：</strong><br><code>指令控制</code> ：  </p>
<ul>
<li>程序的顺序控制  </li>
<li>将指令从内存中取到CPU里，并决定下条要执行的指令的地址 </li>
<li>CPU内与指令控制功能相关的部件：<ul>
<li><code>程序计数器PC</code>（Program Counter），又名指令计数器、指令地址计数器或指令指针 <ul>
<li>用于确定下一条指令的地址 </li>
<li>在程序开始执行前，将程序的第一条指令所在的 内存单元地址送入PC </li>
<li>顺序执行指令时，CPU将自动修改PC的内容，加上指令的长度，使其保持将要执行的下一条指令的地址 </li>
<li>执行转移类操作时，将程序的后继指令的地址送入PC</li>
</ul>
</li>
<li>（内存）<code>地址寄存器MAR</code>/AR（Address Register） <ul>
<li>保存当前CPU所访问的内存单元或I/O接口的地址</li>
<li>连接到地址总线 </li>
<li>由于在内存和CPU之间存在着操作速度上的差别，所以必须使用地址寄存器来保持地址信息，直到内存的读/写操作完成为止 </li>
</ul>
</li>
<li>（内存）<code>数据寄存器MDR</code>/DR（Data Register），缓冲寄存器<ul>
<li>CPU和数据总线的缓冲 </li>
<li>功能：<br>输入缓冲：暂存由内存单元或I/O接口读出的指令或数据<br>输出缓冲：暂存向内存单元或I/O接口存入的数据   </li>
<li>作用：<br>CPU和内存、外部设备接口之间信息传送的中转站<br>补偿CPU和内存、外设接口之间操作速度的差别<br>作为内存操作数的缓冲参加CPU的运算</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>操作控制</code>：  </p>
<ul>
<li>指令取出后，CPU依其操作码字段和形式地址字段解释指令，指出是何操作、如何得到操作数地址 </li>
<li>CPU产生每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作 </li>
<li>CPU内与操作控制功能相关的部件： <ul>
<li><code>指令寄存器IR</code>（Instruction Register） <ul>
<li>保存当前正在执行的一条指令的二进制代码 </li>
<li>指令执行时，指令首先被从内存取到缓冲寄存器中，然后再传送至指令寄存器 </li>
<li>指令寄存器中操作码字段就是指令译码器的输入</li>
</ul>
</li>
<li><code>指令译码器ID</code>（Instruction Decoder）：翻译指令</li>
<li><code>操作控制器</code>：产生操作信号</li>
</ul>
</li>
</ul>
<p><code>时序控制</code> ：</p>
<ul>
<li>控制操作信号的有效时间</li>
<li>在CPU内设置：时序发生器<br><code>数据加工</code>：  </li>
<li>通过算术或逻辑运算将原始信息转换成所需的结果 </li>
<li>CPU内与数据加工功能相关的部件 <ul>
<li><code>ALU</code>（算术逻辑运算单元） </li>
<li><code>浮点运算器</code> </li>
<li><code>通用寄存器组</code> </li>
<li><code>状态条件寄存器</code> <ul>
<li>通常作为程序状态字寄存（PSWR： Program Status Word Register）的一部分</li>
<li>功能：<br>保存由算术指令和逻辑指令运行或测试的结果建立的各种条件码<br><code>进位标志(C)</code><br><code>溢出标志(V)</code><br><code>零标志(Z)</code><br><code>负标志(N)</code><br>保存中断和系统工作状态等信息<br>控制位</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="CPU的基本组成"><a href="#CPU的基本组成" class="headerlink" title="CPU的基本组成"></a>CPU的基本组成</h3><ol>
<li>控制器</li>
<li>运算器</li>
<li>cache</li>
<li>芯片级总线</li>
</ol>
<p><strong>控制器</strong><br>性质：控制部件<br>组成：程序计数器、指令寄存器、指令译码器、时序发生器和操作控制器<br>功能：协调和指挥整个计算机系统的操作（指令控制、操作控制、时序控制）  </p>
<ul>
<li>取指：从内存中取出一条指令，并指出下一条指令在内存中的位置  </li>
<li>分析：对指令进行译码或测试，并产生相应的操作控制信号  </li>
<li>执行：指挥并控制CPU、内存和输入/输出设备之间的数据传送以及对数据的加工</li>
</ul>
<p><strong>运算器</strong><br>性质：执行部件<br>组成：算术逻辑运算单元(ALU)、寄存器组、 状态条件寄存器<br>功能：数据加工 </p>
<ul>
<li>算术运算 </li>
<li>逻辑运算与逻辑测试</li>
</ul>
<p><strong>CPU中的主要寄存器</strong><br>程序计数器（PC）<br>指令寄存器（IR）<br>内存数据寄存器（MDR）<br>内存地址寄存器（MAR）<br>通用寄存器（R0~R3）<br>程序状态字寄存器（PSWR）</p>
<p>各个寄存器的位数和什么因素相关呢？  </p>
<ul>
<li>程序计数器（PC）和PC位数相同</li>
<li>指令寄存器（IR）和指令长度有关  </li>
<li>内存数据寄存器（MDR）和数据总线宽度有关  </li>
<li>内存地址寄存器（MAR）存储空间地址长度有关 </li>
<li>通用寄存器（R0~R3）没有限定长度，和字长有关  </li>
<li>程序状态字寄存器（PSWR）不限定</li>
</ul>
<p><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%9B%BE%E7%89%87/1.jpg" alt="例题"></p>
<p><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%9B%BE%E7%89%87/2.jpg" alt="例题"></p>
<h3 id="操作控制器与时序产生器"><a href="#操作控制器与时序产生器" class="headerlink" title="操作控制器与时序产生器"></a>操作控制器与时序产生器</h3><p>操作控制器的功能：<br>根据不同的指令产生不同的控制信号，以便控制何时打开/关闭数据通路，从而完成取指令和执行指令的控制</p>
<p>操作控制器可分为两种类型：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">时序逻辑型 ----&gt;硬布线控制器（组合逻辑控制器）</span><br></pre></td></tr></table></figure><br>用组合逻辑电路产生固定时序控制信号<br>控制信号形成部件是由门电路组成的复杂树形网络<br>优点：<strong>速度快</strong><br>缺点：时序控制信号形成部件的结构不规整，设计、调试、维护困难，难以实现设计自动化<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存储逻辑型----&gt;微程序控制器（存储逻辑控制器）</span><br></pre></td></tr></table></figure><br>采用存储逻辑实现<br>微操作信号代码化，将每条机器指令转化为一段微程序并存入控制存储器中，微操作控制信号由微指令产生（软件不可见）<br>优点：设计规整，调试、维护及更新、扩充指令方便，易于实现自动化设计<br>缺点：指令执行速度比硬布线控制器<strong>慢</strong></p>
<p><strong>时序产生器</strong> (Timer Generator，<code>TG</code>) ：<br>产生并发出计算机所需要的时序控制信号<br>对各种操作信号实施时间上的控制</p>
<h2 id="5-2-指令周期"><a href="#5-2-指令周期" class="headerlink" title="5.2 指令周期"></a>5.2 指令周期</h2><p><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%9B%BE%E7%89%87/3.png" alt="指令周期"></p>
<p>指令周期 </p>
<ul>
<li>CPU从内存取出并执行一条指令的时间 </li>
<li>连续两次发送取指令地址之间的间隔时间 </li>
<li>取指时间＋执行时间 </li>
</ul>
<p>时钟周期（节拍脉冲、节拍周期或T周期） </p>
<ul>
<li>操作的最基本时间单位 </li>
<li>一个指令周期由多个时钟周期构成 </li>
</ul>
<p>CPU周期（机器周期）</p>
<ul>
<li>CPU与内存交换一次信息的时间 </li>
</ul>
<p>不同机器中术语的含义未必相同：现代计算机已较少采用三级时序系统，机器周期的概念逐渐消失（机器周期=时钟周期）</p>
<p>指令周期、时钟周期、CPU周期的关系<br><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%9B%BE%E7%89%87/4.png" alt="指令周期、时钟周期、CPU周期的关系"></p>
<h3 id="指令的执行过程"><a href="#指令的执行过程" class="headerlink" title="指令的执行过程"></a>指令的执行过程</h3><blockquote>
<p>取指阶段<br>取操作数阶段<br>执行阶段</p>
</blockquote>
<p><code>取指阶段（fetch）</code><br>每条指令的第一个CPU周期都是取指周期 </p>
<ul>
<li>从内存指定单元取出当前指令送至CPU内的指令寄存器IR </li>
<li>修改程序计数器PC，以便取下一条指令 </li>
<li>对指令的操作码字段进行译码测试，以便确定下一步进行何种操作</li>
</ul>
<p><img src="https://blog-pics.obs.myhuaweicloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%9B%BE%E7%89%87/5.jpg" alt="取指阶段"></p>
<p><code>分析指令</code><br>—按指令规定内容执行指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不同指令的操作步骤数</span><br><span class="line">和具体操作内容差异很大</span><br></pre></td></tr></table></figure>
<p>—检查有无中断请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">若无，则转入下一条指令的执行过程</span><br><span class="line">形成下一条指令地址</span><br></pre></td></tr></table></figure>
<p><strong>指令周期的概念</strong><br><code>指令周期</code> ：CPU从内存取出一条指令并执行完这条指令的时间总和</p>
<p><code>CPU周期</code> ：又称机器周期，从内存读取一个指令字的最短时间</p>
<p><code>时钟周期</code>：又称<code>T周期</code> 或<code>节拍脉冲</code>，是处理操作的最基本单位，一个CPU周期包含若干个T周期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1个指令周期 = 若干个CPU周期</span><br><span class="line">1个CPU周期 = 若干个时钟周期</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/a350a89f2f3e437090149a00e8e49d79.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/3e0beda3969546f9b925cf37b3d78ed8.png" alt="在这里插入图片描述"></p>
<h3 id="MOV指令"><a href="#MOV指令" class="headerlink" title="MOV指令"></a>MOV指令</h3><p>MOV是RR型指令，需要两个CPU 周期<br>在第一个CPU周期，即取指令阶段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">• ① 从指存取出指令</span><br><span class="line">• ② 对程序计数器PC加1，以便为取下一条指令做好准备</span><br><span class="line">• ③ 对指令操作码进行译码或测试，以便确定进行什么操作</span><br></pre></td></tr></table></figure>
<p>在第二个CPU周期，即执行指令阶段，完成两个通用寄存器R0、R1之间的数据传送操作</p>
<p><img src="https://img-blog.csdnimg.cn/1011f1e538b74b1a8d6a01fe5675d948.png" alt="在这里插入图片描述"><br><strong>取指周期</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① 程序计数器PC中装入第1条指令地址101（八进制）</span><br><span class="line">② PC的内容被放到指令地址总线ABUS(I)上，对指存进行译码，并启动读命令</span><br><span class="line">③ 从101号地址读出的MOV指令通过指令总线IBUS装入指令寄存器IR</span><br><span class="line">④ 程序计数器内容加1，变成102，为取下一条指令做好准备</span><br><span class="line">⑤ 指令寄存器中的操作码(OP)被译码</span><br><span class="line">⑥ CPU识别出是MOV指令</span><br></pre></td></tr></table></figure>
<p><strong>执行周期</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① 操作控制器(OC)送出控制信号到通用寄存器，选择R1(10)作源寄存器，选择R0作目标寄存器</span><br><span class="line">② OC送出控制信号到ALU，指定ALU做传送操作</span><br><span class="line">③ OC送出控制信号，打开ALU输出三态门，将ALU输出送到数据总线DBUS上</span><br><span class="line">④ OC送出控制信号，将DBUS上的数据打入到数据缓冲寄存器DR(10)</span><br><span class="line">⑤ OC送出控制信号，将DR中的数据打入到目标寄存器R0，R0的内容由00变为10</span><br></pre></td></tr></table></figure>
<h3 id="LAD指令"><a href="#LAD指令" class="headerlink" title="LAD指令"></a>LAD指令</h3><p><code>LAD</code>指令是RS型指令，共需要三个CPU周期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第1个CPU周期为取指令阶段，和MOV指令相同</span><br><span class="line">第2个CPU周期将操作数的地址送往地址寄存器并完成地址译码</span><br><span class="line">第3个CPU周期从内存取出操作数装入通用寄存器</span><br></pre></td></tr></table></figure>
<p><strong>LAD指令的执行周期</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① 操作控制器OC发出控制命令打开IR输出三态门，将指令中的直接地址码6放到数据总线DBUS上</span><br><span class="line">② OC发出操作命令，将地址码6装入数存地址寄存器AR</span><br><span class="line">③ OC发出读命令，将数存6号单元中的数100读出到DBUS上</span><br><span class="line">④ OC发出命令，将DBUS上的数据100装入缓冲寄存器DR</span><br><span class="line">⑤ OC发出命令，将DR中的数100装入通用寄存器R1，原来R1中的数10被冲掉</span><br></pre></td></tr></table></figure>
<h3 id="ADD指令"><a href="#ADD指令" class="headerlink" title="ADD指令"></a>ADD指令</h3><p>ADD指令是RR型指令，共需要两个CPU周期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第1个是取指周期，与MOV指令相同</span><br><span class="line">第2个是执行周期，执行加操作</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/6718eef4a83f49b69818cefc2a1118df.png" alt="在这里插入图片描述"><br><strong>ADD指令的执行周期</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① 操作控制器OC送出控制命令到通用寄存器，选择R1做源寄存器，R2做目标寄存器</span><br><span class="line">② OC送出控制命令到ALU，指定ALU做R1(100)和R2(20)的加法操作</span><br><span class="line">③ OC送出控制命令，打开ALU输出三态门，运算结果120放DBUS上</span><br><span class="line">④ OC送出控制命令，将DBUS上数据打入缓冲寄存器DR，ALU产生的进位信号保存在状态寄存器PSW中</span><br><span class="line">⑤ OC送出控制命令，将DR(120)装入R2，R2中原来的内容20被冲掉</span><br></pre></td></tr></table></figure>
<h3 id="STO指令"><a href="#STO指令" class="headerlink" title="STO指令"></a>STO指令</h3><p>STO指令是RS型指令，共需要三个CPU周期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第1个CPU周期为取指令阶段，和MOV指令相同</span><br><span class="line">第2个CPU周期将操作数的地址（R3）=30送往地址寄存器并完成地址译码</span><br><span class="line">第3个CPU周期将(R2)=120写入到30号单元</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/c5cad228ea2e4ca7af341d37f5eaa164.png" alt="在这里插入图片描述"><strong>STO指令的执行周期</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① 操作控制器OC送出操作命令到通用寄存器，选择R3内容(30)做数据存储器的单元地址</span><br><span class="line">② OC发出操作命令，打开通用寄存器输出三态门，将地址30放到DBUS上</span><br><span class="line">③ OC发出操作命令，将地址30打入AR，并进行数存地址译码</span><br><span class="line">④ OC发出操作命令到通用寄存器，选择(R2)=120，作为数存的写入数据</span><br><span class="line">⑤ OC发出操作命令，打开通用寄存器输出三态门，将120放到DBUS上</span><br><span class="line">⑥ OC发出操作命令，将数据120写入数存30号单元，它原来的数据40被冲掉</span><br></pre></td></tr></table></figure>
<h3 id="JMP指令"><a href="#JMP指令" class="headerlink" title="JMP指令"></a>JMP指令</h3><p>JMP指令是无条件转移指令，共需要两个CPU周期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第1个CPU周期为取指令阶段，和MOV指令相同</span><br><span class="line">第2个CPU周期将地址101送入程序计数器PC</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/948ea5b7d05a420996f2cf08ac5829e2.png" alt="在这里插入图片描述"><br><strong>JMP指令的执行周期</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① OC发出操作控制命令，打开指令寄存器IR的输出三态门，将IR中的地址码101发送到DBUS上</span><br><span class="line">② OC发出操作控制命令，将DBUS上的地址码101打入到程序计数器PC中，PC中的原来内容106被更换</span><br></pre></td></tr></table></figure>
<blockquote>
<h1 id="重点题型：CPU参数计算"><a href="#重点题型：CPU参数计算" class="headerlink" title="*重点题型：CPU参数计算"></a>*重点题型：CPU参数计算</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40581966/article/details/89165628?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-89165628-blog-105262877.pc_relevant_paycolumn_v3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-89165628-blog-105262877.pc_relevant_paycolumn_v3&amp;utm_relevant_index=1">CPU相关性能参数的计算</a></p>
</blockquote>
<h3 id="用方框图语言表示指令周期"><a href="#用方框图语言表示指令周期" class="headerlink" title="用方框图语言表示指令周期"></a>用方框图语言表示指令周期</h3><p>在进行计算机设计时，可以采用方框图语言来表示一条指令的指令周期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方框 ：代表一个CPU周期，方框中的内容表示数据通路的操作或某种控制操作</span><br><span class="line">菱形 ：通常用来表示某种判别或测试，时间上它依附于紧接它的前面一个方框的CPU周期，</span><br><span class="line">不单独占用一个CPU周期</span><br><span class="line">符号“~”代表一个公操作</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/3a28377ad8b24a5b95460d40d6650ae3.png" alt="在这里插入图片描述"></p>
<p><strong>重点例题：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/c18c5c5afe224e818e55360b949a05b7.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/61c78958fe824654b2d90b41775ab536.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/8415d799209440218727ba1b5b3f1567.png" alt="在这里插入图片描述"></p>
<h2 id="5-3-时序产生器和控制方式"><a href="#5-3-时序产生器和控制方式" class="headerlink" title="5.3 时序产生器和控制方式"></a>5.3 时序产生器和控制方式</h2><p>指令周期 ：CPU从内存取出一条指令并执行完这条指令的时间总和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU周期 ：又称机器周期，CPU从内存读取一条指令字的所需的最短时间</span><br><span class="line">时钟周期 ：称为T周期或节拍脉冲，是处理操作的最基本单位，一个CPU周期包含若干个T周期</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1个指令周期 = 若干个CPU周期<br>1个CPU周期 = 若干个时钟周期</p>
</blockquote>
<p>思考题：<br>用二进制码表示的指令和数据都放在内存里，CPU是如何识别出它们是数据还是指令呢?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从时间上来说：</span><br><span class="line">取指令事件发生在指令周期的第一个CPU周期中，取数据事件发生在指令周期的后面几个CPU周期中</span><br><span class="line">从空间上来说：</span><br><span class="line">如果取出的是指令，一定送往指令寄存器IR，如果取出的是数据，一定送往运算器</span><br></pre></td></tr></table></figure>
<p><strong>时序信号</strong></p>
<ol>
<li>时序信号：使计算机准确、迅速、有条不紊地工作</li>
<li>时序信号产生器：给计算机各部件提供工作所需的时间标志</li>
<li>操作控制器利用定时脉冲的顺序和不同的脉冲间隔，有条理、有节奏地指挥机器的动作</li>
</ol>
<p><strong>总结：</strong></p>
<ol>
<li><p>计算机的协调动作需要时间标志，而且需要采用多级时序体制，而时间标志是由时序信号体现的</p>
</li>
<li><p>组成计算机硬件的器件特性决定了时序信号最基本的体制：<code>电位-脉冲制</code></p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/041295209f254d0b9793c29937002244.png" alt="在这里插入图片描述"></p>
<h3 id="硬布线控制器的三级时序体制"><a href="#硬布线控制器的三级时序体制" class="headerlink" title="硬布线控制器的三级时序体制"></a>硬布线控制器的三级时序体制</h3><p><code>主状态周期</code>：<br>一个触发器的状态持续时间，包含若干节拍电位<br><code>节拍电位</code>：<br>一个节拍电位表示一个CPU周期的时间<br><code>节拍脉冲（T周期）</code>：<br>一个节拍电位包含若干个节拍脉冲</p>
<p><strong>三级时序图</strong><br><img src="https://img-blog.csdnimg.cn/9daab8f576ae4fd687cd8513484fc723.png" alt="在这里插入图片描述"><br><strong>微程序控制器的二级时序体制</strong><br><img src="https://img-blog.csdnimg.cn/7c25938157004ba389c52d5bd122d185.png" alt="在这里插入图片描述"><br><strong>节拍电位</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">节拍电位：把一个机器周期分为若干个相等的时间段，每一个时间段对应一个电位信号，称为节拍电位信号</span><br><span class="line">节拍的宽度：取决于CPU完成一次基本操作的时间</span><br></pre></td></tr></table></figure>
<p><strong>工作脉冲</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在节拍中执行的有些操作需要同步定时脉冲</span><br><span class="line">节拍内可设置一个或几个工作脉冲，作为各种同步脉冲的来源</span><br><span class="line">工作脉冲的宽度只占节拍电位宽度的1/n，并处于节拍的末尾</span><br></pre></td></tr></table></figure>
<p><strong>CPU周期、节拍电位、节拍脉冲的时序关系</strong></p>
<p><img src="https://img-blog.csdnimg.cn/f44075b430b446e3a20945e8b364b5b7.png" alt="在这里插入图片描述"><br><strong>时序信号产生器</strong></p>
<p>微程序控制器中使用的时序信号产生器的组成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">时钟源</span><br><span class="line">环形脉冲发生器</span><br><span class="line">节拍脉冲和读写时序</span><br><span class="line">启停控制逻辑</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/c6ef5c54b92a410396570ae98108ae37.png" alt="在这里插入图片描述"><br><strong>启停控制逻辑</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行标志触发器Cr的Q=1，使原始信号变为CPU所需的时序信号</span><br><span class="line">运行标志触发器Cr的Q=0，封锁原始信号</span><br><span class="line">总清信号CLR使Cr的Q=0</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/dd0ab8f900a0412888b923c57bb129bc.png" alt="在这里插入图片描述"><br><strong>启停控制逻辑-启动</strong><br>启动：启动信号为低电平时，在T<sub>4</sub><sup>0</sup>的后沿将1打入Cr<br><img src="https://img-blog.csdnimg.cn/35bdc20fa68b474d806f2d515bc5388c.png" alt="在这里插入图片描述"><br><strong>启停控制逻辑-停机</strong></p>
<p>停机：停机信号为低电平时，在T<sub>4</sub><sup>0</sup>的后沿将0打入Cr</p>
<p><img src="https://img-blog.csdnimg.cn/a2f048896ee044c09eac51a845fe858d.png" alt="在这里插入图片描述"></p>
<h3 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h3><p>控制方式：控制不同操作序列时序信号的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">－同步控制</span><br><span class="line">－异步控制</span><br><span class="line">－联合控制</span><br></pre></td></tr></table></figure>
<p><strong>同步控制方式</strong></p>
<p>在任何情况下，已定的指令在执行时所需的CPU周期数和时钟周期数都固定不变。</p>
<p>根据不同情况，同步控制方式可选取如下方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）采用完全统一的机器周期执行各种不同的指令</span><br><span class="line">（2）采用不定长机器周期</span><br><span class="line">（3）中央控制与局部控制结合</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/1bfbc875f87c402ebb89639b1bb93ebc.png" alt="在这里插入图片描述"></p>
<p><strong>完全同步控制方式</strong><br>采用完全统一的、具有相同时间间隔和相同数目的节拍电位作为机器周期来运行各种不同的指令</p>
<p><img src="https://img-blog.csdnimg.cn/d22091f2827a45339aac52740134ee11.png" alt="在这里插入图片描述"><br><strong>采用不定长机器周期</strong></p>
<p>将大多数操作安排在一个较短的机器周期内完成，对某些时间较长的操作，则采取延长机器周期的方法来解决</p>
<p>延长机器周期:<br><img src="https://img-blog.csdnimg.cn/06593aafddb54533a9b79f2e1e85e9a4.png" alt="在这里插入图片描述"><br><strong>中央控制与局部控制结合</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将大部分指令安排在固定的机器周期完成</span><br><span class="line">对少数复杂指令采用另外的时序进行定时</span><br></pre></td></tr></table></figure>
<p><strong>异步控制方式</strong></p>
<p>一般采用两条控制线，即<code>请求</code>线和<code>回答</code>线</p>
<p><strong>异步控制方式小结</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每条指令、每2个.异操作步控控制信制号方需式要多少时间就占用多少时间</span><br><span class="line">每条指令的指令周期可由多少不等的机器周期数组成</span><br><span class="line">用这种方式形成的操作控制序列没有固定的CPU周期数(节拍电位)或严格的时钟周期(节拍脉冲)与之同步</span><br></pre></td></tr></table></figure>
<p><strong>联合控制方式</strong></p>
<p>同步控制和异步控制相结合的方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">情况1： </span><br><span class="line">大部分操作序列安排在固定的机器周期中，</span><br><span class="line">对某些时间难以确定的操作则以执行部件的“回答”信号作为本次操作的结束</span><br><span class="line">情况2： </span><br><span class="line">机器周期的节拍脉冲数固定，但是各条指令周期的机器周期数不固定</span><br></pre></td></tr></table></figure>
<p><strong>控制器组成总结</strong><br>• 指令部件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">程序计数器PC</span><br><span class="line">指令寄存器</span><br><span class="line">指令译码器</span><br></pre></td></tr></table></figure>
<p>• 时序部件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">脉冲源及启停逻辑</span><br><span class="line">时序信号形成部件</span><br><span class="line">控制方式</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/b59b216ac1004223880efff56db3453b.png" alt="在这里插入图片描述"></p>
<h2 id="5-4-微程序控制器"><a href="#5-4-微程序控制器" class="headerlink" title="5.4 微程序控制器"></a>5.4 微程序控制器</h2><h3 id="微程序控制原理"><a href="#微程序控制原理" class="headerlink" title="微程序控制原理"></a>微程序控制原理</h3><p><strong>微程序控制的基本思想</strong></p>
<p>将微操作控制信号按一定规则进行信息编码形成控制字（微指令），一条机器指令对应一段“程序”该程序存放在控制存储器中，当机器运行时，一条又一条地读出这些微指令，从而产生全机所需要的各种操作控制信号，使相应部件执行所规定的操作因为“程序”的执行结果是实现一条机器指令的功能，所以称为“指令的微程序”</p>
<p>数字计算机可分为<code>控制部件</code>和<code>执行部件</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">控制器</span><br><span class="line">运算器、存储器、外围设备（IO设备）</span><br></pre></td></tr></table></figure>
<p>控制部件与执行部件的一种联系，就是通过控制线。控制部件通过控制线向执行部件发出各种控制命令，通常吧这种控制命令叫做<code>微命令</code>，而执行部件接受微命令后所进行的操作，叫做<code>微操作</code>。</p>
<p><strong>微命令和微操作</strong></p>
<p>微命令 ：控制部件通过控制线向执行部件发出各种控制命令</p>
<p>微操作 ：执行部件接受微命令后所进行的操作。</p>
<p>微操作可分为 <code>相容性</code> 和 <code>相斥性</code> 两种</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相容性：在同时或同一个 CPU 周期内可以并行执行的微操作</span><br><span class="line">相斥性：不能在同时或不能在同一个CPU 周期内并行执行的微操作</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/8161999085594b3bb051479dc1123ec9.png" alt="在这里插入图片描述"><br><strong>微指令和微程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">微指令 ：在机器的一个 CPU 周期中，一组实现一定操作功能的微命令的组合，构成一条微指令</span><br><span class="line">微程序 ：微指令序列为微程序</span><br></pre></td></tr></table></figure>
<p><strong>机器指令和微指令的关系：</strong><br>每条机器指令由一段微指令编程的微程序来解释执行</p>
<p><img src="https://img-blog.csdnimg.cn/c1b74f8ff0524b5a804d390973ad6c7f.png" alt="在这里插入图片描述"></p>
<p><strong>微指令的基本格式</strong><br><img src="https://img-blog.csdnimg.cn/13483cb73299496eae50291a91fcdcda.png" alt="在这里插入图片描述"><br><code>操作控制</code>：用来发出管理和指挥全机工作的控制信号<br><code>顺序控制</code>：用来决定如何形成下一条微指令的地址</p>
<p><img src="https://img-blog.csdnimg.cn/bc7873a635cc4670b5c2d3f42ac99c9b.png" alt="在这里插入图片描述"><br><strong>节拍电位信号和节拍脉冲信号</strong></p>
<p><code>节拍电位信号</code>的持续时间都是一个 CPU 周期</p>
<p><code>节拍脉冲</code>由环形脉冲发生器产生，一个节拍电位持续时间正好包容若干个节拍脉冲</p>
<h3 id="微程序控制器的组成"><a href="#微程序控制器的组成" class="headerlink" title="微程序控制器的组成"></a>微程序控制器的组成</h3><p><code>控制存储器</code>：用来存放实现全部指令系统的微程序，是一种高速存储器</p>
<p><code>微地址</code>：控存单元的地址<br>控存的一个单元的内容即控制字代表了某一个节拍的一组微操作控制信号的信息</p>
<p>微程序控制器主要由<code>控制存储器</code>、<code>微指令寄存器</code> 和 <code>地址转移逻辑</code> 组成</p>
<p><img src="https://img-blog.csdnimg.cn/f8a570f10443413cb3718e8de4189f47.png" alt="在这里插入图片描述"></p>
<h3 id="微程序控制器工作过程"><a href="#微程序控制器工作过程" class="headerlink" title="微程序控制器工作过程"></a>微程序控制器工作过程</h3><p>实质上就是在<code>微程序控制器</code>的控制下，计算机<strong>执行机器指令</strong>的过程</p>
<p>从控存中取出一段<code>取机器指令</code>用的微程序，称为<code>取指微程序</code>，该微程序完成从主存中读取机器指令并送往<code>指令寄存器</code>。</p>
<p>机器指令操作码通过微地址形成部件，产生对应的微程序入口地址，并送入<code>微地址寄存器</code>。</p>
<p>逐条取出对应的微指令，每一条微指令提供一个<code>微命令序列</code>，控制有关的微操作。</p>
<p>执行完对应于一条机器指令的一段微程序后，返回到取指微程序的入口，以便取出下一条机器指令。不断重复，直至程序执行完毕。</p>
<p><strong>举例：</strong><br>假定数<br>a 和 b 已存放在 R1 和 R2 两寄存器中，数 6 存放在 R3 寄存器中。<br>算法要求先进行a+b+6 运算，然后判断结果有无进位；当进位标志 Cy=1 不减 6 ，当 Cy=0 ，减 6 ，从而可以获得正确的结果。</p>
<p><img src="https://img-blog.csdnimg.cn/343019073c1b404c84b1478266b65062.png" alt="在这里插入图片描述"><br>可以看到，十进制加法微程序流程图由四条微指令组成，每一条微指令用一个长方框表示。</p>
<p>第一条微指令为“取指”周期。<br>它是一条专门用来取机器指令的微指令，任务有三：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">①从内存取出一条机器指令，并将指令放到指令寄存器R。在我们的例子中，取出的是“十进制加法”指令。</span><br><span class="line">②对程序计数器加1，做好取下一条机器指令的准备。</span><br><span class="line">③对机器指令的操作码用P,进行判别测试，然后修改微地址寄存器内容，给出下一条微指令的地址。</span><br></pre></td></tr></table></figure>
<p>在我们所示的微程序流程图中，每一条微指令的地址用数字示于长方框的右上角。注意，<code>菱形</code>符号代表<code>判别测试</code>，它的动作依附于第一条微指令。第二条微指令完成<code>a十b</code>运算。第三条微指令完成a十b十6运算，同时又进行判别测试。不过这一次的判别标志不是P而是P2,P2用来测试进位标志Cy。根据测试结果，微程序或者转向公操作，或者转向第四条微指令。当微程序转向公操作(用符号<code>~</code>表示)时，如果没有外围设备请求服务，那么又转向取下一条机器指令。与此相应，第三条微指令和第四条微指令的下一个微地址就又指向第一条微指令，即“取指”微指令。</p>
<p>chat例子：<br>好的，以下是一个简单的微指令和微命令的例子，使用真正的二进制代码表示：</p>
<p>假设有一条指令需要将寄存器A中的值加上10，并将结果写入寄存器B中。为了执行这条指令，CPU需要生成一系列的微指令，并将它们发送给各个控制器和寄存器以完成操作。下面是这些微指令的二进制代码表示：</p>
<p>微指令1：<br>10101000 00000001 00000000</p>
<p>解释：</p>
<ul>
<li>前8位代表微指令的操作码，这里是10101000，用于打开内存读使能信号</li>
<li>接下来的8位代表地址总线的值，这里是00000001，表示要读取寄存器A的值</li>
<li>最后的8位代表数据总线的值，这里是00000000，表示不需要向数据总线输出任何数据。</li>
</ul>
<p>微指令2：<br>11000000 00000010 00000000</p>
<p>解释：</p>
<ul>
<li>前8位代表微指令的操作码，这里是11000000，用于将从内存中读取到的值输入到ALU的A端口</li>
<li>接下来的8位代表地址总线的值，这里是00000010，表示要读取常数10的值</li>
<li>最后的8位代表数据总线的值，这里是00000000，表示不需要向数据总线输出任何数据</li>
</ul>
<p>微指令3：<br>11100000 00000011 00000000</p>
<p>解释：</p>
<ul>
<li>前8位代表微指令的操作码，这里是11100000，用于将常数10和寄存器A中的值相加</li>
<li>接下来的8位代表地址总线的值，这里是00000011，表示要向ALU输出结果</li>
<li>最后的8位代表数据总线的值，这里是00000000，表示不需要向数据总线输出任何数据</li>
</ul>
<p>微指令4：<br>10110000 00000100 00000000</p>
<p>解释：</p>
<ul>
<li>前8位代表微指令的操作码，这里是10110000，用于将ALU的输出写入到寄存器B中</li>
<li>接下来的8位代表地址总线的值，这里是00000100，表示要将结果写入寄存器B</li>
<li>最后的8位代表数据总线的值，这里是00000000，表示不需要向数据总线输出任何数据</li>
</ul>
<p>在这个例子中，每个微指令都由3个字节组成，分别表示操作码、地址和数据。每个微指令包含了多个微命令，例如打开内存读使能信号、将地址发送到地址总线上等等。这些微命令通过组合形成微指令，最终实现了指令所需的各项操作。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**CPU周期与微指令周期的关系**</span><br><span class="line"></span><br><span class="line">在串行方式的微程序控制器中：  </span><br><span class="line">`微指令周期＝读出微指令的时间＋执行该条微指令的时间`</span><br><span class="line"></span><br><span class="line">为了保证整个机器控制信号的同步，可以将一个`微指令周期`设计的恰好和 CPU 周期时间相等</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/7ebb9c8bacb640118763de53296234d7.png)  </span><br><span class="line">在前600ns 内进行运算，在 600ns 时间末尾运算完毕，T&lt;sub&gt;4&lt;/sub&gt; 上升沿将运算结果打入某个寄存器。同时，用 T&lt;sub&gt;4&lt;/sub&gt; 间隔读取下条微指令，经 200ns 延迟，下条微指令从 ROM 读出，并用 T&lt;sub&gt;1&lt;/sub&gt; 上升沿打入到 μIR 。如果忽略触发器翻转延迟，下一条微指令的微命令信号从 T&lt;sub&gt;1&lt;/sub&gt; 上升沿开始有效，  </span><br><span class="line">直到下一条微指令读出后打入 μIR 为止。</span><br><span class="line"></span><br><span class="line">**总结**</span><br><span class="line"></span><br><span class="line">1.  一条机器指令对应一个微程序，这个微程序是由若干条微指令序列组成的。简言之，一条机器指令所完成的操作划分成若干条微指令来完成，由微指令进行解释和执行。</span><br><span class="line">2.  从指令与微指令，程序与微程序，地址与微地址的一一对应关系来看，前者与内存储器有关，后者与控制存储器有关。</span><br><span class="line">3.  每一个 CPU 周期对应一条微指令。机器指令和微指令的关系总结</span><br><span class="line"></span><br><span class="line">## 5.5 微程序设计技术</span><br><span class="line"></span><br><span class="line">**微指令结构的设计目标**</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>有利于缩短微指令字长度<br>有利于减小控制存储器的容量<br>有利于提高微程序的执行速度<br>有利于对微指令的修改<br>有利于提高微程序设计的灵活性<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 微命令编码</span><br><span class="line"></span><br><span class="line">微指令的一般格式为：  </span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/3010ebaf87bf4f61889160b80d3d086d.png)</span><br><span class="line"></span><br><span class="line">微命令编码，即操作控制字段设计方法：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>直接表示法<br>编码表示法<br>混合表示法<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**直接表示法（不译法）**</span><br><span class="line"></span><br><span class="line">在微指令的操作控制字段中每一个微命令都用一位信息表示，对应于一种微操作。设计微指令时，选用或不选用某个微命令，只要将表示该微命令的相应位设置成 1 或 0 。</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>优点是简单、直观、执行速度快，微命令的并行控制能力强，编制的微程序短；<br>缺点是微指令字长<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**编码表示法（字段编译法）**  </span><br><span class="line">把一组`相斥性` 的微命令信号组成一个小组( 即一个字段 )，然后通过小组 (字段）译码器对每一个微命令信号进行译码，译码输出作为操作控制信号。</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>优点是使微指令字大大缩短<br>缺点是由于增加译码电路，使微程序的执行速度稍稍减慢<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**编码的原则**</span><br><span class="line"></span><br><span class="line">1.  相斥性命令分在同一字段内，相容性命令分在不同的字段内 。前者可提高信息位的利用率，缩短微指令字长；后者有利于实现并行操作，加快指令的执行速度。</span><br><span class="line">2.  一般将同类操作中互斥的微命令划分在同一个字段中。</span><br><span class="line">3.  每个小字段包含的信息位不能太多，一般不超过位，否则将增加译码线路的复杂性和译码时间。</span><br><span class="line"></span><br><span class="line">&gt; # \*重点题型：微指令编码格式</span><br><span class="line">&gt; </span><br><span class="line">&gt; [微指令编码格式](https://blog.csdn.net/weixin_51340156/article/details/112277552)</span><br><span class="line"></span><br><span class="line">**例如**:</span><br><span class="line"></span><br><span class="line">&gt; 某机器指令系统总共需要256 个微命令  </span><br><span class="line">&gt; 采用直接表示法，微指令的操作控制字段需 256 位  </span><br><span class="line">&gt; 采用编码表示法，如将控制字段分成 4 位一段，共 16段，每个字段经一个译码器输出，可获得 16 个微命令，总共 16 段就可获得 256 个微命令。微指令的操作控制字段仅 64 位。</span><br><span class="line"></span><br><span class="line">**混合表示法**</span><br><span class="line"></span><br><span class="line">把`直接表示法`与`编码表示法`混合使用，以便能综合考虑指令字长、灵活性、执行微程序速度等方  </span><br><span class="line">面的要求。在微指令中还可附设一个常数字段。该常数可作为操作数送入 ALU 运算，也可作为计数器初值用来控制微程序循环次数。</span><br><span class="line"></span><br><span class="line">### 微地址的形成方法</span><br><span class="line"></span><br><span class="line">根据机器指令操作码找到相应机器指令所对应的微程序的入口地址</span><br><span class="line"></span><br><span class="line">后继微地址的产生</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>计数器方式<br>多路转移<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**计数器方式**  </span><br><span class="line">与用PC 产生机器指令地址的方法相类似</span><br><span class="line"></span><br><span class="line">在顺序执行微指令时，后继微地址由现行微地址加上一个增量来产生</span><br><span class="line"></span><br><span class="line">在非顺序执行微指令时，必须通过转移方式，使现行微指令执行后，转去执行指定后继微地址的下一条微指令。</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/badb74fe52c14e32a4a999947cef7dae.png)</span><br><span class="line"></span><br><span class="line">`优点`：微指令的顺序控制字段较短，微地址产生机构简单  </span><br><span class="line">`缺点`：多路并行转移功能较弱，速度较慢，灵活性较差</span><br><span class="line"></span><br><span class="line">**多路转移方式**  </span><br><span class="line">一条微指令具有多个转移分支的能力称为多路转移。  </span><br><span class="line">在多路转移方式中：</span><br><span class="line"></span><br><span class="line">1.  当微程序 不产生分支 时，后继微地址直接由微指令的`顺序控制字段`给出</span><br><span class="line">2.  当微程序 出现分支 时，有若干“后选”微地址可供选择：即按顺序控制字段的`判别测试`标志和`状态条件`信息来选择其中一个微地址</span><br><span class="line">3.  “状态条件”有 n 位标志，可实现微程序 2&lt;sup&gt;n&lt;/sup&gt; 路转移，涉及微地址寄存器的 n 位</span><br><span class="line"></span><br><span class="line">特点：能以较短的顺序控制字段配合，实现多路并行转移，灵活性好，速度较快，但转移地址逻辑需要用组合逻辑方法实现</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/3a68db57b60e4941a02693deff56f7cd.png)</span><br><span class="line"></span><br><span class="line">### 微指令格式</span><br><span class="line"></span><br><span class="line">微指令的编译方法是决定微指令格式的主要因素</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>水平型微指令<br>垂直型微指令<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**水平型微指令**  </span><br><span class="line">一次能定义并执行多个并行操作微命令的微指令  </span><br><span class="line">格式如下：  </span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/cdbea0871a324ad192dbbc8062ebf7cd.png)</span><br><span class="line"></span><br><span class="line">按照控制字段的编码方法不同，水平型微指令分为三种：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>1 ）全水平型 不译码法 微指令<br>2 ）字段译码法（编码表示法）水平型微指令<br>3 ）直接和译码相混合的水平型微指令<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**垂直型微指令**  </span><br><span class="line">在微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能  </span><br><span class="line">其结构类似于机器指令的结构</span><br><span class="line"></span><br><span class="line">实现一条机器指令的微程序要比水平型微指令编写的微程序长得多，它是采用较长的微程序结构去换取较短的微指令结构</span><br><span class="line"></span><br><span class="line">举例：  </span><br><span class="line">设：微指令字长为16 位，微操作码 3位。</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/e1ebc5d42666499e8676531829a0ba6f.png)  </span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/ce84527c08504d11a2c0e077c55f6edc.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/c557ca40513641b2b8574510bb932342.png)  </span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/4f59475419e54013bc9c68a704ce0073.png)</span><br><span class="line"></span><br><span class="line">**水平型微指令与垂直型微指令的对比：**</span><br><span class="line"></span><br><span class="line">1.  水平型微指令并行操作能力强，效率高，灵活性强，垂直型微指令则较差。</span><br><span class="line">2.  水平型微指令执行一条指令的时间短，垂直型微指令执行时间长。</span><br><span class="line">3.  由水平型微指令解释指令的微程序，有微指令字较长而微程序短的特点。垂直型微指令则相反。</span><br><span class="line">4.  水平型微指令用户难以掌握，而垂直型微指令与指令比较相似，相对来说，比较容易掌握。</span><br><span class="line"></span><br><span class="line">**动态微程序设计**</span><br><span class="line"></span><br><span class="line">1.  静态微程序设计  </span><br><span class="line">    对应于一台计算机的机器指令只有一组微程序，这一组微程序设计好之后，一般无须改变而且也不好改变 。</span><br><span class="line">2.  动态微程序设计  </span><br><span class="line">    采用E&lt;sup&gt;2&lt;/sup&gt;PROM 作为控制存储器，可以通过改变微指令和微程序来改变机器的指令系统 。因而可在一台机器上实现不同类型的指令系统。这种技术又称为仿真其它机器指令系统。</span><br><span class="line"></span><br><span class="line">## 5.5 硬布线控制器</span><br><span class="line"></span><br><span class="line">• 硬布线控制器是早期设计计算机的一种方法。  </span><br><span class="line">• 基本思想：把控制部件看作为产生`专门固定时序控制信号`的逻辑电路，逻辑电路以使用`最少元件`和`取得最高操作速度`为设计目标。  </span><br><span class="line">• 这种逻辑电路是一种由`门电路`和`触发器`构成的`复杂树形网络`，故称之为硬`布线控制器`。</span><br><span class="line"></span><br><span class="line">**硬布线控制器的设计过程**</span><br><span class="line"></span><br><span class="line">绘制指令的流程图 ：</span><br><span class="line"></span><br><span class="line">1.  以指令的执行过程为线索，按指令类型分类，将每条指令归纳为一个微操作序列，根据操作的先后顺序画出指令流程图。</span><br><span class="line">2.  列出微操作时间表 ：把指令流程图中的微操作序列合理地安排在各个机器周期的相应节拍和脉冲中去，使它们在执行的时间上不发生冲突。</span><br><span class="line">3.  微操作的逻辑综合 ：以每个微操作为单位进行“同类项合并”，就是把不同指令在不同周期状态，不同节拍和不同条件下所需要的同一微操作用逻辑关系式综合起来，然后加以简化使逻辑表达式更为合理。</span><br><span class="line">4.  电路实现 ：按照最后得到的逻辑表达式组，可用一系列组合逻辑电路加以实现。</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/3d072e68e444461e82ee9d984dc4071e.png)**微操作的逻辑综合**  </span><br><span class="line">在硬布线控制器中，某一微操作控制信号由`布尔代数表达式`描述的输出函数产生。</span><br><span class="line"></span><br><span class="line">设计方法和过程：  </span><br><span class="line">根据所有机器指令流程图，寻找出产生同一个微操作信号的所有条件，并与适当的节拍电位和节拍脉冲组合，从而写出其布尔代数表达式并进行简化，然后用门电路或可编程器件来实现。</span><br><span class="line"></span><br><span class="line">**特别注意** ：控制信号是电位有效还是脉冲有效，如果是脉冲有效，必须加入节拍脉冲信号进行相“与”。</span><br><span class="line"></span><br><span class="line">**硬布线控制器的评价和时序**</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>速度快<br>电路设计太复杂<br>增加功能不太可能<br>采用三级时序<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**硬布线控制器和微程序控制器的比较1**</span><br><span class="line"></span><br><span class="line">硬布线控制器与微程序控制器相同之处：</span><br><span class="line"></span><br><span class="line">1.  根据指令操作码和时序信号，产生各种控制信号，以便正确地建立各种数据通路，完成取指令和执行指令的控制。</span><br><span class="line">2.  硬布线控制的优点是由于控制器的速度取决于电路延迟，所以速度较快。</span><br><span class="line">3.  硬布线控制的主要缺点是由于将控制部件看成专门产生固定时序控制信号的逻辑电路，所以把用最少元件和取得最高速度作为设计目标。一旦设计完成，不可能通过其他的修改添加新功能。</span><br><span class="line">4.  微程序控制的主要优点是，同硬布线控制器相比，具有规整性、灵活性、可维护性等一系列优点。</span><br><span class="line">5.  微程序控制的主要缺点是由于微程序控制器采用了存储程序原理，所以每条指令都要从控存中取一次，因此影响了速度。</span><br><span class="line"></span><br><span class="line">## 5.6 流水CPU</span><br><span class="line"></span><br><span class="line">### 并行处理技术</span><br><span class="line"></span><br><span class="line">并行性包含两种含义：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>同时性：指两个以上事件在 同一时刻 发生；<br>并发性：指两个以上事件在 同一时间间隔 内发生。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">–时间并行  </span><br><span class="line">–空间并行  </span><br><span class="line">–时间并行+空间并行</span><br><span class="line"></span><br><span class="line">### 流水 CPU 的结构</span><br><span class="line"></span><br><span class="line">并行处理技术的三种形式</span><br><span class="line"></span><br><span class="line">1.  `时间并行`指时间重叠，让多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分，以加快硬件周转而赢得速度。时间并行性概念的实现方式就是采用流水处理部件 。</span><br><span class="line">2.  `空间并行`空间并行指资源重复，以“数量取胜”为原则来大幅度提高计算机的处理速度。</span><br><span class="line">3.  `时间并行+空间并行`指时间重叠和资源重复的综合应用，既采用时间并行性，也采用空间并行性</span><br><span class="line"></span><br><span class="line">**流水计算机的系统组成**</span><br><span class="line"></span><br><span class="line">现代流水计算机的系统中CPU 按流水线方式组织，通常由三部分组成：指令部件、指令队列、执行部件。这三个功能部件可以组成一个 3 级流水线。  </span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/cf0fda5863374feea934879940b0bd40.png)  </span><br><span class="line">**执行部件的配合**</span><br><span class="line"></span><br><span class="line">为了使存储器的存取时间能与流水线的其他各过程段的速度相匹配，一般都采用`多体交叉存器`。  </span><br><span class="line">通常采用并行的运算部件以及部件流水线的工作方式来解决 执行段的速度匹配问题 。</span><br><span class="line"></span><br><span class="line">1.  将执行部件分为定点执行部件和浮点执行部件两个可并行执行的部分， 分别处理定点运算指令和浮点运算指令；</span><br><span class="line">2.  在浮点执行部件中，又有浮点加法部件和浮点乘除部件，它们也可以同时执行不同的指令；</span><br><span class="line">3.  浮点运算部件都以流水线方式工作。</span><br><span class="line"></span><br><span class="line">**流水CPU的时空图**  </span><br><span class="line">为了实现流水，首先把输入的任务或过程 分割为一系列子任务，并使各子任务能在流水线的各个阶段并发地执行。当任务连续不断地输入流水线时，在流水线的输出端便连续不断地吐出执行结果，从而实现了子任务级的并行性。</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/8b94b402d9b944e4afacd99fe9745fb6.png)  </span><br><span class="line">`IF`取指令  </span><br><span class="line">`ID`指令译码  </span><br><span class="line">`EX`：执行运算  </span><br><span class="line">`WB`：结果写回</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/bda9d9492ccd4e1ead7cf88360b0efcf.png)对于非流水计算机来说，上一条指令的4 个子过程全部执行完毕后才能开始下一条指令。因此，每 4 个机器周期才有一个输出结果。</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/d771b2377d664304ae051c0900aca1ec.png)对流水计算机来说，上一条指令与下一条指令的四个子过程在时间上可以重叠执行。因此，当流水线满载时，每一个时钟周期就可以输出一个结果。</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/8f6ba3277d784effa2d1184dcbf85bfa.png)  </span><br><span class="line">由图可见：在8 个单位时间内，非流水 CPU 仅可执行 2 条指令；而流水 CPU 执行了 5 条指令；超标量流水 CPU 则执行了 10 条指令。  </span><br><span class="line">因此，流水 CPU 显然具有更强大的数据吞吐能力。</span><br><span class="line"></span><br><span class="line">**流水线分类**  </span><br><span class="line">`指令流水线` 指指令处理步骤的并行。将指令流的处理过程划分为取指令、译码、执行、写回等几个并行处理的过程段。</span><br><span class="line"></span><br><span class="line">`算术流水线` 指运算操作步骤的并行。如流水加法器、流水乘法器、流水除法等。</span><br><span class="line"></span><br><span class="line">`处理机流水线` 又称为`宏流水线`，是指程序步骤的并行。由一串级联的处理机构成流水线的各个阶段，每台处理机负责某一特定的任务。</span><br><span class="line"></span><br><span class="line">### 流水线中的主要问题</span><br><span class="line"></span><br><span class="line">流水过程中通常会出现以下三种相关冲突使流水线断流</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>–资源相关<br>–数据相关<br>–控制相关<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">`资源相关`是指多条指令进入流水线后，在同一机器时钟周期内争用同一个功能部件所发生的冲突。  </span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/c651b4b8cb514b49ab465bae8b1b31aa.png)</span><br><span class="line"></span><br><span class="line">**解决资源相关冲突的办法**</span><br><span class="line"></span><br><span class="line">1.  执行 IF 过程时，若存在资源相关，则采用延迟 IF法避开相关。</span><br><span class="line">2.  增设一个存储器，将指令和数据分别放在两个存储器中。或采用多端口存储器结构。  </span><br><span class="line">    ![在这里插入图片描述](https://img-blog.csdnimg.cn/95e8663bf72d4e77b42a2a546bccebf4.png)**数据相关**</span><br><span class="line"></span><br><span class="line">在一个程序中，如果必须等前一条指令执行完毕后，才能执行后一条指令，那么这两条指令就是 `数据相关` 的。</span><br><span class="line"></span><br><span class="line">由于多条指令的重叠处理，当后继指令所需的操作数，刚好是前一指令的运算结果时，便发生数据相关冲突。</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/2914a4c8450241d1b1bceb3d27f67f33.png)  </span><br><span class="line">**解决数据相关冲突的办法**  </span><br><span class="line">在流水CPU 的运算器中设置若干运算结果缓冲寄存器，暂时保留运算结果，以便于后继指令直接使用，这称为：`“向前”或定向传送技术`。</span><br><span class="line"></span><br><span class="line">**控制相关**</span><br><span class="line"></span><br><span class="line">控制相关冲突是由转移指令引起的。当执行转移指令时，依据转移条件的产生结果，可能会顺序取下条指令；也可能转移到新的目标地址取指令，从而使流水线`发生断流` 。  </span><br><span class="line">为了减小转移指令对流水线性能的影响，常用以下两种转移处理技术：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>–延迟转移法<br>–转移预测法<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**延迟转移法**  </span><br><span class="line">由编译程序重排指令序列来实现。基本思想是“先执行再转移 ”，即：发生转移取时并不排空指令流水线，而是让紧跟在转移指令 Ib 之后已进入流水线的少数几条指令继续完成。如果这些指令是与 Ib 结果无关的有用指令，那么延迟损失时间片正好得到了有效的  </span><br><span class="line">利用。</span><br><span class="line"></span><br><span class="line">**转移预测法**  </span><br><span class="line">用硬件方法来实现，依据指令过去的行为来预测将来的行为。通过使用 转移取 和 顺序取 两路指令预取队列器以及目标指令 cache ，可将转移预测提前到取指阶段进行，以获得良好的效果。</span><br><span class="line"></span><br><span class="line">### 奔腾 CPU</span><br><span class="line"></span><br><span class="line">不考，略</span><br><span class="line"></span><br><span class="line">## 5.7 RISC CPU</span><br><span class="line"></span><br><span class="line">### RISC 机器的特点</span><br><span class="line"></span><br><span class="line">RISC的三个基本要素</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>一个有限的简单的指令集<br>CPU 配备大量的通用寄存器<br>强调对指令流水线的优化<br>```</p>
<p><strong>RISC机器的特征</strong></p>
<p>⑴使用等长指令，典型长度是 4 个字节 (32 位）。<br>⑵寻址方式少且简单，一般为 2 、 3 种，最多不超过 4种，绝不出现存储器间接寻址方式。<br>⑶只有取数指令和存数指令访问存储器。指令中最多出现 RS 型指令，绝不出现 SS 型指令。<br>⑷指令集中的指令数目一般少于 100 种，指令格式一般少于 4 种。<br>⑸指令功能简单，控制器多采用硬布线方式，以期更快的执行速度。<br>⑹平均而言，所有指令的执行时间为一个处理时钟周期。<br>⑺指令格式中用于指派整数寄存器的个数不少于 32个，用于指派浮点数寄存器的个数不少于 16 个。<br>⑻强调通用寄存器资源的优化使用。<br>⑼支持指令流水并强调指令流水的优化使用。<br>⑽RlSC 技术的复杂性在它的编译程序，因此软件系统开发时间比 CISC 机器长。</p>
<p><img src="https://img-blog.csdnimg.cn/7a6a6899867f4538850229fc4efe66e2.png" alt="在这里插入图片描述"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://jayerine.top">Jay and Erine</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://jayerine.top/2024/02/06/af75ba95c6e9/">https://jayerine.top/2024/02/06/af75ba95c6e9/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%BB%84/">计组</a></div><div class="post_share"><div class="social-share" data-image="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E5%B0%81%E9%9D%A2/%E8%AE%A1%E7%BB%84%E4%BA%94%E5%B0%81%E9%9D%A2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/02/06/edea1504322d/" title="lichess记录"><img class="cover" src="https://s1.ax1x.com/2023/03/02/ppFEcvR.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">lichess记录</div></div></a></div><div class="next-post pull-right"><a href="/2024/02/06/b7e90535f5c5/" title="计算机组成原理 第二章"><img class="cover" src="https://s1.ax1x.com/2023/03/05/ppEhuD0.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next</div><div class="next_info">计算机组成原理 第二章</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/02/06/bd5959ed5f70/" title="计算机组成原理 第三章"><img class="cover" src="https://s1.ax1x.com/2023/03/20/pptblcV.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-06</div><div class="title">计算机组成原理 第三章</div></div></a></div><div><a href="/2024/02/06/b7116e56a5fc/" title="计算机组成原理 第一章"><img class="cover" src="https://s1.ax1x.com/2023/03/05/ppE2Y0U.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-06</div><div class="title">计算机组成原理 第一章</div></div></a></div><div><a href="/2024/02/06/b7e90535f5c5/" title="计算机组成原理 第二章"><img class="cover" src="https://s1.ax1x.com/2023/03/05/ppEhuD0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-06</div><div class="title">计算机组成原理 第二章</div></div></a></div><div><a href="/2024/02/06/0364e15ddae1/" title="计算机组成原理 第四章"><img class="cover" src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E5%B0%81%E9%9D%A2/%E8%AE%A1%E7%A7%9F%E5%9B%9B%E5%B0%81%E9%9D%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-06</div><div class="title">计算机组成原理 第四章</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s1.ax1x.com/2023/02/27/ppCAPEQ.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Jay and Erine</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/JayLXL/BlogDevelopment"><i class="fab fa-github"></i><span>Github</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Jay and Erine are best friend.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">第五章 中央处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E7%BB%84%E6%88%90"><span class="toc-number">1.1.</span> <span class="toc-text">CPU的功能和组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.1.</span> <span class="toc-text">CPU的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="toc-number">1.1.2.</span> <span class="toc-text">CPU的基本组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%8E%E6%97%B6%E5%BA%8F%E4%BA%A7%E7%94%9F%E5%99%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">操作控制器与时序产生器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="toc-number">1.2.</span> <span class="toc-text">5.2 指令周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">指令的执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MOV%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.2.</span> <span class="toc-text">MOV指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LAD%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.3.</span> <span class="toc-text">LAD指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ADD%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.4.</span> <span class="toc-text">ADD指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STO%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.5.</span> <span class="toc-text">STO指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMP%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.6.</span> <span class="toc-text">JMP指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E9%A2%98%E5%9E%8B%EF%BC%9ACPU%E5%8F%82%E6%95%B0%E8%AE%A1%E7%AE%97"><span class="toc-number">2.</span> <span class="toc-text">*重点题型：CPU参数计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%96%B9%E6%A1%86%E5%9B%BE%E8%AF%AD%E8%A8%80%E8%A1%A8%E7%A4%BA%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="toc-number">2.0.1.</span> <span class="toc-text">用方框图语言表示指令周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E6%97%B6%E5%BA%8F%E4%BA%A7%E7%94%9F%E5%99%A8%E5%92%8C%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">5.3 时序产生器和控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E4%B8%89%E7%BA%A7%E6%97%B6%E5%BA%8F%E4%BD%93%E5%88%B6"><span class="toc-number">2.1.1.</span> <span class="toc-text">硬布线控制器的三级时序体制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.2.</span> <span class="toc-text">控制方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">5.4 微程序控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.1.</span> <span class="toc-text">微程序控制原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">2.2.2.</span> <span class="toc-text">微程序控制器的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.3.</span> <span class="toc-text">微程序控制器工作过程</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/02/06/137184bfb43a/" title="面试记录"><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E5%B0%81%E9%9D%A2/Jay%E7%AE%80%E5%8E%86%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试记录"/></a><div class="content"><a class="title" href="/2024/02/06/137184bfb43a/" title="面试记录">面试记录</a><time datetime="2024-02-06T04:00:21.577Z" title="Created 2024-02-06 12:00:21">2024-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/06/bb4263303c4c/" title="git使用"><img src="https://s1.ax1x.com/2023/03/10/ppnbMQ0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="git使用"/></a><div class="content"><a class="title" href="/2024/02/06/bb4263303c4c/" title="git使用">git使用</a><time datetime="2024-02-06T04:00:21.577Z" title="Created 2024-02-06 12:00:21">2024-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/06/0e751f91670a/" title="两棵树（可持久线段树+Hash+高精度数）"><img src="https://s1.ax1x.com/2023/03/02/ppFFvaF.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="两棵树（可持久线段树+Hash+高精度数）"/></a><div class="content"><a class="title" href="/2024/02/06/0e751f91670a/" title="两棵树（可持久线段树+Hash+高精度数）">两棵树（可持久线段树+Hash+高精度数）</a><time datetime="2024-02-06T04:00:21.577Z" title="Created 2024-02-06 12:00:21">2024-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/06/f554b43ffd79/" title="vscode配置opencv C++ 环境与人脸检测（不是人脸识别）算法的尝试"><img src="https://s1.ax1x.com/2023/03/02/ppFFjVU.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vscode配置opencv C++ 环境与人脸检测（不是人脸识别）算法的尝试"/></a><div class="content"><a class="title" href="/2024/02/06/f554b43ffd79/" title="vscode配置opencv C++ 环境与人脸检测（不是人脸识别）算法的尝试">vscode配置opencv C++ 环境与人脸检测（不是人脸识别）算法的尝试</a><time datetime="2024-02-06T04:00:21.577Z" title="Created 2024-02-06 12:00:21">2024-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/06/feae35703595/" title="奇怪名词解释"><img src="https://blog-pics.obs.cn-north-4.myhuaweicloud.com/%E5%B0%81%E9%9D%A2/%E5%A5%87%E6%80%AA%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%E5%B0%81%E9%9D%A2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="奇怪名词解释"/></a><div class="content"><a class="title" href="/2024/02/06/feae35703595/" title="奇怪名词解释">奇怪名词解释</a><time datetime="2024-02-06T04:00:21.577Z" title="Created 2024-02-06 12:00:21">2024-02-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Jay and Erine</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="https://gcore.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><script type="text/javascript" src="/js/fairyDustCursor.js"></script><script id="canvas_nest" defer="defer" color="255,240,245" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>